{"title":"scala2学习笔记（v2.12.11）","uid":"d339d355269868e4606a9ed4016aeb8f","slug":"scala2学习笔记（v2-12-11）","date":"2022-06-02T08:54:37.000Z","updated":"2022-06-02T09:13:33.529Z","comments":true,"path":"api/articles/scala2学习笔记（v2-12-11）.json","keywords":null,"cover":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202206021658720.jpeg","content":"<h1 id=\"什么是Scala？\"><a href=\"#什么是Scala？\" class=\"headerlink\" title=\"什么是Scala？\"></a>什么是Scala？</h1><p><a href=\"https://scala-lang.org/\">Scala </a>是一门基于JVM和Java完全兼容的语言，具有跨平台，可移植性，完备的垃圾回收机制等特定</p>\n<p>Scala比Java更加面向对象，他是一门纯面向对象的语言，我们知道Java并不是，比如他具有基本类型。</p>\n<p>Scala是一门函数式编程语言，Java并不是，JDK8增加的Lambda是函数式。</p>\n<p>Scala的非常适合大数据处理，我们熟悉的Spark、Flink、Kafka等底层都是使用Scala实现的。</p>\n<p>Scala目前主流版本是2，目前版本3也已经Released。先学习2，再学习3。</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231147213.png\" alt=\"Scala官网\"></p>\n<h1 id=\"为什么学习Scala？\"><a href=\"#为什么学习Scala？\" class=\"headerlink\" title=\"为什么学习Scala？\"></a>为什么学习Scala？</h1><p>Scala的好处上面已经提到过了，这些是我们学习Scala的理由，单不完全是我的理由。</p>\n<p>我的理由主要是：</p>\n<pre class=\"line-numbers language-tex\" data-language=\"tex\"><code class=\"language-tex\">公司业务是物联网（IOT），工作需要大数据相关技术，所以学习。\n\n个人也比较喜欢新技术，除了Scala，我也学习目前流行的Golang语言。</code></pre>\n\n<p>建议：学习新技术要根据自己实际情况而定，首先要工作需要的技术，这能够提高技术同时是的自己在岗位上更加突出，更加胜任工作，其次学习时间比较多。</p>\n<h1 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h1><p>我目前学习Scala的主要渠道主要有两处，官网和尚硅谷视频。</p>\n<p>官网是必须要看的，并且强烈推荐看英文原版内容，有些中文网翻译水平实在有限，并且有错误。</p>\n<p>我虽然主要看官网，但是官网资料比较松散，自己又不太爱总结，也觉得浪费时间，我是初学一门语言，在学习Scala的路上，我就是个菜鸟。尚硅谷的视频还是非常不错的（不是打广告哈哈）。</p>\n<p>我学习的过程中主要是跟着尚硅谷的视频学习，但是不完全操作其内容，主要是根据他的目录来学习。</p>\n<p>另外这里建议下，没学过Java的不要学习scala！！！</p>\n<h1 id=\"Scala入门\"><a href=\"#Scala入门\" class=\"headerlink\" title=\"Scala入门\"></a>Scala入门</h1><h2 id=\"Scala、Java、JVM的关系\"><a href=\"#Scala、Java、JVM的关系\" class=\"headerlink\" title=\"Scala、Java、JVM的关系\"></a>Scala、Java、JVM的关系</h2><p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231300992.jpeg\" alt=\"Scala、Java和JVM关系\"></p>\n<p>Java和JVM的关系：写代码(.java) &#x3D;&gt; 使用<code>javac</code>命令编译为<code>.class</code>文件 &#x3D;&gt; 使用JVM运行</p>\n<p>Scala和JVM的关系：写代码(.scala) &#x3D;&gt;使用<code>scalac</code>命令编译为<code>.class</code>文件 &#x3D;&gt; 使用JVM运行</p>\n<p>两者极其类似！！！</p>\n<p>Scala能够使用Java类库！！！</p>\n<h2 id=\"Scala环境安装\"><a href=\"#Scala环境安装\" class=\"headerlink\" title=\"Scala环境安装\"></a>Scala环境安装</h2><p>前提：scala基于JVM，要求我们环境要安装JDK。JDK的安装请自行查询，检查JDK是否安装</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">➜  ~ java -version\nopenjdk version &quot;17.0.3&quot; 2022-04-19 LTS\nOpenJDK Runtime Environment Corretto-17.0.3.6.1 (build 17.0.3+6-LTS)\nOpenJDK 64-Bit Server VM Corretto-17.0.3.6.1 (build 17.0.3+6-LTS, mixed mode, sharing)</code></pre>\n\n<p>我电脑安装的是OpenJDK17，只要大于8即可。</p>\n<p>Scala支持Mac、Windows、Linux等系统。有多种安装方式，</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231305748.png\" alt=\"image-20220523130559667\"></p>\n<p>官方推荐使用<code>cs setup</code>安装</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">➜  ~ brew install coursier&#x2F;formulas&#x2F;coursier &amp;&amp; cs setup\nUpdating Homebrew...\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;a34af3e5d8010f4b87297cbcf23a7090d907d343dfbb691e9ddea9facb4b1605--coursier\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;e56f4bc31b6326034ab85448faa48e50054affc7b327e3e82180fc861633fc54--cs-x86_64-apple-darwin.gz\n&#x3D;&#x3D;&gt; Installing coursier from coursier&#x2F;formulas\n^C^C\nOne sec, cleaning up...\n\n➜  ~ \n➜  ~ brew install coursier&#x2F;formulas&#x2F;coursier &amp;&amp; cs setup\nUpdating Homebrew...\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;a34af3e5d8010f4b87297cbcf23a7090d907d343dfbb691e9ddea9facb4b1605--coursier\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;e56f4bc31b6326034ab85448faa48e50054affc7b327e3e82180fc861633fc54--cs-x86_64-apple-darwin.gz\n&#x3D;&#x3D;&gt; Installing coursier from coursier&#x2F;formulas\n&#x3D;&#x3D;&gt; Caveats\nzsh completions have been installed to:\n  &#x2F;usr&#x2F;local&#x2F;share&#x2F;zsh&#x2F;site-functions\n&#x3D;&#x3D;&gt; Summary\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;coursier&#x2F;2.1.0-M5-18-gfebf9838c: 5 files, 57.4MB, built in 49 seconds\nChecking if a JVM is installed\nFound a JVM installed under &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;corretto-17.0.3&#x2F;Contents&#x2F;Home.\n\nChecking if ~&#x2F;Library&#x2F;Application Support&#x2F;Coursier&#x2F;bin is in PATH\n\nChecking if the standard Scala applications are installed\n  Installed ammonite\n  Installed cs\n  Installed coursier\n  Installed scala\n  Installed scalac\n  Installed sbt\n  Installed sbtn\n  Installed scalafmt</code></pre>\n\n<p>默认安装的scala是最新版本（3.1.2）</p>\n<p>因为我主要是跟着尚硅谷视频学习，所以同步使用他的版本（2.12.11）</p>\n<p>安装参考如下地址：<a href=\"https://scala-lang.org/download/2.12.11.html\">https://scala-lang.org/download/2.12.11.html</a></p>\n<p>通过命令行用<code>cs</code>工具安装</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">➜  ~ cs install scala:2.12.11 &amp;&amp; cs install scalac:2.12.11\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;io&#x2F;get-coursier&#x2F;apps&#x2F;maven-metadata.xml\n  No new update since 2022-05-16 17:11:57\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-compiler&#x2F;2.12.11&#x2F;scala-comp…\n  100.0% [##########] 2.6 KiB (10.9 KiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-reflect&#x2F;2.12.11&#x2F;scala-refle…\n  100.0% [##########] 1.8 KiB (8.0 KiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-compiler&#x2F;2.12.11&#x2F;scala-comp…\n  100.0% [##########] 10.2 MiB (4.0 MiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-reflect&#x2F;2.12.11&#x2F;scala-refle…\n  100.0% [##########] 3.5 MiB (1.1 MiB &#x2F; s)\nWrote scala\nWrote scalac\n\n➜  ~ scala -version\nScala code runner version 2.12.11 -- Copyright 2002-2020, LAMP&#x2F;EPFL and Lightbend, Inc.</code></pre>\n\n<p>温馨提示：如果使用二进制安装，需要配置环境变量。</p>\n<p>交互式命令行，输入<code>scala</code>命令接口打开：</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">➜  ~ scala\nWelcome to Scala 2.12.11 (OpenJDK 64-Bit Server VM, Java 17.0.3).\nType in expressions for evaluation. Or try :help.\n\nscala&gt; val a:Int &#x3D; 10\na: Int &#x3D; 10\n\nscala&gt; val b:Int &#x3D;5\nb: Int &#x3D; 5\n\nscala&gt; a + b\nres0: Int &#x3D; 15\n\nscala&gt; </code></pre>\n\n\n\n<p>写代码并编译执行，创建一个Hello.scala文件，文件内容如下</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">object Hello &#123;\n\tdef main(ags: Array[String]): Unit &#x3D; &#123;\n\t\tprintln(&quot;hello&quot;)\n\t&#125;\n&#125;</code></pre>\n\n<p>使用<code>scalac</code>编译文件，使用<code>scala</code>指令运行</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">➜  Scala2-Tutorials git:(main) ✗ scalac Hello.scala \n➜  Scala2-Tutorials git:(main) ✗ scala Hello         \nhello</code></pre>\n\n\n\n<h2 id=\"编程工具\"><a href=\"#编程工具\" class=\"headerlink\" title=\"编程工具\"></a>编程工具</h2><p>官方推荐使用<code>VSCode</code>和<code>IDEA</code>，我个人非常喜欢使用<code>IDEA</code>，接下来我也会在IDEA上进行开发。</p>\n<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>使用<code>IDEA</code>开发scala需要安装插件。</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231446809.png\" alt=\"IDEA安装Scala插件\"></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231515233.png\" alt=\"IDEA创建Scala项目\"></p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231546413.png\" alt=\"等待中\"></p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231528324.png\" alt=\"创建完成\"></p>\n<p>Scala支持使用<code>SBT</code>和<code>IntelliJ</code>创建项目，我用的是<code>sbt</code>。其他的方式我就不演示了。</p>\n<h2 id=\"HelloWorld\"><a href=\"#HelloWorld\" class=\"headerlink\" title=\"HelloWorld\"></a>HelloWorld</h2><p>创建package</p>\n<p>在上图中<code>scala</code>文件夹上邮件，选择创建package</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231531551.png\" alt=\"创建package\"></p>\n<p>创建一个Object，scala中的<code>Object</code>是一个单例类，全局只有一份</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231533007.png\" alt=\"新建Scala Class，选中Object\"></p>\n<p>编写入口程序main方法的代码</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231535529.png\" alt=\"Hello World main代码\"></p>\n<p>解析下上面的main方法</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala\n\n&#x2F;**\n * object：scala中的一个关键字，声明一个单例对象，也叫做伴生对象\n *&#x2F;\nobject HelloWorld &#123;\n  &#x2F;**\n   * 程序的入口方法， def是关键字，用于定义方法，括号内是参数信息，args是参数名，通过：类型定义数据类型，\n   * 此main方法中args参数的类型是是字符串数组，其实这跟java的类似，只不过表现形式不同而已。括号后面的:Unit代表返回类型，Unit在scala中代表空，类似于Java中的Void\n   * @param args\n   *&#x2F;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(&quot;Hello World&quot;)\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"伴生对象\"><a href=\"#伴生对象\" class=\"headerlink\" title=\"伴生对象\"></a>伴生对象</h2><p><code>object</code>关键字是用于创建伴生对象，什么是伴生对象呢？伴随谁而生？想想我们再Java中使用<code>static</code>定义一个对象，如何访问呢？我们需要使用类名.属性来访问。看下下面的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package io.itlab1024.github.scala;\n\n&#x2F;**\n * 饮料类\n *&#x2F;\npublic class Drink &#123;\n    private static final String MAJOR &#x3D; &quot;水&quot;;\n    &#x2F;**\n     * 水果成分\n     *&#x2F;\n    private String fruits;\n\n    public String getFruits() &#123;\n        return fruits;\n    &#125;\n\n    public void setFruits(String fruits) &#123;\n        this.fruits &#x3D; fruits;\n    &#125;\n    \n    public void show() &#123;\n        System.out.println(&quot;MAJOR&#x3D;&quot; + Drink.MAJOR + &quot;, Fruits&#x3D;&quot; + this.fruits);\n    &#125;\n&#125;</code></pre>\n\n<p>上面代码是java中的定义，<code>Drink</code>代表饮料类，有两个成员变量类，<code>MAJOR</code>代表主成分（饮料主成分都是水），使用<code>static</code>定义，还有一个<code>fruits</code>代表水果，我们看下第22行中<code>Drink.MAJOR</code>使用的是类名字.属性访问，这在java中是正确的，但是这并不符合面向对象的设计，因为我并没有通过对象获取属性，scala中伴生对象就是创造一个伴生类的对象（伴生对象）。这更符合面向对象的思想。</p>\n<p>上面的例子我通过scala的class和object实现(用新的名字ScalaDrink，否则类冲突，当然也可以修改内容中的class后的名字，而不是修改文件名。)</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter01\nimport io.github.itlab1024.scala.chapter01.ScalaDrink\n\n&#x2F;**\n * Scala中Drink类\n *&#x2F;\nclass ScalaDrink (fruits: String)&#123;\n  def show (): Unit &#x3D; &#123;\n    println(&quot;MAJOR&#x3D;&quot; + ScalaDrink.MAJOR + &quot;, Fruits&#x3D;&quot; + this.fruits)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 伴生对象\nobject ScalaDrink &#123;\n  var MAJOR: String &#x3D; &quot;水&quot;\n&#125;</code></pre>\n\n<p>IDEA工具很有好的为我们编辑了类和伴生对象的关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205231617342.png\" alt=\"伴生对象关系\"></p>\n<p>个人体会：scala为了满足纯面向对象的设计，搞得复杂了，语言我觉得越简单越好。</p>\n<h1 id=\"变量和数据类型\"><a href=\"#变量和数据类型\" class=\"headerlink\" title=\"变量和数据类型\"></a>变量和数据类型</h1><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>Scala中的注释跟Java中的完全一样，分为单行注释、多行注释和文档注释</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 文档注释\n *&#x2F;\nobject Test01_Comment &#123;\n  &#x2F;*\n  多行注释\n  main方法的定义\n  *&#x2F;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 单行注释\n    println(&quot;hello&quot;)\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"常量和变量\"><a href=\"#常量和变量\" class=\"headerlink\" title=\"常量和变量\"></a>常量和变量</h2><p>常量使用<code>val</code> 声明，变量说过<code>var</code>声明</p>\n<p>var 常量名[: 类型] &#x3D; 初始值</p>\n<p>val 变量名[: 类型] &#x3D; 初始值</p>\n<p>注意：能用常量的地方不用变量</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\nimport io.github.itlab1024.scala.chapter01.ScalaDrink\n\nobject Test02_Variable &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义变量\n    var i: Int &#x3D; 10\n    &#x2F;&#x2F; 定义常量\n    val j: Int &#x3D; 20\n\n    &#x2F;&#x2F; 类型确定后不能修改，scala其实是强类型语言\n    &#x2F;&#x2F;    i &#x3D; &quot;不能修改类型&quot; &#x2F;&#x2F; 编译错误\n\n    &#x2F;&#x2F;    j &#x3D; 10; &#x2F;&#x2F; 常量的值不能被修改\n\n    &#x2F;&#x2F; 变量声明的时候必须要有初始值\n    &#x2F;&#x2F; var a: Int &#x2F;&#x2F; 这是编译不通过的,java中是允许的\n\n\n    &#x2F;&#x2F; 如果是引用类型，对象不能概念，但是对象里面的变量属性（通过var修饰）是可以修改的，常量属性（不使用var修饰或者使用val修饰）依然是不能修改的。\n    val apple &#x3D; new ScalaDrink(&quot;苹果&quot;)\n    &#x2F;&#x2F;    apple &#x3D; new ScalaDrink(&quot;橘子&quot;) &#x2F;&#x2F; 编译不通过\n    &#x2F;&#x2F;    apple.fruits &#x3D; &quot;橘子&quot; &#x2F;&#x2F; 编译不通过，因为之前创建的ScalaDrink类的fruits属性没有使用var修饰。\n  &#125;\n&#125;</code></pre>\n\n<p>除了修饰符不同以外，跟java类似。</p>\n<h2 id=\"标识符命名规范\"><a href=\"#标识符命名规范\" class=\"headerlink\" title=\"标识符命名规范\"></a>标识符命名规范</h2><p>什么是标识符？scala中对变量、常量、方法、函数名字统称为标识符</p>\n<p>scala中的标识符命名规则基本与java一致。</p>\n<ol>\n<li><p>标识符由字母、数字、下划线组成，但是首字母必须是字母或者下划线</p>\n</li>\n<li><p>以操作符开头，且只能包含操作符（#-*&#x2F;#!等）</p>\n</li>\n<li><p>用反引号&#96;&#96;将任意字符串包起来，这是合法的标识符，即便是scala中的关键字也是可以的，</p>\n<p>scala中的关键字主要有</p>\n<ul>\n<li><code>package</code>，<code>import</code>，<code>class</code>，**<code>object</code><strong>，</strong><code>trait</code><strong>，<code>extends</code>，</strong><code>with</code>**，<code>type</code>，</li>\n</ul>\n<p><code>for</code></p>\n<ul>\n<li><code>private</code>，<code>protected</code>，<code>abstract</code>，**<code>scaled</code><strong>，<code>final</code>，</strong><code>implicit</code>**，<code>lazy</code>，<code>override</code></li>\n<li><code>if</code>，<code>else</code>，**<code>match</code><strong>，<code>case</code>，<code>do</code>，<code>while</code>，<code>for</code>，<code>return</code>，</strong><code>yield</code>**</li>\n<li><strong><code>def</code>，<code>var</code>，<code>val</code></strong></li>\n<li><code>this</code>，<code>super</code></li>\n<li><code>new</code></li>\n<li><code>true</code>, <code>false</code>, <code>null</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 标识符规范测试\n *&#x2F;\nobject Test03_Identifier &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    （1）标识符由字母、数字、下划线组成，但是首字母必须是字母或者下划线\n    val scala: String &#x3D; &quot;scala&quot;\n    val scala134: Int &#x3D; 1\n    val _scala: String &#x3D; &quot;scala&quot;\n    &#x2F;&#x2F;    val 1scala: Int &#x3D; 1 &#x2F;&#x2F;编译不通过，不能以为数字开头\n    &#x2F;&#x2F;    val a+b &#x3D; 1 &#x2F;&#x2F; IDEA工具并不提示错误，但是实际上是不允许的，会提示not found: value +\n\n\n    &#x2F;&#x2F; (2)以操作符开头，且只能包含操作符（#-*&#x2F;#!等）\n    &#x2F;&#x2F; 搞不懂谁会这么干，有实际应用场景吗？？？\n    val +-*&#x2F; &#x3D; 10 &#x2F;&#x2F;正确\n    val +#%^&amp;^*&amp;&amp;* &#x3D; 10 &#x2F;&#x2F;正确\n    println(+#%^&amp;^*&amp;&amp;*)\n\n    &#x2F;&#x2F; (3) 用反引号&#96;&#96;将任意字符串包起来，这是合法的标识符，即便是scala中的关键字也是可以的，\n    &#x2F;&#x2F; 上面有个定义a+b是允许的，但是如果使用反引号引起来就是允许的\n    val &#96;a+b&#96; &#x3D; 1\n    println(&#96;a+b&#96;)\n    &#x2F;&#x2F; 关键字也是允许的\n    &#x2F;&#x2F;    val if &#x3D; 1 &#x2F;&#x2F;编译不通过\n    val &#96;if&#96; &#x3D; 1\n    println(&#96;if&#96;) &#x2F;&#x2F;正确\n\n  &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"字符串输出\"><a href=\"#字符串输出\" class=\"headerlink\" title=\"字符串输出\"></a>字符串输出</h2><p>字符串可以通过<code>+</code>操作符进行相加，例如<code>&quot;a&quot; + &quot;b&quot; </code>结果是<code>ab</code></p>\n<p><code>printf</code>格式化输出，通过<code>%</code>来显示不同内容，类似java中的<code>System.out.printf</code>以及Go中的<code>fmt.Printf</code>。</p>\n<p>插值字符串，在字符串总通过<code>$</code>获取变量进行拼接</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\nobject Test04_String &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 字符串连接\n    val a &#x3D; &quot;I am learning &quot;\n    val b &#x3D; &quot;scala&quot;\n    println(a + b) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; printf格式化输出\n    printf(&quot;%s%s\\n&quot;, a, b) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; 插值字符串（模板字符串）\n    println(s&quot;$a$b&quot;) &#x2F;&#x2F; I am learning scala， s是一个函数， 定义源码：def s(args: Any*): String &#x3D; standardInterpolator(treatEscapes, args)\n\n    &#x2F;&#x2F; 也可以使用$&#123;&#125;，通过+运算符进行连接\n    println(s&quot;$&#123;a + b&#125;&quot;) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; $&#123;&#125;其实可以写scala代码，调用函数等等都是支持的\n    println(s&quot;$&#123;1 + 2 + math.pow(1, 2)&#125;&quot;) &#x2F;&#x2F; 4.0\n\n    &#x2F;&#x2F;格式化小数，比如小数位数,需要注意的是这就不能使用s函数，如果使用会原样输出，需要使用f函数。\n    val f: Float &#x3D; 11.2356F\n    println(f&quot;$f%2.2f&quot;) &#x2F;&#x2F;11.24   这就是说小数点前面要保证两位，小数点后也是两位，多余位数四舍五入，舍弃\n    &#x2F;&#x2F; 也可以省略.前面的数字\n    println(f&quot;$f%.2f&quot;) &#x2F;&#x2F;11.24\n    &#x2F;&#x2F; 前面的数字有范围吗?\n    println(f&quot;$f%100.2f&quot;) &#x2F;&#x2F;输出空，为什么？我也不知道，有空看看源码吧，我估计还有很多细节，平时可能不会用到，但是面试或者考试估计就会出题，我们知道套路就是这样\n\n    &#x2F;&#x2F;raw函数的使用\n    println(raw&quot;$f%2.2f&quot;) &#x2F;&#x2F; 11.2356%2.2f，除了$获取变量值外，其他的字符原样输出了\n    println(s&quot;$f%2.2f&quot;) &#x2F;&#x2F; 11.2356%2.2f\n    &#x2F;&#x2F; s函数和raw函数结果一样，那么他俩有啥区别呢\n    println(raw&quot;$f%2.2f\\t回车&quot;) &#x2F;&#x2F; 11.2356%2.2f\\t回车， 真正的原样输出\n    println(s&quot;$f%2.2f\\t回车&quot;) &#x2F;&#x2F; 11.2356%2.2f\t回车， \\t未原样输出，被解析制表符\n\n\n    &#x2F;&#x2F; 三引号字符串，stripMargin是字符串的函数，忽略边界\n    val s1: String &#x3D;\n      &quot;&quot;&quot;\n        |i\n        |am\n        |learning\n        |scala\n        |&quot;&quot;&quot;.stripMargin\n    println(s1) &#x2F;&#x2F; 原样输出，注意不会输出|,会有回车换行\n\n    &#x2F;&#x2F; 三引号字符串同样可以使用s,raw等函数\n    val s2 &#x3D;\n      s&quot;&quot;&quot;\n         |The\n         |value\n         |is\n         |$a\n         |&quot;&quot;&quot;.stripMargin\n     println(s2)\n\n    &#x2F;&#x2F; raw\n    val s3 &#x3D;\n      raw&quot;&quot;&quot;\n           |$a \\txx\n           |&quot;&quot;&quot;.stripMargin\n   println(s3)\n\n\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"键盘输入\"><a href=\"#键盘输入\" class=\"headerlink\" title=\"键盘输入\"></a>键盘输入</h2><p>键盘输入一般在开发交互式的程序中很有用。</p>\n<p>常用基本语法</p>\n<p><code>StdIn.readLine()</code>,<code>StdIn.readShort()</code>,<code>StdIn.readDouble()</code>，<code>StdIn.readInt()</code>等等</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\nimport scala.io.StdIn\n\nobject Test05_StdIn &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(&quot;请输入姓名&quot;)\n    val name &#x3D; StdIn.readLine()\n    println(&quot;请输入年龄&quot;)\n    val age &#x3D; StdIn.readInt()\n    println(s&quot;$name 的年龄是$age&quot;)\n  &#125;\n&#125;\n</code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205250946966.png\" alt=\"绿色部分是用户输入部分\"></p>\n<h2 id=\"文件输入输出（IO）\"><a href=\"#文件输入输出（IO）\" class=\"headerlink\" title=\"文件输入输出（IO）\"></a>文件输入输出（IO）</h2><p>文件输入主要使用到是scala中的<code>scala.io</code>包内容，但是scala并没有提供文件输出api，需要调用java的API实现</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\nimport java.io.PrintWriter\nimport scala.io.Source\n\n&#x2F;**\n * 文件的输入输出\n *\n * @author itlab1024\n *&#x2F;\nobject Test06_FileIO &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 从文件中读取数据，使用scala.io包下的相关包\n    &#x2F;&#x2F; 读取文件主要分为三个步骤,1：打开文件流，2：读取文件，3：关闭文件流\n    val bufferedSource &#x3D; Source.fromFile(&quot;src&#x2F;main&#x2F;resources&#x2F;read.text&quot;)\n    bufferedSource.foreach(print)\n    bufferedSource.close()\n\n    &#x2F;&#x2F; 写内容到文件,scala中没有实现写文件的api，我们需要通过调用Java的api来实现\n    val writer &#x3D; new PrintWriter(&quot;src&#x2F;main&#x2F;resources&#x2F;write.txt&quot;)\n    writer.write(&quot;I am learning scala&quot;)\n    writer.close()\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>数据类型是任何一门语言的重点，scala也不例外。</p>\n<p>学过java的应该知道Java有8个基本类型<code>char</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>，<code>boolean</code></p>\n<p>还有上面8中类型对应的引用类型，以及<code>String</code>或者是自定义的引用类型。</p>\n<p>scala是纯面向对象的语言，没有基本类型概念，我们通过官网一张图来看下类型继承关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205252032768.svg\" alt=\"Scala Type Hierarchy\"></p>\n<ul>\n<li>Scala中一切数据都是对象，并且是<code>Any</code>的子类。</li>\n<li>Scala中主要分为两种数据：<code>数值类型(AnyVal)</code>和<code>引用类型(AnyRef)</code>。</li>\n<li>Scala和Java一样，低精度的数值类型自动转换为高精度的类型。</li>\n<li>Scala中的<code>String Ops</code>是Java中<code>String</code>的增强</li>\n<li>Unit：等价于Java中的<code>Void</code>空值类型，标识方法没有返回值</li>\n<li>Null：Scala中的<code>Null</code>是所有应用类型的子类</li>\n<li>Nothing：是所有类型的子类，主要用在一个函数没有明确返回值时使用，因为这样我们可以把抛出的返回值返回给任何的变量或者函数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数值类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boolean</td>\n<td><code>true</code>或者<code>false</code></td>\n</tr>\n<tr>\n<td>Byte</td>\n<td>8 位有符号补码整数（-2^7 到 2^7-1] 也就是：-128 到 127</td>\n</tr>\n<tr>\n<td>Short</td>\n<td>16 位有符号补码整数（-2^15 到 2^15-1] 也就是 -32,768 到 32,767</td>\n</tr>\n<tr>\n<td>Int</td>\n<td>32 位二进制补码整数（-2^31 到 2^31-1，含]-2,147,483,648 到 2,147,483,647</td>\n</tr>\n<tr>\n<td>Long</td>\n<td>64 位二进制补码整数（-2^63 到 2^63-1]</td>\n</tr>\n<tr>\n<td>Float</td>\n<td>32 位 IEEE 754 单精度浮点 1.40129846432481707e-45 到 3.40282346638528860e+38</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>64 位 IEEE 754 双精度浮点4.94065645841246544e-324d 到 1.79769313486231570e+308d</td>\n</tr>\n<tr>\n<td>Char</td>\n<td>16 位无符号 Unicode 字符（0 到 2^16-1，含）0 到 65,535</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串，由多个Char组成</td>\n</tr>\n</tbody></table>\n<p>按照上面的说明可以看到基本都是<code>-2^(n-1)到2^(n-1) -1</code>，那么为什么是是这样呢</p>\n<p>我们以<code>Byte</code>来举例说明，<code>Byte</code>是1个字节（byte），8位存（bit）储的。请注意总共有8位（bit）。</p>\n<p>首先有符号数用第一位（正着数）标识符号位<code>1</code>代表负数，<code>0</code>代表整数，那么剩下的7位就是数值位</p>\n<p><code>1符号位+7数值位=8位</code></p>\n<p>那么7位能够表示多少个数呢？应该是2的7次方。范围应该是<code>0-127</code>，再加上符号位就能够代表+(0-127)和-(0-127)，但是0是重复了，正数0（0000 0000）和负数0（1000 0000）其实是一样的。这就浪费了，所以规定正0是0，负0代表最大的负数(-128）。</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 数据类型操作\n *&#x2F;\nobject Test07_DataType &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; Boolean类型\n    var b1: Boolean &#x3D; false\n    b1 &#x3D; true\n\n\n    &#x2F;&#x2F; Byte\n    var a: Byte &#x3D; 127 &#x2F;&#x2F;正确\n    &#x2F;&#x2F;    a &#x3D; 128 &#x2F;&#x2F; 编译出错\n    &#x2F;&#x2F;    a &#x3D; -129 &#x2F;&#x2F; 编译出错\n\n    var b &#x3D; 128 &#x2F;&#x2F;128默认是Int\n\n    &#x2F;&#x2F; Long,可以不指定类型通过以L（l）结尾，建议使用大写。\n    val c: Long &#x3D; 122\n    val c1 &#x3D; 122L\n\n\n    &#x2F;&#x2F; 自动转化类型，下面的10和20默认是Int，相加&#x3D;30，是在Byte范围内的，这是允许的。\n    val d: Byte &#x3D; 10 + 20 &#x2F;&#x2F; IDEA提示类型不匹配（可能觉得后面应该是INT），但实际是可以运行的\n    println(d) &#x2F;&#x2F;30\n\n    val e: Byte &#x3D; 10\n    &#x2F;&#x2F;    val f: Byte &#x3D; e + 20  &#x2F;&#x2F; 编译器提示类型不匹配，这次匹配是确实不能执行的，这是因为这段代码只有到运行时才能获得b1的数据才能执行。\n    &#x2F;&#x2F; 可以使用强制类型转换\n    val f: Byte &#x3D; (e + 20).toByte &#x2F;&#x2F; 使用toByte强制转化为Byte类型\n\n    &#x2F;&#x2F; 超过范围情况\n    val g: Byte &#x3D; 127 &#x2F;&#x2F; 127是Byte的最大正数\n    val h: Byte &#x3D; 1\n    &#x2F;&#x2F;    val i: Byte &#x3D; g + h&#x2F;&#x2F; 运行会报错，因为127 + 1 &#x3D; 128 超出了Byte范围，而是一个Int值。使用Byte接收是不允许的。\n\n    &#x2F;&#x2F; 浮点类型\n    val j &#x3D; 1.23 &#x2F;&#x2F;默认是Double类型\n    &#x2F;&#x2F; 可以使用F(f)指定Float类型\n    val j1 &#x3D; 1.23F\n\n    &#x2F;&#x2F; 字符类型，标识单个字符,当然也包括控制字符（\\t,\\n等）\n    val k: Char &#x3D; &#39;a&#39;\n    val l: Char &#x3D; &#39;\\t&#39;\n    val m: Char &#x3D; &#39;\\\\&#39; &#x2F;&#x2F; 如果想打印\\需要使用转义\n\n    &#x2F;&#x2F; Char类型在计算机底层保存的是实际字面看到的字符吗？其实不是，真正保存的其实是ASCII码\n    val n: Int &#x3D; k\n    println(n) &#x2F;&#x2F; 97 ，也就是说字符&#39;a&#39;实际的整数值是97。\n\n    &#x2F;&#x2F; 整数转化为Char\n    println(98.toChar) &#x2F;&#x2F; b\n\n\n    &#x2F;&#x2F; Unit\n    val o: Unit &#x3D; ()\n    &#x2F;&#x2F; Null\n    val p: Null &#x3D; null\n    &#x2F;&#x2F; Nothing,比如下面方法可以返回Nothing，但是实际并不这么做，因为他是所有类型的子类\n    def  nothingTest() : Nothing &#x3D; &#123;\n      throw RuntimeException &#x2F;&#x2F; 必须抛出异常，否则提示返回类型应该是Void\n    &#125;\n    &#x2F;&#x2F;实际我们可能会这样做\n    def nothingTest(i: Int) : Int &#x3D; &#123;\n      if (i &#x3D;&#x3D; 0)\n        throw RuntimeException &#x2F;&#x2F; 必须抛出异常，否则提示返回类型应该是Void\n      else\n        i\n    &#125;\n\n  &#125;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>Scala中的数据转换规则跟Java的一样</p>\n<p>当Scala程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数值类型，这就是自动类型转换（也叫做隐式转换）。</p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205271728900.jpeg\" alt=\"类型精度排序图，从上到下，从大到小\"></p>\n<p>基本说明：</p>\n<p>​\t自动转换原则：多种类型混合运算时，系统会先自动将所有类型转换为精度大的类型，然后再做运算。</p>\n<p>​\t将精度大的赋值给精度小的数值类型时就会报错，反之自动转换</p>\n<p>​\t(<code>Byte</code>和<code>Short</code>)和<code>Char</code>之间不会自动相互转换</p>\n<p>​\t<code>Byte</code>，<code>Short</code>，<code>Char</code> 三者运算会先转换为<code>Int</code>类型</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 数据类型转换\n *&#x2F;\nobject Test08_DataTypeConversion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    自动转换原则：多种类型混合运算时，系统会先自动将所有类型转换为精度大的类型，然后再做运算。\n    val a: Byte &#x3D; 10\n    val b: Long &#x3D; 23L\n    &#x2F;&#x2F;    val c: Int &#x3D; a + b &#x2F;&#x2F; 编译错误，提示结果是Long，不允许用Int类型常量接收\n    val d: Int &#x3D; a + b.toInt &#x2F;&#x2F;这就没有问题，因为我将b通过toInt方法强制转换为Int，而a是Byte会自动提升为Int，计算结果是Int\n\n    &#x2F;&#x2F;    将精度大的赋值给精度小的数值类型时就会报错，反之自动转换\n    val e: Int &#x3D; 1\n    val f: Long &#x3D; e &#x2F;&#x2F;自动转换为高精度类型\n    &#x2F;&#x2F;    val g: Byte &#x3D; e &#x2F;&#x2F; 错误\n\n    &#x2F;&#x2F;   (&#96;Byte&#96;和&#96;Short&#96;)和&#96;Char&#96;之间不会自动相互转换\n    val h: Byte &#x3D; 1\n    &#x2F;&#x2F;    val i: Char &#x3D; h &#x2F;&#x2F; 错误\n    val j: Short &#x3D; 1\n    &#x2F;&#x2F;    val k: Char &#x3D; j &#x2F;&#x2F;错误\n\n\n    &#x2F;&#x2F;   &#96;Byte&#96;，&#96;Short&#96;，&#96;Char&#96; 三者运算会先转换为&#96;Int&#96;类型\n    &#x2F;&#x2F;    val l: Short &#x3D; h + j &#x2F;&#x2F; 错误提示应该是Int\n\n    &#x2F;&#x2F;数值类型和String的互相转换（重点，平时开发中常用）\n    &#x2F;&#x2F; 数值转String\n    val m: Int &#x3D; 1\n    val n: String &#x3D; m + &quot;&quot;\n\n    &#x2F;&#x2F; String转换为数值\n    val o: String &#x3D; &quot;1&quot;\n    val p: Int &#x3D; o.toInt &#x2F;&#x2F; 直接调用toInt方法\n\n    &#x2F;&#x2F; 注意异常问题\n    &#x2F;&#x2F;    val q : Int &#x3D; &quot;1.1&quot;.toInt &#x2F;&#x2F;编译不报错，运行是不允许的。\n\n\n    &#x2F;&#x2F; 数据溢出问题\n    val r: Int &#x3D; 200 &#x2F;&#x2F;200肯定超过了Bye的范围\n    val s: Byte &#x3D; r.toByte\n    println(s)&#x2F;&#x2F; 结果是-56 则是因为精度缺失了。\n    &#x2F;*我们分析下，Int是32位，\n    200的原码是：\n    00000000 00000000 00000000 11001000\n    补码\n    00000000 00000000 00000000 11001000\n\n    那么转化为Byte的时候要截取1个自己8位，得到结果是11001000，那他的原码就是取反(00110111),再加一(10111000),结果就是-56\n    *&#x2F;\n  &#125;\n&#125;\n</code></pre>\n\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><p>Scala中的运算符和Java中的基本相同。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>算术运算符主要有<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，不做详细介绍。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法运算，可以作用于数值也可用于字符串连接，比如 1+1、”a” + “b”</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>除法</td>\n</tr>\n<tr>\n<td>%</td>\n<td>求余 10&#x2F;3 &#x3D; 1</td>\n</tr>\n</tbody></table>\n<h2 id=\"关系运算符（比较运算符）\"><a href=\"#关系运算符（比较运算符）\" class=\"headerlink\" title=\"关系运算符（比较运算符）\"></a>关系运算符（比较运算符）</h2><p>关系运算符主要有<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，也跟Java基本相同，这里重点说下<code>==</code>,</p>\n<p>还记得java中的<code>==</code>和<code>equals</code>方法的区别吗？<code>==</code>是代表比较引用是否相等，<code>equals</code>代表比较值是否相等，不好理解，scala中就简单了很多<code>==</code>就是判断值是否相等，<code>equals</code>也是判断的值是否相等。</p>\n<p>那么scala中如何判断引用是否相等呢？<code>eq</code>方法。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;&#x3D;</td>\n<td>比较是否相等，对于引用类型，等价于equals方法</td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;&#x3D;</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;&#x3D;</td>\n<td>大于等于</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>逻辑运算符有<code>&amp;&amp;</code>，<code>||</code>，<code>！</code></p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>短路与，比如 a &gt; b &amp;&amp; c &gt; d，如果a &gt; b &#x3D;&#x3D; false,则后面的c &gt; d 不会执行。</td>\n</tr>\n<tr>\n<td>||</td>\n<td>短路或， 比如 a &gt; b || c &gt; d， 如果a&gt;b &#x3D;&#x3D; true,则后面的c &gt; d不会运行。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非，如果 a  &#x3D;&#x3D; false, 则!a &#x3D; true</td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p><code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>，<code>&gt;&gt;=</code>，<code>&lt;&lt;=</code> 跟Java也一样，不说了。</p>\n<p>需要注意的是scala中没有<code>++</code>，<code>--</code>运算符，java中有这个两个运算符，有坑，新手可能会进入误区。scala这点还是比较好的。</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;</td>\n<td>复制 val a &#x3D; 1 ,给a赋值1</td>\n</tr>\n<tr>\n<td>+&#x3D;</td>\n<td>先相加再赋值</td>\n</tr>\n<tr>\n<td>-&#x3D;</td>\n<td>先做减法在赋值</td>\n</tr>\n<tr>\n<td>*&#x3D;</td>\n<td>先做乘法再赋值</td>\n</tr>\n<tr>\n<td>&#x2F;&#x3D;</td>\n<td>先做除法再赋值</td>\n</tr>\n<tr>\n<td>%&#x3D;</td>\n<td>先求余再赋值</td>\n</tr>\n<tr>\n<td>&gt;&gt;&#x3D;</td>\n<td>先向右位移再赋值</td>\n</tr>\n<tr>\n<td>&lt;&lt;&#x3D;</td>\n<td>先向左移再赋值</td>\n</tr>\n</tbody></table>\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>|</td>\n<td>按位或</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td>~</td>\n<td>按位取反</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>右移</td>\n</tr>\n</tbody></table>\n<h2 id=\"运算符的本质\"><a href=\"#运算符的本质\" class=\"headerlink\" title=\"运算符的本质\"></a>运算符的本质</h2><p>scala中的运算符都是方法。</p>\n<p>比如+我们也可通过类似方法调用的方式使用。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">val i &#x3D; j.+(1)</code></pre>\n\n\n\n<h1 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h1><h2 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if-else\"></a>if-else</h2><hr>\n<p>基本语法</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">if（条件） &#123;\n\t&#x2F;&#x2F; 当条件是true的时候执行此处代码\n&#125; else &#123;\n  &#x2F;&#x2F; 当条件是false的时候执行此处代码\n&#125;</code></pre>\n\n<p>用法与java基本一致。</p>\n<p><strong>特别之处</strong></p>\n<p>scala中每个表达式都是有返回值的，一是要保证每个分支返回类型相同，如果确实不同，则接收者类型要使用不同类型的父类。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala\n\nimport scala.io.StdIn\n\n&#x2F;**\n * if - else控制\n *&#x2F;\nobject Test01_IfElse &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; if else\n    val a: Int &#x3D; 1\n    if (a &gt; 0) &#123;\n      println(&quot;正数&quot;)\n    &#125; else if (a &#x3D;&#x3D; 0) &#123;\n      println(&quot;0&quot;)\n    &#125; else &#123;\n      println(&quot;负数&quot;)\n    &#125;\n\n\n\n\n    &#x2F;&#x2F; if else的返回值\n    val b: Int &#x3D; 10\n    val c : Unit &#x3D; if (b &gt; 0) &#123;\n      println(&quot;测试返回值&quot;)\n    &#125;\n    println(c) &#x2F;&#x2F; ()\n\n    &#x2F;&#x2F; 多分支情况要保证最后返回的类型相同\n    val d : String &#x3D; if (b &gt; 0) &#123;\n      println(&quot;测试返回值&quot;) &#x2F;&#x2F; 此处返回是Unit，而else中返回是String，而接收者d的类型是String，这是不允许的（假设下行字符串代码没有）。\n      &quot;此处也返回String，保证每个分支返回的数据类型格式统一&quot;\n    &#125; else &#123;\n      return &quot;abc&quot;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"match模式匹配\"><a href=\"#match模式匹配\" class=\"headerlink\" title=\"match模式匹配\"></a>match模式匹配</h2><p>scala中没有<code>switch</code>，取而代之的是<code>match</code></p>\n<p>相比于Java，scala中的match，没有break关键字，使用<code>_</code>代表默认分支</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.itlab1024.github.scala.chapter04\n\nobject Test02_Match &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;match基本用法\n    val i &#x3D; 0\n    i match &#123;\n      case 0 &#x3D;&gt; println(&quot;等于0&quot;)\n      case _ &#x3D;&gt; println(&quot;不等于0&quot;) &#x2F;&#x2F; _代表默认分支\n    &#125;\n\n    &#x2F;&#x2F; match也有返回值\n    val str &#x3D; i match &#123;\n      case 0 &#x3D;&gt; &quot;ZERO&quot;\n      case _ &#x3D;&gt; &quot;NON ZERO&quot;\n    &#125;\n    println(str)\n\n    &#x2F;&#x2F; 同一个case语句有多个匹配值的时候，使用|分隔\n    i match &#123;\n      case 0 | 1 &#x3D;&gt; &quot;0 or 1&quot;\n      case _ &#x3D;&gt; &quot;other&quot;\n    &#125;\n\n    &#x2F;&#x2F; case中也可以使用表达式\n    val o  &#x3D; 1\n    i match &#123;\n      case i if (i &#x3D;&#x3D; 0) &#x3D;&gt; &quot;zero&quot; &#x2F;&#x2F;case后if表达式的括号scala是不推荐使用的。编辑器也提示给我们了\n      case _ if o &#x3D;&#x3D; 1 &#x3D;&gt; &quot;o is zero&quot;\n    &#125;\n\n    &#x2F;&#x2F;case语句中判断数组是否包含匹配的数据\n    i match &#123;\n      case a if 0 to 9 contains a  &#x3D;&gt; println(&quot;包含&quot;)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n\n\n<p>match还支持匹配<code>case class</code>后面学到的时候再用。</p>\n<h2 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h2><h3 id=\"范围循环\"><a href=\"#范围循环\" class=\"headerlink\" title=\"范围循环\"></a>范围循环</h3><p>主要使用<code>to</code>和<code>until</code>关键字来实现范围循环，其中<code>to</code>标识包含左右边界值，比如 <code>0 to 10</code>包含0和10，<code>until</code>则不包含10</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"> &#x2F;&#x2F; 普通范围循环,使用to关键字,包含左右边界值\n for (i &lt;- 0 to 10) &#123;\n println(i)\n &#125;\n\n&#x2F;&#x2F; 也可以使用until方法， 不包含后面的边界值\nfor (i &lt;- 0 until 10) &#123;\nprintln(i)\n&#125;</code></pre>\n\n<h3 id=\"循环守卫\"><a href=\"#循环守卫\" class=\"headerlink\" title=\"循环守卫\"></a>循环守卫</h3><p>循环守卫的意思是说允许在for循环范围语句后面增加if表达式，只有当表达式&#x3D;true的时候才进行循环</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 循环守卫\nval b : Int &#x3D; 0\nfor (i &lt;- 0 to 10 if b &gt; 1) &#123;\n&#x2F;&#x2F;永远不会执行，因为循环守卫 b &gt; &#x3D; 结果是false\n&#125;</code></pre>\n\n<h3 id=\"循环步长\"><a href=\"#循环步长\" class=\"headerlink\" title=\"循环步长\"></a>循环步长</h3><p>上面我们使用的for循环都是默认一步加一，有时候我们可能希望自定义步长。scala中使用<code>by</code>关键字来控制步长（步长不能是0 否则抛出异常，并且还能是小数）</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 循环步长\nfor (i &lt;- 1 to 10 by 2) &#123;\n\tprintln(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;\n&#x2F;&#x2F; by 后也可以使用负数，当从大到小遍历的时候有用\nfor (i &lt;- 20 to 1 by -2) &#123;\n  println(i) &#x2F;&#x2F;20,8,16,14,12,10,8,6,4,2\n&#125;\n&#x2F;&#x2F; 步长能使用小数吗？可以，要求to前后也必须是小数，也就是类型一致\nfor (i &lt;- 1.3 to 10.0 by 22.0) &#123; &#x2F;&#x2F;会提示to过期，使用BigDecimal，因为Double和Float计算结果取决于操作系统，会出现不准确。\n  println(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;\n&#x2F;&#x2F;使用BigDecimal\nfor (i &lt;- BigDecimal.decimal(1.3) to 10.0 by 22.0) &#123; &#x2F;&#x2F;会提示to过期，使用BigDecimal\n  println(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;</code></pre>\n\n<h3 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 和下面的for循环等价\nfor (i &lt;- 20 to 1 reverse) &#123;\n\tprintln(i) \n&#125;\n\nfor (i &lt;- 1 to 20) &#123;\n\tprintln(i)\n&#125;</code></pre>\n\n<h3 id=\"引入变量\"><a href=\"#引入变量\" class=\"headerlink\" title=\"引入变量\"></a>引入变量</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 引入变量,j就是引入的变量，两个表达式用;隔开。\nfor (i &lt;-0 to 10 ; j &#x3D; i + 1) &#123;\n  println(s&quot;i&#x3D;$i, j&#x3D;$j&quot;)\n&#125;</code></pre>\n\n<h3 id=\"循环返回值\"><a href=\"#循环返回值\" class=\"headerlink\" title=\"循环返回值\"></a>循环返回值</h3><p>scala中默认情况下返回的是Unit，必须使用<code>yeild</code>关键字来实现不同的返回值。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F;循环返回值\nval s1: Unit &#x3D; for (i &lt;- 1 to 10) &#123;\n\t&quot;结果&quot;\n&#125;\nprintln(s&quot;s1 &#x3D; $s1&quot;) &#x2F;&#x2F;s1 &#x3D; ()\n\nval s2 &#x3D; for (i &lt;- 1 to 10) yield &#123;\n\t&quot;结果&quot;\n&#125;\nprintln(s&quot;s2 &#x3D; $s2&quot;) &#x2F;&#x2F; s2 &#x3D; Vector(结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果)\n\n&#x2F;&#x2F; 将i都乘以2 ，最终返回一个数组\nval s3 &#x3D; for (i &lt;- 1 to 10) yield &#123;\n  i * 2\n&#125;\nprintln(s3) &#x2F;&#x2F;Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)</code></pre>\n\n<h3 id=\"while和do…while\"><a href=\"#while和do…while\" class=\"headerlink\" title=\"while和do…while\"></a>while和do…while</h3><p>和Java中完全一样，do while即便条件表达式不成立也会先执行一次。</p>\n<h3 id=\"循环中断\"><a href=\"#循环中断\" class=\"headerlink\" title=\"循环中断\"></a>循环中断</h3><p>Java中关于循环中断有两个关键字<code>break</code>和<code>continue</code>，scala中没有这两个关键字，要使用<code>breakable</code>来实现，也可以使用<code>try catch</code>来实现。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 循环中断\n&#x2F;&#x2F; try catch\ntry &#123;\n  for (i &lt;- 0 to 10) &#123;\n    if (i &#x3D;&#x3D; 1) &#123;\n      throw new RuntimeException\n    &#125;\n  &#125;\n&#125; catch &#123;\n  case e: Exception &#x3D;&gt; &#x2F;&#x2F; 什么也不做，退出循环\n&#125;\n&#x2F;&#x2F; try catch 虽然可时间，但是有点麻烦， 可以用breaks下的break方法\nBreaks.breakable(for (i &lt;- 0 to 10) &#123;\n  if (i &#x3D;&#x3D; 1) &#123;\n    Breaks.break();\n  &#125;\n&#125;)</code></pre>\n\n<p>我只想说不如java的break方便。我觉得就是为了体现面向对象的思想。但是确实要麻烦了点。</p>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><h2 id=\"函数基本语法\"><a href=\"#函数基本语法\" class=\"headerlink\" title=\"函数基本语法\"></a>函数基本语法</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">def 函数名 (参数变量: 参数变量类型) : 返回类型 &#123;\n  &#x2F;&#x2F;函数体\n&#125;</code></pre>\n\n<h2 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h2><p>scala中的函数类似java支持0个或者多个参数，不同于java的是scala中的函数还支持多个返回值</p>\n<h3 id=\"单返回值\"><a href=\"#单返回值\" class=\"headerlink\" title=\"单返回值\"></a>单返回值</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 函数，求两个整数的和\ndef sum (x: Int, y: Int) : Int &#x3D; &#123;\n\tx + y &#x2F;&#x2F; 可以省略return 这是scala中函数的特点\n&#125;</code></pre>\n\n\n\n<h3 id=\"多个返回值\"><a href=\"#多个返回值\" class=\"headerlink\" title=\"多个返回值\"></a>多个返回值</h3><p>比如给定两个数返回两个数的和以及差值</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 多返回值\ndef sumAndDes(x: Int, y: Int): (Int, Int) &#x3D; &#123;&#x2F;&#x2F; 多个返回值用括号包裹起来\n\treturn (x + y, x - y) &#x2F;&#x2F; return可以省略\n&#125;</code></pre>\n\n\n\n<p><strong>可变参数</strong></p>\n<p>可变参数可以通过 在类型后使用<code>*</code>来定义</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 可变参数\ndef printlnValues(values: String*)  &#x3D; &#123;\n&#125;</code></pre>\n\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F;参数默认值\ndef defaultParmasFunc(x: Int &#x3D; 10) &#x3D; &#123;&#125;</code></pre>\n\n<h3 id=\"带名参数\"><a href=\"#带名参数\" class=\"headerlink\" title=\"带名参数\"></a>带名参数</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 带名参数\ndef namedParamFunc(name: String, age: Int): Unit &#x3D; &#123;\n\t&#x2F;&#x2F; 函数体\n&#125;\nnamedParamFunc(name &#x3D; &quot;张三&quot;, age &#x3D; 10) &#x2F;&#x2F; 调用的时候可以指定名称</code></pre>\n\n<h2 id=\"函数至简原则\"><a href=\"#函数至简原则\" class=\"headerlink\" title=\"函数至简原则\"></a>函数至简原则</h2><ul>\n<li>return可以省略，scala使用函数体最后一个代码作为返回值</li>\n<li>如果函数体只有一个行代码，大括号可以省略</li>\n<li>返回值类型如果能够推断出来，那么可以省略</li>\n<li>如果有return，则不能省略返回值类型，必须指定</li>\n<li>如果函数明确声明Unit，那么即便函数体中使用return也不会起作用</li>\n<li>scala如果无返回值类型，可以省略等号</li>\n<li>如果函数无参，但是声明了参数列表，那么调用时小括号可以省略</li>\n<li>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</li>\n<li>如果不关心名称只关心处理逻辑，那么def关键字可以省略，这就是匿名函数</li>\n</ul>\n<p>代码示例：</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 函数至简原则\n&#x2F;&#x2F;    * return可以省略，scala使用函数体最后一个代码作为返回值\ndef func1(x: Int): Int &#x3D; &#123;\n  x + 1\n&#125;\n\n&#x2F;&#x2F;    * 如果函数体只有一个行代码，大括号可以省略\ndef func2(x: Int): Int &#x3D; x + 1\n\n&#x2F;&#x2F;    * 返回值类型如果能够推断出来，那么可以省略\ndef func3(x: Int) &#x3D; x + 1\n\n&#x2F;&#x2F;    * 如果有return，则不能省略返回值类型，必须指定, 比如下面方法的: Int不能省略\ndef func4(x: Int): Int &#x3D; return x + 1\n\n&#x2F;&#x2F;    * 如果函数明确声明Unit，那么即便函数体中使用return也不会起作用,\ndef fun5(x: Int): Unit &#x3D; return x + 1\n\nprintln(fun5(1)) &#x2F;&#x2F; 结果不是2，而是(),也就是Unit\n\n&#x2F;&#x2F;    * scala如果无返回值类型，可以省略等号\ndef func6(x: Int) &#123;&#125;\n\n&#x2F;&#x2F;    * 如果函数无参，但是声明了参数列表，那么调用时小括号可以省略\ndef func7() &#x3D; &#123;&#125;\n\nfunc7 &#x2F;&#x2F; 等价于func7()\n\n&#x2F;&#x2F;    * 如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略\ndef fun8 &#x3D; &#123;&#125;\n\nfun8 &#x2F;&#x2F; 不能使用fun8()\n\n&#x2F;&#x2F;    如果不关心名称只关心处理逻辑，那么def关键字可以省略，这就是匿名函数\nval func9 &#x3D; (name: String) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 函数体\n  println(name)\n&#125;\n&#x2F;&#x2F;      如何调用呢,scala中什么都有返回值\n&#x2F;&#x2F;      上面的例子可以修改为\nfunc9(&quot;名字&quot;)</code></pre>\n\n\n\n<h2 id=\"函数的值传递\"><a href=\"#函数的值传递\" class=\"headerlink\" title=\"函数的值传递\"></a>函数的值传递</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; ----函数的值传递------\n&#x2F;&#x2F; 先定义一个函数\ndef func10(i: Int): Int &#x3D; &#123;\n  println(&quot;函数func10被调用&quot;)\n  i + 1\n&#125;\n&#x2F;&#x2F; 函数作为值进行传递, 函数名后加上空格再加上_代表这是一个函数整体\nval f1 &#x3D; func10 _ &#x2F;&#x2F; 也可以写成val f1 : Int &#x3D;&gt; Int &#x3D; func10， 也可以写成\nprintln(f1)\nprintln(f1(10))</code></pre>\n\n<h2 id=\"函数作为参数传递\"><a href=\"#函数作为参数传递\" class=\"headerlink\" title=\"函数作为参数传递\"></a>函数作为参数传递</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 函数可以作为函数参数传递\n    &#x2F;&#x2F; 定义一个二元计算,下面的dualEval是一个函数，参数是op也是一个函数，此函数的参数列表是Int类型的a和b\ndef dualEval(op: (Int, Int) &#x3D;&gt; Int, a: Int, b: Int): Int &#x3D; &#123;\n  op(a, b)\n&#125;\n\ndef op(a: Int, b: Int): Int &#x3D; &#123;\n  a + b\n&#125;\n\nprintln(op(1, 2)) &#x2F;&#x2F; 3</code></pre>\n\n<h2 id=\"函数可以作为函数的返回值\"><a href=\"#函数可以作为函数的返回值\" class=\"headerlink\" title=\"函数可以作为函数的返回值\"></a>函数可以作为函数的返回值</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 函数可以作为函数的返回值\ndef returnFunc(): String &#x3D;&gt; String &#x3D; &#123;\n  def subFunc1(s: String) &#x3D; &#123;\n    println(s)\n    &quot;晕&quot;\n  &#125;\n\n  subFunc1\n&#125;\n\nval stringToString: String &#x3D;&gt; String &#x3D; returnFunc()\nval str &#x3D; stringToString(&quot;参数&quot;)\nprintln(str)</code></pre>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">val arr: Array[Int] &#x3D; Array(1, 2, 3)\n\n&#x2F;&#x2F; 对数组进行处理，将操作抽象出来，处理完毕的结果返回一个新的数组\ndef arrayOperation(array: Array[Int], op: Int &#x3D;&gt; Int): Array[Int] &#x3D; &#123;\n  for (a &lt;- array) yield op(a)\n&#125;\n\n&#x2F;&#x2F; 定义一个+1操作\ndef addOne(i: Int): Int &#x3D; i + 1\n\n&#x2F;&#x2F; 我们先对数组arr进行加一，返回新的数组\nval newArr &#x3D; arrayOperation(arr, addOne)\n\nprintln(newArr.mkString(&quot;,&quot;)) &#x2F;&#x2F; 2,3,4</code></pre>\n\n<h2 id=\"函数柯里化-amp-闭包\"><a href=\"#函数柯里化-amp-闭包\" class=\"headerlink\" title=\"函数柯里化&amp;闭包\"></a>函数柯里化&amp;闭包</h2><p>闭包：如果一个函数，访问到了他的外部（局部）变量的值，那么这个函数和他所在的环境，就称为闭包</p>\n<p>函数柯里化：把一个参数列表的多个参数，编程多个参数列表。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"> &#x2F;&#x2F; 闭包\ndef add(i: Int): Int &#x3D;&gt; Int &#x3D; &#123;\n  def add2(j: Int): Int &#x3D; &#123;\n    i + j\n  &#125;\n\n  add2\n&#125;\n\nval f1 &#x3D; add(1) &#x2F;&#x2F;f1是一个函数\nprintln(f1(2)) &#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 函数柯里化，比如上面的闭包就可以写成如下模式，并且推荐使用函数的库里化\ndef addCurrying(a: Int)(b: Int): Int &#x3D; &#123;\n  a + b\n&#125;\nprintln(addCurrying(1)(2))</code></pre>\n\n\n\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>自己调用自己就是递归。</p>\n<p>示例：n的阶乘，比如5！&#x3D; 1x2x3x4x5;</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter05\n\n&#x2F;**\n * 递归\n *&#x2F;\nobject Test04_Recursion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(fact(5))\n  &#125;\n\n  def fact(n: Int): Int &#x3D; &#123;\n    if (n &#x3D;&#x3D; 0) return 1\n    fact(n - 1) * n\n  &#125;\n\n&#125;\n\n&#x2F;&#x2F; 递归有什么问题呢?会出现栈帧过多，出现Stack Overflow错误，在scala中如何解决呢？\ndef fact2(n: Int) : Int &#x3D; &#123;\n  @tailrec\n  def work(n: Int, result: Int) : Int &#x3D; &#123;\n    if (n &#x3D;&#x3D; 0) return result\n    work(n-1, result * n)\n  &#125;\n  work(n , 1)\n&#125;\nprintln(fact2(5)) &#x2F;&#x2F; 结果也是120，但是这种方式就不会增多栈帧数量</code></pre>\n\n\n\n<h2 id=\"控制抽象\"><a href=\"#控制抽象\" class=\"headerlink\" title=\"控制抽象\"></a>控制抽象</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter05\n\n&#x2F;**\n * 控制抽象\n *&#x2F;\nobject Test05_ControlAbstraction &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 通常函数调用我们都是传递值\n    &#x2F;&#x2F; 传值参数\n    def f1(): Int &#x3D; &#123;\n      println(&quot;f1调用&quot;)\n      1\n    &#125;\n\n    def f2(i: Int): Int &#x3D; &#123;\n      i\n    &#125;\n\n    println(f2(f1()))\n\n    println(&quot;------&quot;)\n\n    &#x2F;&#x2F; 不同于上面的传值参数，接下来看下什么是传名参数\n    &#x2F;&#x2F; 请注意参数的类型 &#x3D;&gt; Int\n    def f3(i: &#x3D;&gt; Int): Unit &#x3D; &#123;\n      println(i)\n      println(i)\n    &#125;\n    f3(f1()) &#x2F;&#x2F;这里需要注意的是f1调用了几次呢？两次，奇怪不，是因为上面f3对于i打印了2次，所有f1就被调用了两次\n    &#x2F;&#x2F; 运行结果是：\n    &#x2F;*\n    ------\n    f1调用\n    1\n    f1调用\n    1\n    *&#x2F;\n\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h2><p>当函数返回值被声明为<code>lazy</code>的时候，函数的执行将被推迟，知道我们首次对其取值，该函数才会运行，这种函数被称为惰性函数</p>\n<p>类似于Java JPA中的lazy的概念。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter05\n\nobject Test06_LazyFunc &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    lazy val i &#x3D; addOne(1)\n    println(i) &#x2F;&#x2F; 如果注释掉改行，也就是i不被使用，则addOne方法不会被执行\n  &#125;\n\n  def addOne(i: Int): Int &#x3D; &#123;\n    println(&quot;addOne方法被调用&quot;)\n    i + 1\n  &#125;\n&#125;\n</code></pre>\n\n<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><p>Scala中的面向对象基本和Java相同，我是个javaer，一样的地方我就不写了。主要记录下不同的地方。</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>scala有两种包的管理方式，一种和java一样，一个源文件在一个包下（包名和文件所在路径不要求一致），另外一种是scala中支持包名的嵌套</p>\n<p>该种方式的特点是：</p>\n<p>一个源文件可以有多个包</p>\n<p>子包中的类可以直接访问父包汇总的内容，无需导包</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 嵌套风格的package\npackage p1 &#123;\n  &#x2F;&#x2F; 定义一个单例对象\n  object o1 &#123;\n    val N1: String &#x3D; &quot;N1&quot;\n  &#125;\n  package p2 &#123;\n    object o2 &#123;\n      def main(args: Array[String]): Unit &#x3D; &#123;\n        o1.N1 &#x2F;&#x2F; 直接调用外层包\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"包对象\"><a href=\"#包对象\" class=\"headerlink\" title=\"包对象\"></a>包对象</h2><p>在scala中可以为每个包定义一个同名的包对象，定义在包对象的成员，做为其对应包下的所有class和objcet的共享变量，可以直接访问。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala\n\npackage object chapter06 &#123;\n  &#x2F;&#x2F; 定义共享的值\n  val sharedValue1 : Int &#x3D; 1\n  &#x2F;&#x2F; 定义共享方法\n  def pkgName() : String &#x3D; &#123;\n    &quot;io.github.itlab1024.scala.chapter06&quot;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 调用包对象\npackage io.github.itlab1024.scala.chapter06\n\nobject Test02_PackageObject &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 调用包对象的方法和成员\n    println(sharedValue1)\n    println(pkgName())\n  &#125;\n&#125;\n\n</code></pre>\n\n<h2 id=\"包导入\"><a href=\"#包导入\" class=\"headerlink\" title=\"包导入\"></a>包导入</h2><p>跟java相同，有以下不同之处</p>\n<ul>\n<li>嵌套包可以不通过的包下import，这是局部引入，只在当前包下有效。</li>\n<li>可以屏蔽某一个类，比如<code>import java.util.&#123;HashSet =&gt; _,_&#125;</code></li>\n<li>导入相同包的多个类，用<code>&#123;&#125;</code>括起来，逗号分隔</li>\n<li>。。。。。。</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\n&#x2F;**\n * 包导入\n *&#x2F;\n&#x2F;&#x2F; 给类起别名\nimport java.util.&#123;ArrayList &#x3D;&gt; MyArrays&#125;\n&#x2F;&#x2F; 不导入HashMap，这有啥用？？?\nimport java.util.&#123;HashMap &#x3D;&gt; _&#125;\n\nobject Test03_PackageImport &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 使用别名\n    val i: MyArrays[Int] &#x3D; new MyArrays[Int]()\n\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 嵌套包导入\npackage A &#123;\n  package B &#123;\n\n  &#125;\n&#x2F;&#x2F; 有些就不尝试了，感觉用处不大\n&#125;</code></pre>\n\n<h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h2><p>类和对象的定义跟java一样，类可以看成一个模板，对象可以认为是一个具体的事务</p>\n<p>注意：在scala中没有public关键字（默认就是public的），一个.scala文件中可以定义多个类。</p>\n<p>基本语法：</p>\n<pre class=\"line-numbers language-tex\" data-language=\"tex\"><code class=\"language-tex\">[修饰符] class 类名 &#123;\n\t&#x2F;&#x2F;类的body体\n&#125;</code></pre>\n\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nimport scala.beans.BeanProperty\n\nobject Test04_Class &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val it &#x3D; new IT\n    it.name &#x2F;&#x2F;可以访问\n    &#x2F;&#x2F;    it.age &#x2F;&#x2F; 因为是private，不能访问\n    &#x2F;&#x2F; 赋值\n    &#x2F;&#x2F;    it.name &#x3D; &quot;itlab1024&quot; &#x2F;&#x2F; val常量不能变更值\n    it.weibo &#x3D; &quot;itlab&quot; &#x2F;&#x2F; 可以\n    &#x2F;&#x2F; homeUrl 我们加了 @BeanProperty注解，就可以使用get和set方法\n    it.setHomeUrl(&quot;&quot;)\n    it.getHomeUrl\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个类\nclass IT &#123;\n  &#x2F;&#x2F; 定义属性和方法\n  val name: String &#x3D; &quot;itlab&quot;\n  &#x2F;&#x2F; 可以定义为私有的\n\n  private var age: Int &#x3D; 1\n  @BeanProperty &#x2F;&#x2F; @BeanProperty 提供getter方法和setter方法\n  var homeUrl &#x3D; &quot;itlab1024.github.io&quot;\n\n  var weibo: String &#x3D; _\n\n&#125;</code></pre>\n\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（成员方法），才能对数据进行操作。</p>\n<h3 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h3><p>scala中没有<code>public</code>关键字，但是有<code>private</code>和<code>protected</code></p>\n<p><code>private</code>:只有类的内部和半生对象可以访问</p>\n<p><code>protected</code>:同类子类可以访问，同一个包的不同类不能够访问</p>\n<p><code>private [包名]</code>：增加包访问权限，包名下的其他类可以访问。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 定义一个父类\nclass Test04_ClassForAccess &#123;\n  private var idCard: String &#x3D; &quot;1333x&quot;\n  private var name: String &#x3D; &quot;itlab&quot;\n  var sex: String &#x3D; &quot;男&quot;\n  private[chapter06] var age: Int &#x3D; 1\n\n  def printInfo(): Unit &#x3D; &#123;\n    println(s&quot;Persion: $idCard $name, $sex $age&quot;)\n  &#125;\n&#125;\n\npackage io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 定义一个子类\nclass Test04_Access extends Test04_ClassForAccess &#123;\n  override def printInfo(): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    println(idcard) &#x2F;&#x2F; 无法访问，idcard是private 只能在本类和其伴生对象中访问\n    println(name) &#x2F;&#x2F;可以访问，protected，可以再父子类访问\n    println(sex) &#x2F;&#x2F;可以访问，默认public的\n\n    println(age) &#x2F;&#x2F; age可以访问，因为使用了private [chapter06]声明了\n  &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>方法和函数一样，只不过方法是类中函数的一种特殊叫法</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nclass Test05_Method &#123;\n  &#x2F;&#x2F; 定义一个方法\n  def method1(): Int &#x3D; &#123;\n    1\n  &#125;\n&#125;\n\nclass subClass extends Test05_Method &#123;\n  &#x2F;&#x2F; 使用override关键字实现函数的重写\n  override def method1(): Int &#x3D; super.method1()\n&#125;</code></pre>\n\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 使用new关键字\nobject Test05_Method &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val method &#x3D; new Test05_Method &#x2F;&#x2F; 使用new创建一个类的实例对象\n    method.method1() &#x2F;&#x2F; 调用方法\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h3><p>scala中也有构造方法，可以定义多个，不同的是定义有点区别。</p>\n<p>scala中分为主构造器（仅有一个），和副构造器（可以有多个），用this作为方法名</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 默认就有一个主构造器，下面的()可以省略。\nclass Test06_Constructor() &#123;\n  var name: String &#x3D; &quot;&quot;\n  var age: Int &#x3D; 10\n  println(&quot;主构造器被调用&quot;)\n\n  &#x2F;&#x2F; 副构造器，可以有多个\n  def this(name: String) &#123;\n    this() &#x2F;&#x2F;直接调用主构造器\n    this.name &#x3D; name\n    println(&quot;副构造器被调用&quot;)\n  &#125;\n&#125;\n\nobject Test06_Constructor &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    new Test06_Constructor()\n\n    println(&quot;--------&quot;)\n\n    new Test06_Constructor(&quot;1&quot;)\n\n    &#x2F;*\n    运行结果：\n\n    \n    主构造器被调用\n    --------\n    主构造器被调用\n    副构造器被调用\n    * *&#x2F;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"主构造器参数\"><a href=\"#主构造器参数\" class=\"headerlink\" title=\"主构造器参数\"></a>主构造器参数</h3><p>上面的主构造器是默认的，我们没有进行修改，默认无参，也可以定义参数</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 参数可以使用val或者var，如果不修饰则通过 对象.属性名 无法获取到值，可以如下面的age那样指定默认值\nclass ConstructorParams(private var name: String, val age: Int &#x3D; 1) &#123;\n  &#x2F;&#x2F;    var name: String &#x3D; &quot;itlab&quot; &#x2F;&#x2F; 无需再次定义name，否则报错\n\n  &#x2F;&#x2F; 定义方法打印name\n  def printName(): Unit &#x3D; &#123;\n    println(this.name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; mian方法调用\n&#x2F;&#x2F; 主构造器参数\nval cp &#x3D; new ConstructorParams(&quot;itlab&quot;) &#x2F;&#x2F; age有默认值，可以省略\ncp.age &#x2F;&#x2F; 可以访问\n&#x2F;&#x2F;    cp.name &#x2F;&#x2F; 访问不到name\n&#x2F;&#x2F; 调用printname方法\ncp.printName() &#x2F;&#x2F; itlab</code></pre>\n\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><p>scala中的继承通过<code>extends</code>关键字，主要有以下特点</p>\n<ul>\n<li>子类继承父类的属性和方法</li>\n<li>单继承</li>\n<li>构造器先执行父类再执行子类</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test07_ClassExtends &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val clazz &#x3D; new SubClass(&quot;itlab&quot;, 1, &quot;男&quot;)\n    &#x2F;&#x2F;运行结果\n    &#x2F;*\n    ParentClass 主构造器执行\n    SubClass 主构造器执行\n    SubClass 副构造器调用\n     *&#x2F;\n  &#125;\n&#125;\n\nclass ParentClass &#123;\n  var name: String &#x3D; &quot;ITLAB&quot;\n  var age &#x3D; 1\n  println(&quot;ParentClass 主构造器执行&quot;)\n\n  def this(name: String, age: Int) &#123;\n    this()\n    println(&quot;ParentClass 副构造器调用&quot;)\n    this.name &#x3D; name\n    this.age &#x3D; age\n  &#125;\n\n  def printName() &#x3D; &#123;\n    println(this.name)\n  &#125;\n&#125;\n\nclass SubClass extends ParentClass &#123;\n  println(&quot;SubClass 主构造器执行&quot;)\n  var sex: String &#x3D; _\n\n  def this(name: String, age: Int, sex: String) &#123;\n    this()\n    println(&quot;SubClass 副构造器调用&quot;)\n    this.name &#x3D; name\n    this.age &#x3D; age\n    this.sex &#x3D; sex\n  &#125;\n\n  &#x2F;&#x2F;重写printName方法\n  override def printName(): Unit &#x3D; &#123;\n    println(this.name + &quot; 子类&quot;)\n  &#125;\n  \n  &#x2F;&#x2F; 多态，简单介绍下，没什么特别的 跟java一样\n  def f1() &#123;&#125;\n  def f1(i: Int)&#123;&#125;\n&#125;</code></pre>\n\n<h2 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h2><p>scala中使用<code>abstract</code>定义抽象类，继承和重写需要注意的点</p>\n<ul>\n<li>如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需要声明为抽象类</li>\n<li>重写非抽象方法需要用<code>override</code>修饰，重写抽象方法可以省略<code>override</code>修饰。</li>\n<li>子类调用父类的方法使用<code>super</code>关键字</li>\n<li>子类对抽象属性进行实现，父类抽象属性可以用<code>var</code>修饰，子类对非抽象属性重写，父类非抽象属性只支持<code>val</code>类型</li>\n</ul>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test08_AbstractClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val clazz &#x3D; new Class1\n    clazz.name\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 抽象类\nabstract class Test08_AbstractClass &#123;\n  &#x2F;&#x2F; 非抽象属性，抽象方法中的属性不用初始化，其他情况必须初始化\n  var name: String &#x3D; &quot;itlab1024&quot;\n  &#x2F;&#x2F; 抽象属性（只声明，没有初始化）\n  val age: Int\n\n  &#x2F;&#x2F; 非抽象方法\n  def f1(): Unit &#x3D; &#123;&#125;\n\n  &#x2F;&#x2F; 抽象方法\n  def f2(): Unit\n&#125;\n\n&#x2F;**\n * 普通类继承抽象类\n *&#x2F;\nclass Class1 extends Test08_AbstractClass &#123;\n  &#x2F;&#x2F; age属性是抽象属性，所以普通类继承的时候必须初始化, override可以省略，但是我个人建议还是加上，代码清晰\n  override val age: Int &#x3D; 1\n\n  &#x2F;&#x2F; f2 是抽象方法，普通类继承的时候必须实现该方法, override可以省略，但是我个人建议还是加上，代码清晰\n  override def f2(): Unit &#x3D; &#123;\n    super.f1() &#x2F;&#x2F;可以使用super调用父抽象类的方法\n    println(age)\n  &#125;\n\n  &#x2F;&#x2F; 重写非抽象方法, override不能省略\n  override def f1() &#123;\n  &#125;\n\n  &#x2F;&#x2F; 重写非抽象属性, override不能省略, 此处虽然编译没有问题，但是运行时会提示错误&quot;overriding variable name in class Test08_AbstractClass of type String;\n  &#x2F;&#x2F; variable name cannot override a mutable variable\n  &#x2F;&#x2F;  override var name: String &#x3D; &quot;&quot;&quot;\n  &#x2F;&#x2F; 也就是说变量不需要重写，直接使用name &#x3D; &quot;value&quot;即可。可以将name修改为val下面的代码就不会有有问题\n  override var name: String &#x3D; &quot;&quot;\n&#125;</code></pre>\n\n<h2 id=\"匿名子类\"><a href=\"#匿名子类\" class=\"headerlink\" title=\"匿名子类\"></a>匿名子类</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nabstract class Test09_AnonymousClass &#123;\n  var name: String\n  def f1()\n&#125;\nobject Test09_AnonymousClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    new Test09_AnonymousClass &#123;\n      override var name: String &#x3D; &quot;&quot;\n\n      override def f1(): Unit &#x3D; &#123;&#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>跟java一样。</p>\n<h2 id=\"单例对象（伴生对象）\"><a href=\"#单例对象（伴生对象）\" class=\"headerlink\" title=\"单例对象（伴生对象）\"></a>单例对象（伴生对象）</h2><p>scala中没有<code>static</code>，因为他设计为完全面向对象，<code>static</code>并不符合面向对象的思想，但是为了兼容java的静态概念，scala就创造了伴生对象（也叫做单例对象）.</p>\n<p>单例对象使用<code>object</code>来定义</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nimport io.github.itlab1024.scala.chapter06.Test09_Object.SCALA_NAME\n\n&#x2F;**\n * 伴生对象，举个例子，一个类的所有示例对象可能都有一个共同值，在java中，我们在类中定义一个static的变量，然后对象中通过类型.属性名进行访问\n * 在scala中使用伴生对象来解决，比如下面的Test09_Object有两个，一个是class修饰，一个是object修饰。\n * object是伴生对象，伴随class修饰的类而生，两者名字要相同\n *&#x2F;\nobject Test09_Object &#123;\n  &#x2F;&#x2F; 这就类似于java中的。 public staitc final String SCALA_NAME &#x3D; &quot;scala&quot;\n  val SCALA_NAME: String &#x3D; &quot;scala&quot;\n&#125;\n\nclass Test09_Object &#123;\n  val name: String &#x3D; SCALA_NAME\n&#125;</code></pre>\n\n<p>通过伴生对象我们能够实现单例模式</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test10_Singleton &#123;\n  private val test10_Singleton: Test10_Singleton &#x3D; new Test10_Singleton(&quot;itlab1024&quot;)\n\n  def getInstance(): Test10_Singleton &#x3D; &#123;\n    test10_Singleton\n  &#125;\n\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(Test10_Singleton.getInstance().eq(Test10_Singleton.getInstance())) &#x2F;&#x2F; true 说明实例只有一个\n  &#125;\n&#125;\n\n&#x2F;&#x2F;主构造方法使用private修饰。\nclass Test10_Singleton private(val name: String) &#123;\n\n&#125;</code></pre>\n\n\n\n<h2 id=\"特质-Trait\"><a href=\"#特质-Trait\" class=\"headerlink\" title=\"特质(Trait)\"></a>特质(Trait)</h2><p>scala中的特质就是接口，和java中的<code>interface</code>类似</p>\n<p>scala中的特质可以包含抽象属性和方法，也可以包含具体的属性和方法，感觉跟java中的<code>abstract</code>更相似。子类使用<code>extends</code>来实现特质，如果有多个特质，则<code>with</code>连接，如果又继承类，同时又实现特质的时候，应该把类紧跟在<code>extends</code>后。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test11_Trait &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val s &#x3D; new S\n    s.f2()\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个父类\nclass P &#123;\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;p调用&quot;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义两个trait\ntrait t1 &#123;\n  var name: String\n\n  def f1(): Unit\n\n  val age: Int &#x3D; 10\n\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;t1调用&quot;)\n  &#125;\n&#125;\n\ntrait t2 &#123;\n  var  name: String\n\n  def f1(): Unit\n\n  val age: Int &#x3D; 10\n\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;t2调用&quot;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子类,继承父类p，实现特质1和特质2,请注意下面的顺序\nclass S extends P with t1 with t2 &#123;\n  override var name: String &#x3D; &quot;&quot;\n\n  override def f1(): Unit &#x3D; &#123;&#125;\n\n  override val age: Int &#x3D; 10\n\n  override def f2(): Unit &#x3D; super.f2() &#x2F;&#x2F; f2方法在两个特质里都有， super.f2()调用的是谁呢？是特质t2\n&#125;</code></pre>\n\n<p>需要注意的是如果一个类继承了父类，并且实现了多个特质，比如<code>subClass extends ParentClass with trait1 with trait2</code> ,并且父类和两个特质都定义了相同的方法，那么子类的super.方法()。调用的是traint2的方法，这里可以理解为方法被覆盖了。</p>\n<h3 id=\"特质叠加、特质钻石问题\"><a href=\"#特质叠加、特质钻石问题\" class=\"headerlink\" title=\"特质叠加、特质钻石问题\"></a>特质叠加、特质钻石问题</h3><p>以后测试。</p>\n<h2 id=\"类型检查和转换\"><a href=\"#类型检查和转换\" class=\"headerlink\" title=\"类型检查和转换\"></a>类型检查和转换</h2><p>java中使用<code>instanceOf</code> 关键字，scala中使用的是函数<code>isInstanceOf</code>,转换则使用<code>asInstanceOf</code>。</p>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test11_TypeCheckAndConversion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val ball &#x3D; new Ball\n    println(&quot;ball是Ball类型吗?&quot; + ball.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball是BasketBall类型吗?&quot; + ball.isInstanceOf[BasketBall]) &#x2F;&#x2F; false\n    val ball2 &#x3D; new BasketBall\n\n    println(&quot;ball2是Ball类型吗?&quot; + ball2.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball2是BasketBall类型吗?&quot; + ball2.isInstanceOf[BasketBall]) &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 可以将父类型装置转化为子类型\n    val ball3: BasketBall &#x3D; new BasketBall\n    println(&quot;ball3是Ball类型吗?&quot; + ball3.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball3是BasketBall类型吗?&quot; + ball3.isInstanceOf[BasketBall]) &#x2F;&#x2F; true\n    &#x2F;&#x2F;    转换\n    val ball4: Ball &#x3D; ball3.asInstanceOf[Ball]\n\n  &#125;\n&#125;\n\nclass Ball &#123;\n\n&#125;\n\nclass BasketBall extends Ball &#123;\n\n&#125;</code></pre>\n\n<h2 id=\"枚举类和应用类\"><a href=\"#枚举类和应用类\" class=\"headerlink\" title=\"枚举类和应用类\"></a>枚举类和应用类</h2><ul>\n<li>枚举类需要继承<code>Enumeration</code></li>\n<li>应用类需要继承<code>App</code></li>\n</ul>\n<p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter06\n\nobject Test12_EnumAndAppClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(TimeUnit.YEAR) &#x2F;&#x2F;YEAR\n    println(TimeUnit.DAY) &#x2F;&#x2F; DAY\n    println(TimeUnit.HOUR) &#x2F;&#x2F; HOUR\n    println(TimeUnit.YEAR.id) &#x2F;&#x2F; 0\n    println(TimeUnit.DAY.id) &#x2F;&#x2F; 3\n    println(TimeUnit.HOUR.id) &#x2F;&#x2F; 4\n    println(TimeUnit.MONTH.id) &#x2F;&#x2F; 1\n\n    &#x2F;&#x2F; 通过名字获取到枚举\n    val value &#x3D; TimeUnit.withName(&quot;MONTH&quot;)\n    println(value)\n  &#125;\n&#125;\n\nobject TimeUnit extends Enumeration &#123;\n  val YEAR: TimeUnit.Value &#x3D; Value(&quot;YEAR&quot;)\n  val MONTH: TimeUnit.Value &#x3D; Value\n  val DAY: TimeUnit.Value &#x3D; Value(3, &quot;DAY&quot;)\n  val HOUR: TimeUnit.Value &#x3D; Value\n  val MINUTE: TimeUnit.Value &#x3D; Value(&quot;MINUTE&quot;)\n  val SECOND: TimeUnit.Value &#x3D; Value\n&#125;\n\n&#x2F;&#x2F; 应用类\nobject MyApp extends App &#123;\n  println(&quot;继承APP就省去了main的定义&quot;)\n&#125;</code></pre>\n\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><ul>\n<li><p>scala中的集合有三大类，Seq，Set，Map。所有的集合都实现<code>Iterable</code>特质</p>\n</li>\n<li><p>对于几乎所有的集合类，scala都提供可变和不可变两个版本，分别位于<code>scala.collection.mutable</code>和<code>scala.collection.immutable</code>中</p>\n</li>\n<li><p>scala不可变集合，就是指该集合对象不可修改，每次修改就会返回一个新对象，而不会对原对象进行更改。</p>\n</li>\n<li><p>可变集合，就是这个集合可以直接对原集合进行修改。不会返回新的对象</p>\n</li>\n</ul>\n<p>建议：在集合操作的时候，不可变用符号，可变用方法。</p>\n<p><strong>集合继承图</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202206011916051.jpeg\" alt=\"不可变集合继承图\"></p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"不可变数组\"><a href=\"#不可变数组\" class=\"headerlink\" title=\"不可变数组\"></a>不可变数组</h3><p>示例</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nobject Test01_ImmutableArray &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    var arr: Array[Int] &#x3D; new Array[Int](10)\n    &#x2F;&#x2F; 另一种创建的方式,使用apply方法\n    val array &#x3D; Array.apply(1, 2, 3) &#x2F;&#x2F; 可省略apply方法， Array(1, 2, 3)\n    println(array.length)\n    &#x2F;&#x2F; 访问数组中的元素\n    val i &#x3D; array(0)\n    println(&quot;第一个元素是:&quot; + i) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; 修改,不是说不可变吗，要注意的是不可变数组的不可变是说内存地址不变，大小不可变，索引上的元素还是可以变的\n    array(0) &#x3D; 4\n    println(array.mkString(&quot;,&quot;)) &#x2F;&#x2F; 4,2,3\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 循环数组\n    &#x2F;&#x2F; 普通for loop\n    for(i &lt;- 0 until array.length) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 上面代码提示我们可以使用array.indices\n    for (i &lt;- array.indices) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 我们也可以使用如下方法\n    for (i &lt;- array) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 也可以使用foreach方法，函数式编程\n    array.foreach(println)\n\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 迭代器\n    val iterator &#x3D; array.iterator\n    while (iterator.hasNext) &#123;\n      println(iterator.next())\n    &#125;\n    println(&quot;------------&quot;)\n\n    &#x2F;&#x2F; 添加元素(追加到最后，使用:+()方法)\n    val newArray &#x3D; array.:+(0) &#x2F;&#x2F; 返回新的数组\n    newArray.foreach(println)\n    println(&quot;------------&quot;)\n\n    &#x2F;&#x2F; 向最前面添加元素(使用+:()方法)\n    val newArray2 &#x3D; newArray.+:(-1)\n    newArray2.foreach(println)\n\n    &#x2F;&#x2F; 简化使用+:和:+\n    val ints &#x3D; newArray2 :+ 1\n    val ints2 &#x3D; 29 +: newArray2\n    \n    \n\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"可变数组\"><a href=\"#可变数组\" class=\"headerlink\" title=\"可变数组\"></a>可变数组</h3><p>可变数组<code>ArrayBuffer</code></p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable.ArrayBuffer\n\n&#x2F;**\n * 可变数组ArrayBuffer\n *&#x2F;\nobject Test02_ArrayBuffer &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建可变数组\n    val _ &#x3D; new ArrayBuffer[Int]()\n    &#x2F;&#x2F; 第二种方法使用伴生对象\n    val array &#x3D; ArrayBuffer(1, 2, 3)\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 访问数组的元素\n    val i &#x3D; array(0)\n    println(i)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 修改\n    array(0) &#x3D; -1\n    println(array)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 添加元素 可以使用:+和+:的方式，但是需要注意的是需要定义新的数组来接收。\n    val ints &#x3D; array :+ 2 &#x2F;&#x2F; 向后追加\n    println(ints)\n    println(&quot;---------&quot;)\n    &#x2F;&#x2F; 向前追加\n    val ints1 &#x3D; 1 +: array\n    println(ints1)\n\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 向后追加推荐使用+&#x3D;来实现\n    println(array) &#x2F;&#x2F; ArrayBuffer(-1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 向前追加使用+&#x3D;:\n    1 +&#x3D;: array\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, -1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 也可使用append方法和prepend方法\n    array.append(1)\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n    array.prepend(0)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 插入值\n    array.insert(1, 100) &#x2F;&#x2F;在索引1的位置插入100，后面的值后移\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 100, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 删除元素\n    array.remove(1)\n    println(array) &#x2F;&#x2F;ArrayBuffer(0, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n    &#x2F;&#x2F; 也可以删除索引后的几个值\n    array.remove(1, 2)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F;也可以根据值来删除\n    array -&#x3D; 1\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 如果有多个相同的值呢，使用-&#x3D;只会删除一个，并且从左向右寻找。\n    array.append(1, 2, 1)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3, 1, 2, 1)\n    array -&#x3D; 1\n    println(array) &#x2F;&#x2F;ArrayBuffer(0, 2, 3, 2, 1)\n    \n\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"可变数组与不可变数组的转换\"><a href=\"#可变数组与不可变数组的转换\" class=\"headerlink\" title=\"可变数组与不可变数组的转换\"></a>可变数组与不可变数组的转换</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">&#x2F;&#x2F; 可变数组与不可变数组的转换\nvar a1 &#x3D; ArrayBuffer[Int](1, 2, 3)\n&#x2F;&#x2F; 转换为不可变数组\nval array1: Array[Int] &#x3D; a1.toArray\n&#x2F;&#x2F; 将不可变数组转化为可变数组\nval buffer: mutable.Buffer[Int] &#x3D; array1.toBuffer</code></pre>\n\n<h3 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\n&#x2F;**\n * 多维数组\n *&#x2F;\nobject Test03_MultiArray &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建一个二维数组\n    val array: Array[Array[Int]] &#x3D; Array.ofDim[Int](2, 2)\n\n    &#x2F;&#x2F; 设置元素\n    array(0)(1) &#x3D; 1\n\n    &#x2F;&#x2F; 访问元素\n    val i: Int &#x3D; array(0)(1)\n    println(i) &#x2F;&#x2F; 1\n    println(&quot;------&quot;)\n\n    &#x2F;&#x2F; 遍历二维数组\n    for (i &lt;- array.indices; j &lt;- array(i).indices) &#123;\n      println(array(i)(j) + &quot;\\t&quot;)\n      if (j &#x3D;&#x3D; array(i).length - 1) println()\n    &#125;\n\n    &#x2F;&#x2F; 使用foreach循环\n    array.foreach(_.foreach(println))\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"列表List\"><a href=\"#列表List\" class=\"headerlink\" title=\"列表List\"></a>列表List</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable.ListBuffer\n\nobject Test04_List &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建一个不可变的List,可以使用apply。\n    val l: List[Int] &#x3D; List.apply(1, 2, 3)\n    &#x2F;&#x2F; 也可以使用伴生对象创建\n    val list: List[Int] &#x3D; List(1, 2, 3)\n\n    &#x2F;&#x2F; 访问list的元素\n    val i &#x3D; list(1)\n    println(i) &#x2F;&#x2F; 2\n\n    &#x2F;&#x2F; 赋值\n    &#x2F;&#x2F;    list(0) &#x3D; 10 &#x2F;&#x2F; 这是不允许的\n\n    &#x2F;&#x2F; 遍历，可以使用普通for循环，或foreach\n    for(i &lt;- list.indices) &#123;\n      println(i)\n    &#125;\n\n    &#x2F;&#x2F; 添加元素\n    &#x2F;&#x2F; 向最后添加\n    val list1 &#x3D; list :+ 10\n    println(list1) &#x2F;&#x2F; List(1, 2, 3, 10)\n    &#x2F;&#x2F; 向前添加\n    val list2 &#x3D; 11 +: list1\n    println(list2) &#x2F;&#x2F; List(11, 1, 2, 3, 10)\n\n\n    &#x2F;&#x2F; 合并列表\n    val l1 &#x3D; List(1)\n    val l2 &#x3D; List(2)\n    val l3 &#x3D; l1 ::: l2 &#x2F;&#x2F; 也可以使用l1 ++ l2\n    println(l3) &#x2F;&#x2F; List(1, 2)\n\n\n    &#x2F;&#x2F; 可变列表ListBuffer\n    val lb: ListBuffer[Int] &#x3D; ListBuffer[Int](1, 2, 3)\n    lb.append(4)\n    println(lb) &#x2F;&#x2F; ListBuffer(1, 2, 3, 4)\n    &#x2F;&#x2F;其他的不操作了。。。。。。，跟ArrayBuffer类似\n\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>不可变集合Set</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nobject Test05_ImmutableSet &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建Set\n    val s &#x3D; Set(1, 2)\n    &#x2F;&#x2F; 添加元素\n    val ns &#x3D; s + 3\n    println(ns) &#x2F;&#x2F; Set(1, 2, 3)\n  &#125;\n&#125;\n</code></pre>\n\n<p>可变集合Set</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable\n\nobject Test06_MutableSet &#123;\n\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建可变set\n    val set &#x3D; mutable.Set(1, 2, 3)\n    &#x2F;&#x2F; 添加\n    set +&#x3D; 10\n    println(set) &#x2F;&#x2F;Set(1, 2, 3, 10)\n    &#x2F;&#x2F; 建议使用add方法\n    set.add(9)\n    println(set) &#x2F;&#x2F; Set(9, 1, 2, 3, 10)\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>可变Map</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nobject Test07_ImmutableMap &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建Map\n    val map: Map[Int, Int] &#x3D; Map[Int, Int]((1, 2), (3, 4)) &#x2F;&#x2F; 也可以使用-&gt;,比如1-&gt;2,3-&gt;4\n    println(map) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4)\n\n    &#x2F;&#x2F; 添加\n    val map1 &#x3D; map + (5 -&gt; 6)\n    println(map1) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4, 5 -&gt; 6)\n\n    &#x2F;&#x2F; 删除\n    val map2 &#x3D; map1 - 1\n    println(map2) &#x2F;&#x2F; Map(3 -&gt; 4, 5 -&gt; 6)\n\n    &#x2F;&#x2F; 通过key获取\n    val i &#x3D; map2(3)\n    println(i) &#x2F;&#x2F; 4, 如果key不存在会抛出异常\n\n    &#x2F;&#x2F; 循环\n    for((k, v) &lt;- map2) &#123;\n      println(s&quot;k&#x3D;$k, v&#x3D;$v&quot;)\n    &#125;\n\n\n  &#125;\n&#125;</code></pre>\n\n<p>可变的Map</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable\n\nobject Test08_MutableMap &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义可变的map\n    val map: mutable.Map[Int, Int] &#x3D; mutable.Map(1 -&gt; 2, 3 -&gt; 4)\n    &#x2F;&#x2F; 添加\n    map + (5 -&gt; 6)\n    println(map) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4) 为啥没加进去，其实+这个函数就是为了不可变设计的。但是scala缺无法根据不同的map区分，其实list和set也是如此\n\n    &#x2F;&#x2F; 使用\n    map.put(5, 6)\n    println(map) &#x2F;&#x2F; Map(5 -&gt; 6, 1 -&gt; 2, 3 -&gt; 4)\n    \n    &#x2F;&#x2F; 懒了，其他的不试了，以后用的时候再积累吧\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h2><p>元组可以理解为一个容器，可以存放各种不同或者相同类型的数据。</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter08\n\n&#x2F;**\n * 元组\n *&#x2F;\nobject Test01_Tuple &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建元组\n    val tuple1: (Int, String, Boolean) &#x3D; (1, &quot;a&quot;, true)\n    &#x2F;&#x2F; 获取元组元素，通过_index的方式\n    println(tuple1._1) &#x2F;&#x2F; 1\n    println(tuple1._2) &#x2F;&#x2F; a\n    println(tuple1._3) &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 遍历元组\n    for(e &lt;- tuple1.productIterator) &#123;\n      println(e)\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter08\n\nimport scala.collection.mutable\n\n&#x2F;**\n * scala中的队列\n *&#x2F;\nobject Test02_Queue &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义队列\n    val queue: mutable.Queue[Int] &#x3D; mutable.Queue[Int]()\n    println(queue) &#x2F;&#x2F;Queue()\n\n    &#x2F;&#x2F; 入队\n    queue.enqueue(1)\n    println(queue) &#x2F;&#x2F; Queue(1)\n\n    &#x2F;&#x2F; 出队\n    val i &#x3D; queue.dequeue()\n    println(i) &#x2F;&#x2F; 1\n    println(queue) &#x2F;&#x2F;Queue()\n  &#125;\n&#125;</code></pre>\n\n<h1 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h1><p>主要学习下样例类（case class）的匹配</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package io.github.itlab1024.scala.chapter09\n\nobject Test01_PatternMatch &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; match默认是无法对普通类进行操作的，必须在类的伴生对象中实现自己的apply和unapply方法。scala中提供了样例类，这样的类默认就提供了这些方法\n    val t &#x3D; T(&quot;itlab1024&quot;)\n    t match &#123;\n      case T(&quot;1&quot;) &#x3D;&gt; println(&quot;匹配1&quot;)\n      case _ &#x3D;&gt;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 样例类\ncase class T(name: String) &#123;\n&#125;</code></pre>\n\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter10\n\nobject Test01_Exception &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    try &#123;\n\n    &#125; catch &#123;\n      case e: NullPointerException &#x3D;&gt; println(&quot;空指针&quot;)\n      case ex: ClassNotFoundException &#x3D;&gt; println(&quot;类没没找到&quot;)\n    &#125; finally &#123;\n      &#x2F;&#x2F; 别忘了关闭流等操作。。。。\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>scala中的泛型比java稍微复杂点，会分为协变，逆变</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">class MyClass[+T] &#x2F;&#x2F; 协变\nclass MyClass[-T] &#x2F;&#x2F; 逆变\nclass MyClass[T]\t&#x2F;&#x2F; 不变</code></pre>\n\n<p>协变：Son是Father的子类，则MyList[Son]也可以作为MyList[Father]的子类</p>\n<p>逆变：Son是Father的子类，则MyList[Son]作为MyList[Father]的父类</p>\n<p>不变：Son是Father的子类，则MyList[Son]和MyList[Father]没有关系</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">package io.github.itlab1024.scala.chapter11\n\nobject Test01_Generics &#123;\n  &#x2F;&#x2F; 协变和逆变\n  val l: MyList[Father] &#x3D; new MyList[Son] &#x2F;&#x2F; 这是不允许的，但是如果将MyList的泛型修改为+E则没有问题。\n  val n: MyList[Son] &#x3D; new MyList[Father] &#x2F;&#x2F; 这也是不允许的，，但是如果将MyList的泛型修改为-E则没有问题。\n&#125;\n\nclass Father &#123;\n\n&#125;\n\nclass Son extends Father &#123;\n\n&#125;\n\n&#x2F;&#x2F; 定义泛型的集合类型\nclass MyList[E] &#123; &#x2F;&#x2F; 此处现在是不变的泛型\n\n&#125;</code></pre>\n\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结，粗略的学习了下，感觉scala的设计有点复杂了，尤其里面各种方法，比如<code>+=:</code>,<code>::</code>,<code>:::</code>等，很难记。</p></blockquote>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Github：<a href=\"https://github.com/ITLab1024/Scala2-Tutorials\">https://github.com/ITLab1024/Scala2-Tutorials</a></p>\n<p><img src=\"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202206021712863.png\" alt=\"微信公众号\"></p></blockquote>\n","feature":true,"text":"什么是Scala？Scala 是一门基于JVM和Java完全兼容的语言，具有跨平台，可移植性，完备的垃圾回收机制等特定 Scala比Java更加面向对象，他是一门纯面向对象的语言，我们知道Java并不是，比如他具有基本类型。 Scala是一门函数式编程语言，Java并不是，JDK...","link":"","photos":[],"count_time":{"symbolsCount":"56k","symbolsTime":"51 mins."},"categories":[{"name":"Scala","slug":"Scala","count":1,"path":"api/categories/Scala.json"}],"tags":[{"name":"Scala2","slug":"Scala2","count":1,"path":"api/tags/Scala2.json"},{"name":"2.12.11","slug":"2-12-11","count":1,"path":"api/tags/2-12-11.json"},{"name":"BigData","slug":"BigData","count":1,"path":"api/tags/BigData.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFScala%EF%BC%9F\"><span class=\"toc-text\">什么是Scala？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0Scala%EF%BC%9F\"><span class=\"toc-text\">为什么学习Scala？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\"><span class=\"toc-text\">学习资料</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Scala%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">Scala入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Scala%E3%80%81Java%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">Scala、Java、JVM的关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Scala%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">Scala环境安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">编程工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">安装插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">创建项目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HelloWorld\"><span class=\"toc-text\">HelloWorld</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">伴生对象</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">变量和数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">常量和变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">标识符命名规范</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">字符串输出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">键盘输入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89\"><span class=\"toc-text\">文件输入输出（IO）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型转换</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">算术运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89\"><span class=\"toc-text\">关系运算符（比较运算符）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">逻辑运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">赋值运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">位运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">运算符的本质</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">流程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#if-else\"><span class=\"toc-text\">if-else</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#match%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">match模式匹配</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#for%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">for循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">范围循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E5%AE%88%E5%8D%AB\"><span class=\"toc-text\">循环守卫</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E6%AD%A5%E9%95%BF\"><span class=\"toc-text\">循环步长</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reverse\"><span class=\"toc-text\">Reverse</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">引入变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">循环返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#while%E5%92%8Cdo%E2%80%A6while\"><span class=\"toc-text\">while和do…while</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">循环中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">函数式编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">函数基本语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">函数定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">单返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">多个返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">参数默认值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E5%90%8D%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">带名参数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%87%B3%E7%AE%80%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">函数至简原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">函数的值传递</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">函数作为参数传递</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数可以作为函数的返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-amp-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">函数柯里化&amp;闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">控制抽象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">懒加载</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">面向对象编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">包对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">包导入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">类和对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">封装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90\"><span class=\"toc-text\">访问权限</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">创建对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%99%A8\"><span class=\"toc-text\">构造器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">主构造器参数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">继承和多态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">抽象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">匿名子类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%EF%BC%89\"><span class=\"toc-text\">单例对象（伴生对象）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E8%B4%A8-Trait\"><span class=\"toc-text\">特质(Trait)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E8%B4%A8%E5%8F%A0%E5%8A%A0%E3%80%81%E7%89%B9%E8%B4%A8%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">特质叠加、特质钻石问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型检查和转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E5%BA%94%E7%94%A8%E7%B1%BB\"><span class=\"toc-text\">枚举类和应用类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88\"><span class=\"toc-text\">集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">不可变数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">可变数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">可变数组与不可变数组的转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">多维数组</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8List\"><span class=\"toc-text\">列表List</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84\"><span class=\"toc-text\">元组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">模式匹配</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常处理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a></li></ol>","author":{"name":"ITLab","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202204221711395.png","link":"/","description":"梦想越是美丽，就越是显得遥不可及，可奇怪的是，一旦你下定了决心，很快地，那些梦想就一一成为了现实！","socials":{"github":"https://github.com/ITLab1024","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xpp1109","csdn":"","juejin":"","customs":{"wxgzh":{"icon":"fa fa-wechat","link":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202204231828426.jpg"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"使用Kubeadm搭建Kubernetes集群（v1.22）","uid":"ddc916691a7c6f09eafaf2d5a06c2348","slug":"使用Kubeadm搭建Kubernetes集群（v1-22）","date":"2022-05-02T03:18:25.000Z","updated":"2022-06-02T08:46:03.037Z","comments":true,"path":"api/articles/使用Kubeadm搭建Kubernetes集群（v1-22）.json","keywords":null,"cover":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202205021123222.jpeg","text":"版本说明 v1.22 准备三台机器 使用Multipass（如何使用，请参考文章皮皮：使用Ubuntu Multipass创建虚拟机（方便快捷））创建三个vm。也就是三个节点node1， node2， node3 multipass launch -c 2 -m 2G -n no...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Kubernetes","slug":"Kubernetes","count":2,"path":"api/categories/Kubernetes.json"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","count":1,"path":"api/tags/Kubernetes.json"},{"name":"Container","slug":"Container","count":1,"path":"api/tags/Container.json"}],"author":{"name":"ITLab","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202204221711395.png","link":"/","description":"梦想越是美丽，就越是显得遥不可及，可奇怪的是，一旦你下定了决心，很快地，那些梦想就一一成为了现实！","socials":{"github":"https://github.com/ITLab1024","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xpp1109","csdn":"","juejin":"","customs":{"wxgzh":{"icon":"fa fa-wechat","link":"https://raw.githubusercontent.com/ITLab1024/picgo-images/main/202204231828426.jpg"}}}},"feature":true}}