[{"id":"d339d355269868e4606a9ed4016aeb8f","title":"scala2学习笔记（v2.12.11）","content":"什么是Scala？Scala 是一门基于JVM和Java完全兼容的语言，具有跨平台，可移植性，完备的垃圾回收机制等特定\nScala比Java更加面向对象，他是一门纯面向对象的语言，我们知道Java并不是，比如他具有基本类型。\nScala是一门函数式编程语言，Java并不是，JDK8增加的Lambda是函数式。\nScala的非常适合大数据处理，我们熟悉的Spark、Flink、Kafka等底层都是使用Scala实现的。\nScala目前主流版本是2，目前版本3也已经Released。先学习2，再学习3。\n\n为什么学习Scala？Scala的好处上面已经提到过了，这些是我们学习Scala的理由，单不完全是我的理由。\n我的理由主要是：\n公司业务是物联网（IOT），工作需要大数据相关技术，所以学习。\n\n个人也比较喜欢新技术，除了Scala，我也学习目前流行的Golang语言。\n\n建议：学习新技术要根据自己实际情况而定，首先要工作需要的技术，这能够提高技术同时是的自己在岗位上更加突出，更加胜任工作，其次学习时间比较多。\n学习资料我目前学习Scala的主要渠道主要有两处，官网和尚硅谷视频。\n官网是必须要看的，并且强烈推荐看英文原版内容，有些中文网翻译水平实在有限，并且有错误。\n我虽然主要看官网，但是官网资料比较松散，自己又不太爱总结，也觉得浪费时间，我是初学一门语言，在学习Scala的路上，我就是个菜鸟。尚硅谷的视频还是非常不错的（不是打广告哈哈）。\n我学习的过程中主要是跟着尚硅谷的视频学习，但是不完全操作其内容，主要是根据他的目录来学习。\n另外这里建议下，没学过Java的不要学习scala！！！\nScala入门Scala、Java、JVM的关系\nJava和JVM的关系：写代码(.java) &#x3D;&gt; 使用javac命令编译为.class文件 &#x3D;&gt; 使用JVM运行\nScala和JVM的关系：写代码(.scala) &#x3D;&gt;使用scalac命令编译为.class文件 &#x3D;&gt; 使用JVM运行\n两者极其类似！！！\nScala能够使用Java类库！！！\nScala环境安装前提：scala基于JVM，要求我们环境要安装JDK。JDK的安装请自行查询，检查JDK是否安装\n➜  ~ java -version\nopenjdk version &quot;17.0.3&quot; 2022-04-19 LTS\nOpenJDK Runtime Environment Corretto-17.0.3.6.1 (build 17.0.3+6-LTS)\nOpenJDK 64-Bit Server VM Corretto-17.0.3.6.1 (build 17.0.3+6-LTS, mixed mode, sharing)\n\n我电脑安装的是OpenJDK17，只要大于8即可。\nScala支持Mac、Windows、Linux等系统。有多种安装方式，\n\n官方推荐使用cs setup安装\n➜  ~ brew install coursier&#x2F;formulas&#x2F;coursier &amp;&amp; cs setup\nUpdating Homebrew...\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;a34af3e5d8010f4b87297cbcf23a7090d907d343dfbb691e9ddea9facb4b1605--coursier\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;e56f4bc31b6326034ab85448faa48e50054affc7b327e3e82180fc861633fc54--cs-x86_64-apple-darwin.gz\n&#x3D;&#x3D;&gt; Installing coursier from coursier&#x2F;formulas\n^C^C\nOne sec, cleaning up...\n\n➜  ~ \n➜  ~ brew install coursier&#x2F;formulas&#x2F;coursier &amp;&amp; cs setup\nUpdating Homebrew...\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;a34af3e5d8010f4b87297cbcf23a7090d907d343dfbb691e9ddea9facb4b1605--coursier\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;github.com&#x2F;coursier&#x2F;coursier&#x2F;releases&#x2F;download&#x2F;v2.1.0-M5\nAlready downloaded: &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;e56f4bc31b6326034ab85448faa48e50054affc7b327e3e82180fc861633fc54--cs-x86_64-apple-darwin.gz\n&#x3D;&#x3D;&gt; Installing coursier from coursier&#x2F;formulas\n&#x3D;&#x3D;&gt; Caveats\nzsh completions have been installed to:\n  &#x2F;usr&#x2F;local&#x2F;share&#x2F;zsh&#x2F;site-functions\n&#x3D;&#x3D;&gt; Summary\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;coursier&#x2F;2.1.0-M5-18-gfebf9838c: 5 files, 57.4MB, built in 49 seconds\nChecking if a JVM is installed\nFound a JVM installed under &#x2F;Users&#x2F;shizhenchao&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;corretto-17.0.3&#x2F;Contents&#x2F;Home.\n\nChecking if ~&#x2F;Library&#x2F;Application Support&#x2F;Coursier&#x2F;bin is in PATH\n\nChecking if the standard Scala applications are installed\n  Installed ammonite\n  Installed cs\n  Installed coursier\n  Installed scala\n  Installed scalac\n  Installed sbt\n  Installed sbtn\n  Installed scalafmt\n\n默认安装的scala是最新版本（3.1.2）\n因为我主要是跟着尚硅谷视频学习，所以同步使用他的版本（2.12.11）\n安装参考如下地址：https://scala-lang.org/download/2.12.11.html\n通过命令行用cs工具安装\n➜  ~ cs install scala:2.12.11 &amp;&amp; cs install scalac:2.12.11\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;io&#x2F;get-coursier&#x2F;apps&#x2F;maven-metadata.xml\n  No new update since 2022-05-16 17:11:57\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-compiler&#x2F;2.12.11&#x2F;scala-comp…\n  100.0% [##########] 2.6 KiB (10.9 KiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-reflect&#x2F;2.12.11&#x2F;scala-refle…\n  100.0% [##########] 1.8 KiB (8.0 KiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-compiler&#x2F;2.12.11&#x2F;scala-comp…\n  100.0% [##########] 10.2 MiB (4.0 MiB &#x2F; s)\nhttps:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;org&#x2F;scala-lang&#x2F;scala-reflect&#x2F;2.12.11&#x2F;scala-refle…\n  100.0% [##########] 3.5 MiB (1.1 MiB &#x2F; s)\nWrote scala\nWrote scalac\n\n➜  ~ scala -version\nScala code runner version 2.12.11 -- Copyright 2002-2020, LAMP&#x2F;EPFL and Lightbend, Inc.\n\n温馨提示：如果使用二进制安装，需要配置环境变量。\n交互式命令行，输入scala命令接口打开：\n➜  ~ scala\nWelcome to Scala 2.12.11 (OpenJDK 64-Bit Server VM, Java 17.0.3).\nType in expressions for evaluation. Or try :help.\n\nscala&gt; val a:Int &#x3D; 10\na: Int &#x3D; 10\n\nscala&gt; val b:Int &#x3D;5\nb: Int &#x3D; 5\n\nscala&gt; a + b\nres0: Int &#x3D; 15\n\nscala&gt; \n\n\n\n写代码并编译执行，创建一个Hello.scala文件，文件内容如下\nobject Hello &#123;\n\tdef main(ags: Array[String]): Unit &#x3D; &#123;\n\t\tprintln(&quot;hello&quot;)\n\t&#125;\n&#125;\n\n使用scalac编译文件，使用scala指令运行\n➜  Scala2-Tutorials git:(main) ✗ scalac Hello.scala \n➜  Scala2-Tutorials git:(main) ✗ scala Hello         \nhello\n\n\n\n编程工具官方推荐使用VSCode和IDEA，我个人非常喜欢使用IDEA，接下来我也会在IDEA上进行开发。\n安装插件使用IDEA开发scala需要安装插件。\n\n创建项目\n\n\nScala支持使用SBT和IntelliJ创建项目，我用的是sbt。其他的方式我就不演示了。\nHelloWorld创建package\n在上图中scala文件夹上邮件，选择创建package\n\n创建一个Object，scala中的Object是一个单例类，全局只有一份\n\n编写入口程序main方法的代码\n\n解析下上面的main方法\npackage io.itlab1024.github.scala\n\n&#x2F;**\n * object：scala中的一个关键字，声明一个单例对象，也叫做伴生对象\n *&#x2F;\nobject HelloWorld &#123;\n  &#x2F;**\n   * 程序的入口方法， def是关键字，用于定义方法，括号内是参数信息，args是参数名，通过：类型定义数据类型，\n   * 此main方法中args参数的类型是是字符串数组，其实这跟java的类似，只不过表现形式不同而已。括号后面的:Unit代表返回类型，Unit在scala中代表空，类似于Java中的Void\n   * @param args\n   *&#x2F;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(&quot;Hello World&quot;)\n  &#125;\n&#125;\n\n伴生对象object关键字是用于创建伴生对象，什么是伴生对象呢？伴随谁而生？想想我们再Java中使用static定义一个对象，如何访问呢？我们需要使用类名.属性来访问。看下下面的代码\npackage io.itlab1024.github.scala;\n\n&#x2F;**\n * 饮料类\n *&#x2F;\npublic class Drink &#123;\n    private static final String MAJOR &#x3D; &quot;水&quot;;\n    &#x2F;**\n     * 水果成分\n     *&#x2F;\n    private String fruits;\n\n    public String getFruits() &#123;\n        return fruits;\n    &#125;\n\n    public void setFruits(String fruits) &#123;\n        this.fruits &#x3D; fruits;\n    &#125;\n    \n    public void show() &#123;\n        System.out.println(&quot;MAJOR&#x3D;&quot; + Drink.MAJOR + &quot;, Fruits&#x3D;&quot; + this.fruits);\n    &#125;\n&#125;\n\n上面代码是java中的定义，Drink代表饮料类，有两个成员变量类，MAJOR代表主成分（饮料主成分都是水），使用static定义，还有一个fruits代表水果，我们看下第22行中Drink.MAJOR使用的是类名字.属性访问，这在java中是正确的，但是这并不符合面向对象的设计，因为我并没有通过对象获取属性，scala中伴生对象就是创造一个伴生类的对象（伴生对象）。这更符合面向对象的思想。\n上面的例子我通过scala的class和object实现(用新的名字ScalaDrink，否则类冲突，当然也可以修改内容中的class后的名字，而不是修改文件名。)\npackage io.itlab1024.github.scala.chapter01\nimport io.github.itlab1024.scala.chapter01.ScalaDrink\n\n&#x2F;**\n * Scala中Drink类\n *&#x2F;\nclass ScalaDrink (fruits: String)&#123;\n  def show (): Unit &#x3D; &#123;\n    println(&quot;MAJOR&#x3D;&quot; + ScalaDrink.MAJOR + &quot;, Fruits&#x3D;&quot; + this.fruits)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 伴生对象\nobject ScalaDrink &#123;\n  var MAJOR: String &#x3D; &quot;水&quot;\n&#125;\n\nIDEA工具很有好的为我们编辑了类和伴生对象的关系。\n\n个人体会：scala为了满足纯面向对象的设计，搞得复杂了，语言我觉得越简单越好。\n变量和数据类型注释Scala中的注释跟Java中的完全一样，分为单行注释、多行注释和文档注释\npackage io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 文档注释\n *&#x2F;\nobject Test01_Comment &#123;\n  &#x2F;*\n  多行注释\n  main方法的定义\n  *&#x2F;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 单行注释\n    println(&quot;hello&quot;)\n  &#125;\n&#125;\n\n常量和变量常量使用val 声明，变量说过var声明\nvar 常量名[: 类型] &#x3D; 初始值\nval 变量名[: 类型] &#x3D; 初始值\n注意：能用常量的地方不用变量\npackage io.itlab1024.github.scala.chapter02\n\nimport io.github.itlab1024.scala.chapter01.ScalaDrink\n\nobject Test02_Variable &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义变量\n    var i: Int &#x3D; 10\n    &#x2F;&#x2F; 定义常量\n    val j: Int &#x3D; 20\n\n    &#x2F;&#x2F; 类型确定后不能修改，scala其实是强类型语言\n    &#x2F;&#x2F;    i &#x3D; &quot;不能修改类型&quot; &#x2F;&#x2F; 编译错误\n\n    &#x2F;&#x2F;    j &#x3D; 10; &#x2F;&#x2F; 常量的值不能被修改\n\n    &#x2F;&#x2F; 变量声明的时候必须要有初始值\n    &#x2F;&#x2F; var a: Int &#x2F;&#x2F; 这是编译不通过的,java中是允许的\n\n\n    &#x2F;&#x2F; 如果是引用类型，对象不能概念，但是对象里面的变量属性（通过var修饰）是可以修改的，常量属性（不使用var修饰或者使用val修饰）依然是不能修改的。\n    val apple &#x3D; new ScalaDrink(&quot;苹果&quot;)\n    &#x2F;&#x2F;    apple &#x3D; new ScalaDrink(&quot;橘子&quot;) &#x2F;&#x2F; 编译不通过\n    &#x2F;&#x2F;    apple.fruits &#x3D; &quot;橘子&quot; &#x2F;&#x2F; 编译不通过，因为之前创建的ScalaDrink类的fruits属性没有使用var修饰。\n  &#125;\n&#125;\n\n除了修饰符不同以外，跟java类似。\n标识符命名规范什么是标识符？scala中对变量、常量、方法、函数名字统称为标识符\nscala中的标识符命名规则基本与java一致。\n\n标识符由字母、数字、下划线组成，但是首字母必须是字母或者下划线\n\n以操作符开头，且只能包含操作符（#-*&#x2F;#!等）\n\n用反引号&#96;&#96;将任意字符串包起来，这是合法的标识符，即便是scala中的关键字也是可以的，\nscala中的关键字主要有\n\npackage，import，class，**object，trait，extends，with**，type，\n\nfor\n\nprivate，protected，abstract，**scaled，final，implicit**，lazy，override\nif，else，**match，case，do，while，for，return，yield**\ndef，var，val\nthis，super\nnew\ntrue, false, null\n\n\n\n示例\npackage io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 标识符规范测试\n *&#x2F;\nobject Test03_Identifier &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    （1）标识符由字母、数字、下划线组成，但是首字母必须是字母或者下划线\n    val scala: String &#x3D; &quot;scala&quot;\n    val scala134: Int &#x3D; 1\n    val _scala: String &#x3D; &quot;scala&quot;\n    &#x2F;&#x2F;    val 1scala: Int &#x3D; 1 &#x2F;&#x2F;编译不通过，不能以为数字开头\n    &#x2F;&#x2F;    val a+b &#x3D; 1 &#x2F;&#x2F; IDEA工具并不提示错误，但是实际上是不允许的，会提示not found: value +\n\n\n    &#x2F;&#x2F; (2)以操作符开头，且只能包含操作符（#-*&#x2F;#!等）\n    &#x2F;&#x2F; 搞不懂谁会这么干，有实际应用场景吗？？？\n    val +-*&#x2F; &#x3D; 10 &#x2F;&#x2F;正确\n    val +#%^&amp;^*&amp;&amp;* &#x3D; 10 &#x2F;&#x2F;正确\n    println(+#%^&amp;^*&amp;&amp;*)\n\n    &#x2F;&#x2F; (3) 用反引号&#96;&#96;将任意字符串包起来，这是合法的标识符，即便是scala中的关键字也是可以的，\n    &#x2F;&#x2F; 上面有个定义a+b是允许的，但是如果使用反引号引起来就是允许的\n    val &#96;a+b&#96; &#x3D; 1\n    println(&#96;a+b&#96;)\n    &#x2F;&#x2F; 关键字也是允许的\n    &#x2F;&#x2F;    val if &#x3D; 1 &#x2F;&#x2F;编译不通过\n    val &#96;if&#96; &#x3D; 1\n    println(&#96;if&#96;) &#x2F;&#x2F;正确\n\n  &#125;\n&#125;\n\n\n\n字符串输出字符串可以通过+操作符进行相加，例如&quot;a&quot; + &quot;b&quot; 结果是ab\nprintf格式化输出，通过%来显示不同内容，类似java中的System.out.printf以及Go中的fmt.Printf。\n插值字符串，在字符串总通过$获取变量进行拼接\n示例\npackage io.itlab1024.github.scala.chapter02\n\nobject Test04_String &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 字符串连接\n    val a &#x3D; &quot;I am learning &quot;\n    val b &#x3D; &quot;scala&quot;\n    println(a + b) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; printf格式化输出\n    printf(&quot;%s%s\\n&quot;, a, b) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; 插值字符串（模板字符串）\n    println(s&quot;$a$b&quot;) &#x2F;&#x2F; I am learning scala， s是一个函数， 定义源码：def s(args: Any*): String &#x3D; standardInterpolator(treatEscapes, args)\n\n    &#x2F;&#x2F; 也可以使用$&#123;&#125;，通过+运算符进行连接\n    println(s&quot;$&#123;a + b&#125;&quot;) &#x2F;&#x2F; I am learning scala\n\n    &#x2F;&#x2F; $&#123;&#125;其实可以写scala代码，调用函数等等都是支持的\n    println(s&quot;$&#123;1 + 2 + math.pow(1, 2)&#125;&quot;) &#x2F;&#x2F; 4.0\n\n    &#x2F;&#x2F;格式化小数，比如小数位数,需要注意的是这就不能使用s函数，如果使用会原样输出，需要使用f函数。\n    val f: Float &#x3D; 11.2356F\n    println(f&quot;$f%2.2f&quot;) &#x2F;&#x2F;11.24   这就是说小数点前面要保证两位，小数点后也是两位，多余位数四舍五入，舍弃\n    &#x2F;&#x2F; 也可以省略.前面的数字\n    println(f&quot;$f%.2f&quot;) &#x2F;&#x2F;11.24\n    &#x2F;&#x2F; 前面的数字有范围吗?\n    println(f&quot;$f%100.2f&quot;) &#x2F;&#x2F;输出空，为什么？我也不知道，有空看看源码吧，我估计还有很多细节，平时可能不会用到，但是面试或者考试估计就会出题，我们知道套路就是这样\n\n    &#x2F;&#x2F;raw函数的使用\n    println(raw&quot;$f%2.2f&quot;) &#x2F;&#x2F; 11.2356%2.2f，除了$获取变量值外，其他的字符原样输出了\n    println(s&quot;$f%2.2f&quot;) &#x2F;&#x2F; 11.2356%2.2f\n    &#x2F;&#x2F; s函数和raw函数结果一样，那么他俩有啥区别呢\n    println(raw&quot;$f%2.2f\\t回车&quot;) &#x2F;&#x2F; 11.2356%2.2f\\t回车， 真正的原样输出\n    println(s&quot;$f%2.2f\\t回车&quot;) &#x2F;&#x2F; 11.2356%2.2f\t回车， \\t未原样输出，被解析制表符\n\n\n    &#x2F;&#x2F; 三引号字符串，stripMargin是字符串的函数，忽略边界\n    val s1: String &#x3D;\n      &quot;&quot;&quot;\n        |i\n        |am\n        |learning\n        |scala\n        |&quot;&quot;&quot;.stripMargin\n    println(s1) &#x2F;&#x2F; 原样输出，注意不会输出|,会有回车换行\n\n    &#x2F;&#x2F; 三引号字符串同样可以使用s,raw等函数\n    val s2 &#x3D;\n      s&quot;&quot;&quot;\n         |The\n         |value\n         |is\n         |$a\n         |&quot;&quot;&quot;.stripMargin\n     println(s2)\n\n    &#x2F;&#x2F; raw\n    val s3 &#x3D;\n      raw&quot;&quot;&quot;\n           |$a \\txx\n           |&quot;&quot;&quot;.stripMargin\n   println(s3)\n\n\n  &#125;\n&#125;\n\n键盘输入键盘输入一般在开发交互式的程序中很有用。\n常用基本语法\nStdIn.readLine(),StdIn.readShort(),StdIn.readDouble()，StdIn.readInt()等等\n示例\npackage io.itlab1024.github.scala.chapter02\n\nimport scala.io.StdIn\n\nobject Test05_StdIn &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(&quot;请输入姓名&quot;)\n    val name &#x3D; StdIn.readLine()\n    println(&quot;请输入年龄&quot;)\n    val age &#x3D; StdIn.readInt()\n    println(s&quot;$name 的年龄是$age&quot;)\n  &#125;\n&#125;\n\n\n\n文件输入输出（IO）文件输入主要使用到是scala中的scala.io包内容，但是scala并没有提供文件输出api，需要调用java的API实现\npackage io.itlab1024.github.scala.chapter02\n\nimport java.io.PrintWriter\nimport scala.io.Source\n\n&#x2F;**\n * 文件的输入输出\n *\n * @author itlab1024\n *&#x2F;\nobject Test06_FileIO &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 从文件中读取数据，使用scala.io包下的相关包\n    &#x2F;&#x2F; 读取文件主要分为三个步骤,1：打开文件流，2：读取文件，3：关闭文件流\n    val bufferedSource &#x3D; Source.fromFile(&quot;src&#x2F;main&#x2F;resources&#x2F;read.text&quot;)\n    bufferedSource.foreach(print)\n    bufferedSource.close()\n\n    &#x2F;&#x2F; 写内容到文件,scala中没有实现写文件的api，我们需要通过调用Java的api来实现\n    val writer &#x3D; new PrintWriter(&quot;src&#x2F;main&#x2F;resources&#x2F;write.txt&quot;)\n    writer.write(&quot;I am learning scala&quot;)\n    writer.close()\n  &#125;\n&#125;\n\n数据类型数据类型是任何一门语言的重点，scala也不例外。\n学过java的应该知道Java有8个基本类型char，byte，short，int，long，float，double，boolean\n还有上面8中类型对应的引用类型，以及String或者是自定义的引用类型。\nscala是纯面向对象的语言，没有基本类型概念，我们通过官网一张图来看下类型继承关系。\n\n\nScala中一切数据都是对象，并且是Any的子类。\nScala中主要分为两种数据：数值类型(AnyVal)和引用类型(AnyRef)。\nScala和Java一样，低精度的数值类型自动转换为高精度的类型。\nScala中的String Ops是Java中String的增强\nUnit：等价于Java中的Void空值类型，标识方法没有返回值\nNull：Scala中的Null是所有应用类型的子类\nNothing：是所有类型的子类，主要用在一个函数没有明确返回值时使用，因为这样我们可以把抛出的返回值返回给任何的变量或者函数\n\n\n\n\n数值类型\n说明\n\n\n\nBoolean\ntrue或者false\n\n\nByte\n8 位有符号补码整数（-2^7 到 2^7-1] 也就是：-128 到 127\n\n\nShort\n16 位有符号补码整数（-2^15 到 2^15-1] 也就是 -32,768 到 32,767\n\n\nInt\n32 位二进制补码整数（-2^31 到 2^31-1，含]-2,147,483,648 到 2,147,483,647\n\n\nLong\n64 位二进制补码整数（-2^63 到 2^63-1]\n\n\nFloat\n32 位 IEEE 754 单精度浮点 1.40129846432481707e-45 到 3.40282346638528860e+38\n\n\nDouble\n64 位 IEEE 754 双精度浮点4.94065645841246544e-324d 到 1.79769313486231570e+308d\n\n\nChar\n16 位无符号 Unicode 字符（0 到 2^16-1，含）0 到 65,535\n\n\nString\n字符串，由多个Char组成\n\n\n按照上面的说明可以看到基本都是-2^(n-1)到2^(n-1) -1，那么为什么是是这样呢\n我们以Byte来举例说明，Byte是1个字节（byte），8位存（bit）储的。请注意总共有8位（bit）。\n首先有符号数用第一位（正着数）标识符号位1代表负数，0代表整数，那么剩下的7位就是数值位\n1符号位+7数值位=8位\n那么7位能够表示多少个数呢？应该是2的7次方。范围应该是0-127，再加上符号位就能够代表+(0-127)和-(0-127)，但是0是重复了，正数0（0000 0000）和负数0（1000 0000）其实是一样的。这就浪费了，所以规定正0是0，负0代表最大的负数(-128）。\n示例\npackage io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 数据类型操作\n *&#x2F;\nobject Test07_DataType &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; Boolean类型\n    var b1: Boolean &#x3D; false\n    b1 &#x3D; true\n\n\n    &#x2F;&#x2F; Byte\n    var a: Byte &#x3D; 127 &#x2F;&#x2F;正确\n    &#x2F;&#x2F;    a &#x3D; 128 &#x2F;&#x2F; 编译出错\n    &#x2F;&#x2F;    a &#x3D; -129 &#x2F;&#x2F; 编译出错\n\n    var b &#x3D; 128 &#x2F;&#x2F;128默认是Int\n\n    &#x2F;&#x2F; Long,可以不指定类型通过以L（l）结尾，建议使用大写。\n    val c: Long &#x3D; 122\n    val c1 &#x3D; 122L\n\n\n    &#x2F;&#x2F; 自动转化类型，下面的10和20默认是Int，相加&#x3D;30，是在Byte范围内的，这是允许的。\n    val d: Byte &#x3D; 10 + 20 &#x2F;&#x2F; IDEA提示类型不匹配（可能觉得后面应该是INT），但实际是可以运行的\n    println(d) &#x2F;&#x2F;30\n\n    val e: Byte &#x3D; 10\n    &#x2F;&#x2F;    val f: Byte &#x3D; e + 20  &#x2F;&#x2F; 编译器提示类型不匹配，这次匹配是确实不能执行的，这是因为这段代码只有到运行时才能获得b1的数据才能执行。\n    &#x2F;&#x2F; 可以使用强制类型转换\n    val f: Byte &#x3D; (e + 20).toByte &#x2F;&#x2F; 使用toByte强制转化为Byte类型\n\n    &#x2F;&#x2F; 超过范围情况\n    val g: Byte &#x3D; 127 &#x2F;&#x2F; 127是Byte的最大正数\n    val h: Byte &#x3D; 1\n    &#x2F;&#x2F;    val i: Byte &#x3D; g + h&#x2F;&#x2F; 运行会报错，因为127 + 1 &#x3D; 128 超出了Byte范围，而是一个Int值。使用Byte接收是不允许的。\n\n    &#x2F;&#x2F; 浮点类型\n    val j &#x3D; 1.23 &#x2F;&#x2F;默认是Double类型\n    &#x2F;&#x2F; 可以使用F(f)指定Float类型\n    val j1 &#x3D; 1.23F\n\n    &#x2F;&#x2F; 字符类型，标识单个字符,当然也包括控制字符（\\t,\\n等）\n    val k: Char &#x3D; &#39;a&#39;\n    val l: Char &#x3D; &#39;\\t&#39;\n    val m: Char &#x3D; &#39;\\\\&#39; &#x2F;&#x2F; 如果想打印\\需要使用转义\n\n    &#x2F;&#x2F; Char类型在计算机底层保存的是实际字面看到的字符吗？其实不是，真正保存的其实是ASCII码\n    val n: Int &#x3D; k\n    println(n) &#x2F;&#x2F; 97 ，也就是说字符&#39;a&#39;实际的整数值是97。\n\n    &#x2F;&#x2F; 整数转化为Char\n    println(98.toChar) &#x2F;&#x2F; b\n\n\n    &#x2F;&#x2F; Unit\n    val o: Unit &#x3D; ()\n    &#x2F;&#x2F; Null\n    val p: Null &#x3D; null\n    &#x2F;&#x2F; Nothing,比如下面方法可以返回Nothing，但是实际并不这么做，因为他是所有类型的子类\n    def  nothingTest() : Nothing &#x3D; &#123;\n      throw RuntimeException &#x2F;&#x2F; 必须抛出异常，否则提示返回类型应该是Void\n    &#125;\n    &#x2F;&#x2F;实际我们可能会这样做\n    def nothingTest(i: Int) : Int &#x3D; &#123;\n      if (i &#x3D;&#x3D; 0)\n        throw RuntimeException &#x2F;&#x2F; 必须抛出异常，否则提示返回类型应该是Void\n      else\n        i\n    &#125;\n\n  &#125;\n&#125;\n\n\n\n\n类型转换Scala中的数据转换规则跟Java的一样\n当Scala程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数值类型，这就是自动类型转换（也叫做隐式转换）。\n\n基本说明：\n​\t自动转换原则：多种类型混合运算时，系统会先自动将所有类型转换为精度大的类型，然后再做运算。\n​\t将精度大的赋值给精度小的数值类型时就会报错，反之自动转换\n​\t(Byte和Short)和Char之间不会自动相互转换\n​\tByte，Short，Char 三者运算会先转换为Int类型\n示例\npackage io.itlab1024.github.scala.chapter02\n\n&#x2F;**\n * 数据类型转换\n *&#x2F;\nobject Test08_DataTypeConversion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    自动转换原则：多种类型混合运算时，系统会先自动将所有类型转换为精度大的类型，然后再做运算。\n    val a: Byte &#x3D; 10\n    val b: Long &#x3D; 23L\n    &#x2F;&#x2F;    val c: Int &#x3D; a + b &#x2F;&#x2F; 编译错误，提示结果是Long，不允许用Int类型常量接收\n    val d: Int &#x3D; a + b.toInt &#x2F;&#x2F;这就没有问题，因为我将b通过toInt方法强制转换为Int，而a是Byte会自动提升为Int，计算结果是Int\n\n    &#x2F;&#x2F;    将精度大的赋值给精度小的数值类型时就会报错，反之自动转换\n    val e: Int &#x3D; 1\n    val f: Long &#x3D; e &#x2F;&#x2F;自动转换为高精度类型\n    &#x2F;&#x2F;    val g: Byte &#x3D; e &#x2F;&#x2F; 错误\n\n    &#x2F;&#x2F;   (&#96;Byte&#96;和&#96;Short&#96;)和&#96;Char&#96;之间不会自动相互转换\n    val h: Byte &#x3D; 1\n    &#x2F;&#x2F;    val i: Char &#x3D; h &#x2F;&#x2F; 错误\n    val j: Short &#x3D; 1\n    &#x2F;&#x2F;    val k: Char &#x3D; j &#x2F;&#x2F;错误\n\n\n    &#x2F;&#x2F;   &#96;Byte&#96;，&#96;Short&#96;，&#96;Char&#96; 三者运算会先转换为&#96;Int&#96;类型\n    &#x2F;&#x2F;    val l: Short &#x3D; h + j &#x2F;&#x2F; 错误提示应该是Int\n\n    &#x2F;&#x2F;数值类型和String的互相转换（重点，平时开发中常用）\n    &#x2F;&#x2F; 数值转String\n    val m: Int &#x3D; 1\n    val n: String &#x3D; m + &quot;&quot;\n\n    &#x2F;&#x2F; String转换为数值\n    val o: String &#x3D; &quot;1&quot;\n    val p: Int &#x3D; o.toInt &#x2F;&#x2F; 直接调用toInt方法\n\n    &#x2F;&#x2F; 注意异常问题\n    &#x2F;&#x2F;    val q : Int &#x3D; &quot;1.1&quot;.toInt &#x2F;&#x2F;编译不报错，运行是不允许的。\n\n\n    &#x2F;&#x2F; 数据溢出问题\n    val r: Int &#x3D; 200 &#x2F;&#x2F;200肯定超过了Bye的范围\n    val s: Byte &#x3D; r.toByte\n    println(s)&#x2F;&#x2F; 结果是-56 则是因为精度缺失了。\n    &#x2F;*我们分析下，Int是32位，\n    200的原码是：\n    00000000 00000000 00000000 11001000\n    补码\n    00000000 00000000 00000000 11001000\n\n    那么转化为Byte的时候要截取1个自己8位，得到结果是11001000，那他的原码就是取反(00110111),再加一(10111000),结果就是-56\n    *&#x2F;\n  &#125;\n&#125;\n\n\n运算符Scala中的运算符和Java中的基本相同。\n算术运算符算术运算符主要有+，-，*，/，%，不做详细介绍。\n\n\n\n运算符\n说明\n\n\n\n+\n加法运算，可以作用于数值也可用于字符串连接，比如 1+1、”a” + “b”\n\n\n-\n减法\n\n\n*\n乘法\n\n\n&#x2F;\n除法\n\n\n%\n求余 10&#x2F;3 &#x3D; 1\n\n\n关系运算符（比较运算符）关系运算符主要有==，!=，&lt;，&gt;，&lt;=，&gt;=，也跟Java基本相同，这里重点说下==,\n还记得java中的==和equals方法的区别吗？==是代表比较引用是否相等，equals代表比较值是否相等，不好理解，scala中就简单了很多==就是判断值是否相等，equals也是判断的值是否相等。\n那么scala中如何判断引用是否相等呢？eq方法。\n\n\n\n运算符\n说明\n\n\n\n&#x3D;&#x3D;\n比较是否相等，对于引用类型，等价于equals方法\n\n\n!&#x3D;\n不等于\n\n\n&lt;\n小于\n\n\n&gt;\n大于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;&#x3D;\n大于等于\n\n\n逻辑运算符逻辑运算符有&amp;&amp;，||，！\n\n\n\n运算符\n说明\n\n\n\n&amp;&amp;\n短路与，比如 a &gt; b &amp;&amp; c &gt; d，如果a &gt; b &#x3D;&#x3D; false,则后面的c &gt; d 不会执行。\n\n\n||\n短路或， 比如 a &gt; b || c &gt; d， 如果a&gt;b &#x3D;&#x3D; true,则后面的c &gt; d不会运行。\n\n\n!\n非，如果 a  &#x3D;&#x3D; false, 则!a &#x3D; true\n\n\n赋值运算符=，+=，-=，*=，/=，%=，&gt;&gt;=，&lt;&lt;= 跟Java也一样，不说了。\n需要注意的是scala中没有++，--运算符，java中有这个两个运算符，有坑，新手可能会进入误区。scala这点还是比较好的。\n\n\n\n运算符\n说明\n\n\n\n&#x3D;\n复制 val a &#x3D; 1 ,给a赋值1\n\n\n+&#x3D;\n先相加再赋值\n\n\n-&#x3D;\n先做减法在赋值\n\n\n*&#x3D;\n先做乘法再赋值\n\n\n&#x2F;&#x3D;\n先做除法再赋值\n\n\n%&#x3D;\n先求余再赋值\n\n\n&gt;&gt;&#x3D;\n先向右位移再赋值\n\n\n&lt;&lt;&#x3D;\n先向左移再赋值\n\n\n位运算符\n\n\n运算符\n说明\n\n\n\n&amp;\n按位与\n\n\n|\n按位或\n\n\n^\n按位异或\n\n\n~\n按位取反\n\n\n&lt;&lt;\n左移\n\n\n&gt;&gt;\n右移\n\n\n运算符的本质scala中的运算符都是方法。\n比如+我们也可通过类似方法调用的方式使用。\nval i &#x3D; j.+(1)\n\n\n\n流程控制if-else\n基本语法\nif（条件） &#123;\n\t&#x2F;&#x2F; 当条件是true的时候执行此处代码\n&#125; else &#123;\n  &#x2F;&#x2F; 当条件是false的时候执行此处代码\n&#125;\n\n用法与java基本一致。\n特别之处\nscala中每个表达式都是有返回值的，一是要保证每个分支返回类型相同，如果确实不同，则接收者类型要使用不同类型的父类。\npackage io.itlab1024.github.scala\n\nimport scala.io.StdIn\n\n&#x2F;**\n * if - else控制\n *&#x2F;\nobject Test01_IfElse &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; if else\n    val a: Int &#x3D; 1\n    if (a &gt; 0) &#123;\n      println(&quot;正数&quot;)\n    &#125; else if (a &#x3D;&#x3D; 0) &#123;\n      println(&quot;0&quot;)\n    &#125; else &#123;\n      println(&quot;负数&quot;)\n    &#125;\n\n\n\n\n    &#x2F;&#x2F; if else的返回值\n    val b: Int &#x3D; 10\n    val c : Unit &#x3D; if (b &gt; 0) &#123;\n      println(&quot;测试返回值&quot;)\n    &#125;\n    println(c) &#x2F;&#x2F; ()\n\n    &#x2F;&#x2F; 多分支情况要保证最后返回的类型相同\n    val d : String &#x3D; if (b &gt; 0) &#123;\n      println(&quot;测试返回值&quot;) &#x2F;&#x2F; 此处返回是Unit，而else中返回是String，而接收者d的类型是String，这是不允许的（假设下行字符串代码没有）。\n      &quot;此处也返回String，保证每个分支返回的数据类型格式统一&quot;\n    &#125; else &#123;\n      return &quot;abc&quot;\n    &#125;\n  &#125;\n&#125;\n\n\n\n\nmatch模式匹配scala中没有switch，取而代之的是match\n相比于Java，scala中的match，没有break关键字，使用_代表默认分支\npackage io.itlab1024.github.scala.chapter04\n\nobject Test02_Match &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F;match基本用法\n    val i &#x3D; 0\n    i match &#123;\n      case 0 &#x3D;&gt; println(&quot;等于0&quot;)\n      case _ &#x3D;&gt; println(&quot;不等于0&quot;) &#x2F;&#x2F; _代表默认分支\n    &#125;\n\n    &#x2F;&#x2F; match也有返回值\n    val str &#x3D; i match &#123;\n      case 0 &#x3D;&gt; &quot;ZERO&quot;\n      case _ &#x3D;&gt; &quot;NON ZERO&quot;\n    &#125;\n    println(str)\n\n    &#x2F;&#x2F; 同一个case语句有多个匹配值的时候，使用|分隔\n    i match &#123;\n      case 0 | 1 &#x3D;&gt; &quot;0 or 1&quot;\n      case _ &#x3D;&gt; &quot;other&quot;\n    &#125;\n\n    &#x2F;&#x2F; case中也可以使用表达式\n    val o  &#x3D; 1\n    i match &#123;\n      case i if (i &#x3D;&#x3D; 0) &#x3D;&gt; &quot;zero&quot; &#x2F;&#x2F;case后if表达式的括号scala是不推荐使用的。编辑器也提示给我们了\n      case _ if o &#x3D;&#x3D; 1 &#x3D;&gt; &quot;o is zero&quot;\n    &#125;\n\n    &#x2F;&#x2F;case语句中判断数组是否包含匹配的数据\n    i match &#123;\n      case a if 0 to 9 contains a  &#x3D;&gt; println(&quot;包含&quot;)\n    &#125;\n  &#125;\n&#125;\n\n\n\n\nmatch还支持匹配case class后面学到的时候再用。\nfor循环范围循环主要使用to和until关键字来实现范围循环，其中to标识包含左右边界值，比如 0 to 10包含0和10，until则不包含10\n &#x2F;&#x2F; 普通范围循环,使用to关键字,包含左右边界值\n for (i &lt;- 0 to 10) &#123;\n println(i)\n &#125;\n\n&#x2F;&#x2F; 也可以使用until方法， 不包含后面的边界值\nfor (i &lt;- 0 until 10) &#123;\nprintln(i)\n&#125;\n\n循环守卫循环守卫的意思是说允许在for循环范围语句后面增加if表达式，只有当表达式&#x3D;true的时候才进行循环\n&#x2F;&#x2F; 循环守卫\nval b : Int &#x3D; 0\nfor (i &lt;- 0 to 10 if b &gt; 1) &#123;\n&#x2F;&#x2F;永远不会执行，因为循环守卫 b &gt; &#x3D; 结果是false\n&#125;\n\n循环步长上面我们使用的for循环都是默认一步加一，有时候我们可能希望自定义步长。scala中使用by关键字来控制步长（步长不能是0 否则抛出异常，并且还能是小数）\n&#x2F;&#x2F; 循环步长\nfor (i &lt;- 1 to 10 by 2) &#123;\n\tprintln(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;\n&#x2F;&#x2F; by 后也可以使用负数，当从大到小遍历的时候有用\nfor (i &lt;- 20 to 1 by -2) &#123;\n  println(i) &#x2F;&#x2F;20,8,16,14,12,10,8,6,4,2\n&#125;\n&#x2F;&#x2F; 步长能使用小数吗？可以，要求to前后也必须是小数，也就是类型一致\nfor (i &lt;- 1.3 to 10.0 by 22.0) &#123; &#x2F;&#x2F;会提示to过期，使用BigDecimal，因为Double和Float计算结果取决于操作系统，会出现不准确。\n  println(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;\n&#x2F;&#x2F;使用BigDecimal\nfor (i &lt;- BigDecimal.decimal(1.3) to 10.0 by 22.0) &#123; &#x2F;&#x2F;会提示to过期，使用BigDecimal\n  println(i) &#x2F;&#x2F;1 3 5 7 9\n&#125;\n\nReverse&#x2F;&#x2F; 和下面的for循环等价\nfor (i &lt;- 20 to 1 reverse) &#123;\n\tprintln(i) \n&#125;\n\nfor (i &lt;- 1 to 20) &#123;\n\tprintln(i)\n&#125;\n\n引入变量&#x2F;&#x2F; 引入变量,j就是引入的变量，两个表达式用;隔开。\nfor (i &lt;-0 to 10 ; j &#x3D; i + 1) &#123;\n  println(s&quot;i&#x3D;$i, j&#x3D;$j&quot;)\n&#125;\n\n循环返回值scala中默认情况下返回的是Unit，必须使用yeild关键字来实现不同的返回值。\n&#x2F;&#x2F;循环返回值\nval s1: Unit &#x3D; for (i &lt;- 1 to 10) &#123;\n\t&quot;结果&quot;\n&#125;\nprintln(s&quot;s1 &#x3D; $s1&quot;) &#x2F;&#x2F;s1 &#x3D; ()\n\nval s2 &#x3D; for (i &lt;- 1 to 10) yield &#123;\n\t&quot;结果&quot;\n&#125;\nprintln(s&quot;s2 &#x3D; $s2&quot;) &#x2F;&#x2F; s2 &#x3D; Vector(结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果, 结果)\n\n&#x2F;&#x2F; 将i都乘以2 ，最终返回一个数组\nval s3 &#x3D; for (i &lt;- 1 to 10) yield &#123;\n  i * 2\n&#125;\nprintln(s3) &#x2F;&#x2F;Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n\nwhile和do…while和Java中完全一样，do while即便条件表达式不成立也会先执行一次。\n循环中断Java中关于循环中断有两个关键字break和continue，scala中没有这两个关键字，要使用breakable来实现，也可以使用try catch来实现。\n&#x2F;&#x2F; 循环中断\n&#x2F;&#x2F; try catch\ntry &#123;\n  for (i &lt;- 0 to 10) &#123;\n    if (i &#x3D;&#x3D; 1) &#123;\n      throw new RuntimeException\n    &#125;\n  &#125;\n&#125; catch &#123;\n  case e: Exception &#x3D;&gt; &#x2F;&#x2F; 什么也不做，退出循环\n&#125;\n&#x2F;&#x2F; try catch 虽然可时间，但是有点麻烦， 可以用breaks下的break方法\nBreaks.breakable(for (i &lt;- 0 to 10) &#123;\n  if (i &#x3D;&#x3D; 1) &#123;\n    Breaks.break();\n  &#125;\n&#125;)\n\n我只想说不如java的break方便。我觉得就是为了体现面向对象的思想。但是确实要麻烦了点。\n函数式编程函数基本语法def 函数名 (参数变量: 参数变量类型) : 返回类型 &#123;\n  &#x2F;&#x2F;函数体\n&#125;\n\n函数定义scala中的函数类似java支持0个或者多个参数，不同于java的是scala中的函数还支持多个返回值\n单返回值&#x2F;&#x2F; 函数，求两个整数的和\ndef sum (x: Int, y: Int) : Int &#x3D; &#123;\n\tx + y &#x2F;&#x2F; 可以省略return 这是scala中函数的特点\n&#125;\n\n\n\n多个返回值比如给定两个数返回两个数的和以及差值\n&#x2F;&#x2F; 多返回值\ndef sumAndDes(x: Int, y: Int): (Int, Int) &#x3D; &#123;&#x2F;&#x2F; 多个返回值用括号包裹起来\n\treturn (x + y, x - y) &#x2F;&#x2F; return可以省略\n&#125;\n\n\n\n可变参数\n可变参数可以通过 在类型后使用*来定义\n&#x2F;&#x2F; 可变参数\ndef printlnValues(values: String*)  &#x3D; &#123;\n&#125;\n\n参数默认值&#x2F;&#x2F;参数默认值\ndef defaultParmasFunc(x: Int &#x3D; 10) &#x3D; &#123;&#125;\n\n带名参数&#x2F;&#x2F; 带名参数\ndef namedParamFunc(name: String, age: Int): Unit &#x3D; &#123;\n\t&#x2F;&#x2F; 函数体\n&#125;\nnamedParamFunc(name &#x3D; &quot;张三&quot;, age &#x3D; 10) &#x2F;&#x2F; 调用的时候可以指定名称\n\n函数至简原则\nreturn可以省略，scala使用函数体最后一个代码作为返回值\n如果函数体只有一个行代码，大括号可以省略\n返回值类型如果能够推断出来，那么可以省略\n如果有return，则不能省略返回值类型，必须指定\n如果函数明确声明Unit，那么即便函数体中使用return也不会起作用\nscala如果无返回值类型，可以省略等号\n如果函数无参，但是声明了参数列表，那么调用时小括号可以省略\n如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略\n如果不关心名称只关心处理逻辑，那么def关键字可以省略，这就是匿名函数\n\n代码示例：\n&#x2F;&#x2F; 函数至简原则\n&#x2F;&#x2F;    * return可以省略，scala使用函数体最后一个代码作为返回值\ndef func1(x: Int): Int &#x3D; &#123;\n  x + 1\n&#125;\n\n&#x2F;&#x2F;    * 如果函数体只有一个行代码，大括号可以省略\ndef func2(x: Int): Int &#x3D; x + 1\n\n&#x2F;&#x2F;    * 返回值类型如果能够推断出来，那么可以省略\ndef func3(x: Int) &#x3D; x + 1\n\n&#x2F;&#x2F;    * 如果有return，则不能省略返回值类型，必须指定, 比如下面方法的: Int不能省略\ndef func4(x: Int): Int &#x3D; return x + 1\n\n&#x2F;&#x2F;    * 如果函数明确声明Unit，那么即便函数体中使用return也不会起作用,\ndef fun5(x: Int): Unit &#x3D; return x + 1\n\nprintln(fun5(1)) &#x2F;&#x2F; 结果不是2，而是(),也就是Unit\n\n&#x2F;&#x2F;    * scala如果无返回值类型，可以省略等号\ndef func6(x: Int) &#123;&#125;\n\n&#x2F;&#x2F;    * 如果函数无参，但是声明了参数列表，那么调用时小括号可以省略\ndef func7() &#x3D; &#123;&#125;\n\nfunc7 &#x2F;&#x2F; 等价于func7()\n\n&#x2F;&#x2F;    * 如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略\ndef fun8 &#x3D; &#123;&#125;\n\nfun8 &#x2F;&#x2F; 不能使用fun8()\n\n&#x2F;&#x2F;    如果不关心名称只关心处理逻辑，那么def关键字可以省略，这就是匿名函数\nval func9 &#x3D; (name: String) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 函数体\n  println(name)\n&#125;\n&#x2F;&#x2F;      如何调用呢,scala中什么都有返回值\n&#x2F;&#x2F;      上面的例子可以修改为\nfunc9(&quot;名字&quot;)\n\n\n\n函数的值传递&#x2F;&#x2F; ----函数的值传递------\n&#x2F;&#x2F; 先定义一个函数\ndef func10(i: Int): Int &#x3D; &#123;\n  println(&quot;函数func10被调用&quot;)\n  i + 1\n&#125;\n&#x2F;&#x2F; 函数作为值进行传递, 函数名后加上空格再加上_代表这是一个函数整体\nval f1 &#x3D; func10 _ &#x2F;&#x2F; 也可以写成val f1 : Int &#x3D;&gt; Int &#x3D; func10， 也可以写成\nprintln(f1)\nprintln(f1(10))\n\n函数作为参数传递&#x2F;&#x2F; 函数可以作为函数参数传递\n    &#x2F;&#x2F; 定义一个二元计算,下面的dualEval是一个函数，参数是op也是一个函数，此函数的参数列表是Int类型的a和b\ndef dualEval(op: (Int, Int) &#x3D;&gt; Int, a: Int, b: Int): Int &#x3D; &#123;\n  op(a, b)\n&#125;\n\ndef op(a: Int, b: Int): Int &#x3D; &#123;\n  a + b\n&#125;\n\nprintln(op(1, 2)) &#x2F;&#x2F; 3\n\n函数可以作为函数的返回值&#x2F;&#x2F; 函数可以作为函数的返回值\ndef returnFunc(): String &#x3D;&gt; String &#x3D; &#123;\n  def subFunc1(s: String) &#x3D; &#123;\n    println(s)\n    &quot;晕&quot;\n  &#125;\n\n  subFunc1\n&#125;\n\nval stringToString: String &#x3D;&gt; String &#x3D; returnFunc()\nval str &#x3D; stringToString(&quot;参数&quot;)\nprintln(str)\n\n练习val arr: Array[Int] &#x3D; Array(1, 2, 3)\n\n&#x2F;&#x2F; 对数组进行处理，将操作抽象出来，处理完毕的结果返回一个新的数组\ndef arrayOperation(array: Array[Int], op: Int &#x3D;&gt; Int): Array[Int] &#x3D; &#123;\n  for (a &lt;- array) yield op(a)\n&#125;\n\n&#x2F;&#x2F; 定义一个+1操作\ndef addOne(i: Int): Int &#x3D; i + 1\n\n&#x2F;&#x2F; 我们先对数组arr进行加一，返回新的数组\nval newArr &#x3D; arrayOperation(arr, addOne)\n\nprintln(newArr.mkString(&quot;,&quot;)) &#x2F;&#x2F; 2,3,4\n\n函数柯里化&amp;闭包闭包：如果一个函数，访问到了他的外部（局部）变量的值，那么这个函数和他所在的环境，就称为闭包\n函数柯里化：把一个参数列表的多个参数，编程多个参数列表。\n &#x2F;&#x2F; 闭包\ndef add(i: Int): Int &#x3D;&gt; Int &#x3D; &#123;\n  def add2(j: Int): Int &#x3D; &#123;\n    i + j\n  &#125;\n\n  add2\n&#125;\n\nval f1 &#x3D; add(1) &#x2F;&#x2F;f1是一个函数\nprintln(f1(2)) &#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 函数柯里化，比如上面的闭包就可以写成如下模式，并且推荐使用函数的库里化\ndef addCurrying(a: Int)(b: Int): Int &#x3D; &#123;\n  a + b\n&#125;\nprintln(addCurrying(1)(2))\n\n\n\n递归自己调用自己就是递归。\n示例：n的阶乘，比如5！&#x3D; 1x2x3x4x5;\npackage io.github.itlab1024.scala.chapter05\n\n&#x2F;**\n * 递归\n *&#x2F;\nobject Test04_Recursion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(fact(5))\n  &#125;\n\n  def fact(n: Int): Int &#x3D; &#123;\n    if (n &#x3D;&#x3D; 0) return 1\n    fact(n - 1) * n\n  &#125;\n\n&#125;\n\n&#x2F;&#x2F; 递归有什么问题呢?会出现栈帧过多，出现Stack Overflow错误，在scala中如何解决呢？\ndef fact2(n: Int) : Int &#x3D; &#123;\n  @tailrec\n  def work(n: Int, result: Int) : Int &#x3D; &#123;\n    if (n &#x3D;&#x3D; 0) return result\n    work(n-1, result * n)\n  &#125;\n  work(n , 1)\n&#125;\nprintln(fact2(5)) &#x2F;&#x2F; 结果也是120，但是这种方式就不会增多栈帧数量\n\n\n\n控制抽象package io.github.itlab1024.scala.chapter05\n\n&#x2F;**\n * 控制抽象\n *&#x2F;\nobject Test05_ControlAbstraction &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 通常函数调用我们都是传递值\n    &#x2F;&#x2F; 传值参数\n    def f1(): Int &#x3D; &#123;\n      println(&quot;f1调用&quot;)\n      1\n    &#125;\n\n    def f2(i: Int): Int &#x3D; &#123;\n      i\n    &#125;\n\n    println(f2(f1()))\n\n    println(&quot;------&quot;)\n\n    &#x2F;&#x2F; 不同于上面的传值参数，接下来看下什么是传名参数\n    &#x2F;&#x2F; 请注意参数的类型 &#x3D;&gt; Int\n    def f3(i: &#x3D;&gt; Int): Unit &#x3D; &#123;\n      println(i)\n      println(i)\n    &#125;\n    f3(f1()) &#x2F;&#x2F;这里需要注意的是f1调用了几次呢？两次，奇怪不，是因为上面f3对于i打印了2次，所有f1就被调用了两次\n    &#x2F;&#x2F; 运行结果是：\n    &#x2F;*\n    ------\n    f1调用\n    1\n    f1调用\n    1\n    *&#x2F;\n\n  &#125;\n&#125;\n\n懒加载当函数返回值被声明为lazy的时候，函数的执行将被推迟，知道我们首次对其取值，该函数才会运行，这种函数被称为惰性函数\n类似于Java JPA中的lazy的概念。\npackage io.github.itlab1024.scala.chapter05\n\nobject Test06_LazyFunc &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    lazy val i &#x3D; addOne(1)\n    println(i) &#x2F;&#x2F; 如果注释掉改行，也就是i不被使用，则addOne方法不会被执行\n  &#125;\n\n  def addOne(i: Int): Int &#x3D; &#123;\n    println(&quot;addOne方法被调用&quot;)\n    i + 1\n  &#125;\n&#125;\n\n\n面向对象编程Scala中的面向对象基本和Java相同，我是个javaer，一样的地方我就不写了。主要记录下不同的地方。\n包scala有两种包的管理方式，一种和java一样，一个源文件在一个包下（包名和文件所在路径不要求一致），另外一种是scala中支持包名的嵌套\n该种方式的特点是：\n一个源文件可以有多个包\n子包中的类可以直接访问父包汇总的内容，无需导包\n&#x2F;&#x2F; 嵌套风格的package\npackage p1 &#123;\n  &#x2F;&#x2F; 定义一个单例对象\n  object o1 &#123;\n    val N1: String &#x3D; &quot;N1&quot;\n  &#125;\n  package p2 &#123;\n    object o2 &#123;\n      def main(args: Array[String]): Unit &#x3D; &#123;\n        o1.N1 &#x2F;&#x2F; 直接调用外层包\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n包对象在scala中可以为每个包定义一个同名的包对象，定义在包对象的成员，做为其对应包下的所有class和objcet的共享变量，可以直接访问。\npackage io.github.itlab1024.scala\n\npackage object chapter06 &#123;\n  &#x2F;&#x2F; 定义共享的值\n  val sharedValue1 : Int &#x3D; 1\n  &#x2F;&#x2F; 定义共享方法\n  def pkgName() : String &#x3D; &#123;\n    &quot;io.github.itlab1024.scala.chapter06&quot;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 调用包对象\npackage io.github.itlab1024.scala.chapter06\n\nobject Test02_PackageObject &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 调用包对象的方法和成员\n    println(sharedValue1)\n    println(pkgName())\n  &#125;\n&#125;\n\n\n\n包导入跟java相同，有以下不同之处\n\n嵌套包可以不通过的包下import，这是局部引入，只在当前包下有效。\n可以屏蔽某一个类，比如import java.util.&#123;HashSet =&gt; _,_&#125;\n导入相同包的多个类，用&#123;&#125;括起来，逗号分隔\n。。。。。。\n\npackage io.github.itlab1024.scala.chapter06\n\n&#x2F;**\n * 包导入\n *&#x2F;\n&#x2F;&#x2F; 给类起别名\nimport java.util.&#123;ArrayList &#x3D;&gt; MyArrays&#125;\n&#x2F;&#x2F; 不导入HashMap，这有啥用？？?\nimport java.util.&#123;HashMap &#x3D;&gt; _&#125;\n\nobject Test03_PackageImport &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 使用别名\n    val i: MyArrays[Int] &#x3D; new MyArrays[Int]()\n\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 嵌套包导入\npackage A &#123;\n  package B &#123;\n\n  &#125;\n&#x2F;&#x2F; 有些就不尝试了，感觉用处不大\n&#125;\n\n类和对象类和对象的定义跟java一样，类可以看成一个模板，对象可以认为是一个具体的事务\n注意：在scala中没有public关键字（默认就是public的），一个.scala文件中可以定义多个类。\n基本语法：\n[修饰符] class 类名 &#123;\n\t&#x2F;&#x2F;类的body体\n&#125;\n\n示例\npackage io.github.itlab1024.scala.chapter06\n\nimport scala.beans.BeanProperty\n\nobject Test04_Class &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val it &#x3D; new IT\n    it.name &#x2F;&#x2F;可以访问\n    &#x2F;&#x2F;    it.age &#x2F;&#x2F; 因为是private，不能访问\n    &#x2F;&#x2F; 赋值\n    &#x2F;&#x2F;    it.name &#x3D; &quot;itlab1024&quot; &#x2F;&#x2F; val常量不能变更值\n    it.weibo &#x3D; &quot;itlab&quot; &#x2F;&#x2F; 可以\n    &#x2F;&#x2F; homeUrl 我们加了 @BeanProperty注解，就可以使用get和set方法\n    it.setHomeUrl(&quot;&quot;)\n    it.getHomeUrl\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个类\nclass IT &#123;\n  &#x2F;&#x2F; 定义属性和方法\n  val name: String &#x3D; &quot;itlab&quot;\n  &#x2F;&#x2F; 可以定义为私有的\n\n  private var age: Int &#x3D; 1\n  @BeanProperty &#x2F;&#x2F; @BeanProperty 提供getter方法和setter方法\n  var homeUrl &#x3D; &quot;itlab1024.github.io&quot;\n\n  var weibo: String &#x3D; _\n\n&#125;\n\n封装封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（成员方法），才能对数据进行操作。\n访问权限scala中没有public关键字，但是有private和protected\nprivate:只有类的内部和半生对象可以访问\nprotected:同类子类可以访问，同一个包的不同类不能够访问\nprivate [包名]：增加包访问权限，包名下的其他类可以访问。\npackage io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 定义一个父类\nclass Test04_ClassForAccess &#123;\n  private var idCard: String &#x3D; &quot;1333x&quot;\n  private var name: String &#x3D; &quot;itlab&quot;\n  var sex: String &#x3D; &quot;男&quot;\n  private[chapter06] var age: Int &#x3D; 1\n\n  def printInfo(): Unit &#x3D; &#123;\n    println(s&quot;Persion: $idCard $name, $sex $age&quot;)\n  &#125;\n&#125;\n\npackage io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 定义一个子类\nclass Test04_Access extends Test04_ClassForAccess &#123;\n  override def printInfo(): Unit &#x3D; &#123;\n    &#x2F;&#x2F;    println(idcard) &#x2F;&#x2F; 无法访问，idcard是private 只能在本类和其伴生对象中访问\n    println(name) &#x2F;&#x2F;可以访问，protected，可以再父子类访问\n    println(sex) &#x2F;&#x2F;可以访问，默认public的\n\n    println(age) &#x2F;&#x2F; age可以访问，因为使用了private [chapter06]声明了\n  &#125;\n&#125;\n\n\n方法方法和函数一样，只不过方法是类中函数的一种特殊叫法\npackage io.github.itlab1024.scala.chapter06\n\nclass Test05_Method &#123;\n  &#x2F;&#x2F; 定义一个方法\n  def method1(): Int &#x3D; &#123;\n    1\n  &#125;\n&#125;\n\nclass subClass extends Test05_Method &#123;\n  &#x2F;&#x2F; 使用override关键字实现函数的重写\n  override def method1(): Int &#x3D; super.method1()\n&#125;\n\n创建对象&#x2F;&#x2F; 使用new关键字\nobject Test05_Method &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val method &#x3D; new Test05_Method &#x2F;&#x2F; 使用new创建一个类的实例对象\n    method.method1() &#x2F;&#x2F; 调用方法\n  &#125;\n&#125;\n\n构造器scala中也有构造方法，可以定义多个，不同的是定义有点区别。\nscala中分为主构造器（仅有一个），和副构造器（可以有多个），用this作为方法名\npackage io.github.itlab1024.scala.chapter06\n\n&#x2F;&#x2F; 默认就有一个主构造器，下面的()可以省略。\nclass Test06_Constructor() &#123;\n  var name: String &#x3D; &quot;&quot;\n  var age: Int &#x3D; 10\n  println(&quot;主构造器被调用&quot;)\n\n  &#x2F;&#x2F; 副构造器，可以有多个\n  def this(name: String) &#123;\n    this() &#x2F;&#x2F;直接调用主构造器\n    this.name &#x3D; name\n    println(&quot;副构造器被调用&quot;)\n  &#125;\n&#125;\n\nobject Test06_Constructor &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    new Test06_Constructor()\n\n    println(&quot;--------&quot;)\n\n    new Test06_Constructor(&quot;1&quot;)\n\n    &#x2F;*\n    运行结果：\n\n    \n    主构造器被调用\n    --------\n    主构造器被调用\n    副构造器被调用\n    * *&#x2F;\n  &#125;\n&#125;\n\n主构造器参数上面的主构造器是默认的，我们没有进行修改，默认无参，也可以定义参数\n&#x2F;&#x2F; 参数可以使用val或者var，如果不修饰则通过 对象.属性名 无法获取到值，可以如下面的age那样指定默认值\nclass ConstructorParams(private var name: String, val age: Int &#x3D; 1) &#123;\n  &#x2F;&#x2F;    var name: String &#x3D; &quot;itlab&quot; &#x2F;&#x2F; 无需再次定义name，否则报错\n\n  &#x2F;&#x2F; 定义方法打印name\n  def printName(): Unit &#x3D; &#123;\n    println(this.name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; mian方法调用\n&#x2F;&#x2F; 主构造器参数\nval cp &#x3D; new ConstructorParams(&quot;itlab&quot;) &#x2F;&#x2F; age有默认值，可以省略\ncp.age &#x2F;&#x2F; 可以访问\n&#x2F;&#x2F;    cp.name &#x2F;&#x2F; 访问不到name\n&#x2F;&#x2F; 调用printname方法\ncp.printName() &#x2F;&#x2F; itlab\n\n继承和多态scala中的继承通过extends关键字，主要有以下特点\n\n子类继承父类的属性和方法\n单继承\n构造器先执行父类再执行子类\n\npackage io.github.itlab1024.scala.chapter06\n\nobject Test07_ClassExtends &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val clazz &#x3D; new SubClass(&quot;itlab&quot;, 1, &quot;男&quot;)\n    &#x2F;&#x2F;运行结果\n    &#x2F;*\n    ParentClass 主构造器执行\n    SubClass 主构造器执行\n    SubClass 副构造器调用\n     *&#x2F;\n  &#125;\n&#125;\n\nclass ParentClass &#123;\n  var name: String &#x3D; &quot;ITLAB&quot;\n  var age &#x3D; 1\n  println(&quot;ParentClass 主构造器执行&quot;)\n\n  def this(name: String, age: Int) &#123;\n    this()\n    println(&quot;ParentClass 副构造器调用&quot;)\n    this.name &#x3D; name\n    this.age &#x3D; age\n  &#125;\n\n  def printName() &#x3D; &#123;\n    println(this.name)\n  &#125;\n&#125;\n\nclass SubClass extends ParentClass &#123;\n  println(&quot;SubClass 主构造器执行&quot;)\n  var sex: String &#x3D; _\n\n  def this(name: String, age: Int, sex: String) &#123;\n    this()\n    println(&quot;SubClass 副构造器调用&quot;)\n    this.name &#x3D; name\n    this.age &#x3D; age\n    this.sex &#x3D; sex\n  &#125;\n\n  &#x2F;&#x2F;重写printName方法\n  override def printName(): Unit &#x3D; &#123;\n    println(this.name + &quot; 子类&quot;)\n  &#125;\n  \n  &#x2F;&#x2F; 多态，简单介绍下，没什么特别的 跟java一样\n  def f1() &#123;&#125;\n  def f1(i: Int)&#123;&#125;\n&#125;\n\n抽象scala中使用abstract定义抽象类，继承和重写需要注意的点\n\n如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需要声明为抽象类\n重写非抽象方法需要用override修饰，重写抽象方法可以省略override修饰。\n子类调用父类的方法使用super关键字\n子类对抽象属性进行实现，父类抽象属性可以用var修饰，子类对非抽象属性重写，父类非抽象属性只支持val类型\n\n示例\npackage io.github.itlab1024.scala.chapter06\n\nobject Test08_AbstractClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val clazz &#x3D; new Class1\n    clazz.name\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 抽象类\nabstract class Test08_AbstractClass &#123;\n  &#x2F;&#x2F; 非抽象属性，抽象方法中的属性不用初始化，其他情况必须初始化\n  var name: String &#x3D; &quot;itlab1024&quot;\n  &#x2F;&#x2F; 抽象属性（只声明，没有初始化）\n  val age: Int\n\n  &#x2F;&#x2F; 非抽象方法\n  def f1(): Unit &#x3D; &#123;&#125;\n\n  &#x2F;&#x2F; 抽象方法\n  def f2(): Unit\n&#125;\n\n&#x2F;**\n * 普通类继承抽象类\n *&#x2F;\nclass Class1 extends Test08_AbstractClass &#123;\n  &#x2F;&#x2F; age属性是抽象属性，所以普通类继承的时候必须初始化, override可以省略，但是我个人建议还是加上，代码清晰\n  override val age: Int &#x3D; 1\n\n  &#x2F;&#x2F; f2 是抽象方法，普通类继承的时候必须实现该方法, override可以省略，但是我个人建议还是加上，代码清晰\n  override def f2(): Unit &#x3D; &#123;\n    super.f1() &#x2F;&#x2F;可以使用super调用父抽象类的方法\n    println(age)\n  &#125;\n\n  &#x2F;&#x2F; 重写非抽象方法, override不能省略\n  override def f1() &#123;\n  &#125;\n\n  &#x2F;&#x2F; 重写非抽象属性, override不能省略, 此处虽然编译没有问题，但是运行时会提示错误&quot;overriding variable name in class Test08_AbstractClass of type String;\n  &#x2F;&#x2F; variable name cannot override a mutable variable\n  &#x2F;&#x2F;  override var name: String &#x3D; &quot;&quot;&quot;\n  &#x2F;&#x2F; 也就是说变量不需要重写，直接使用name &#x3D; &quot;value&quot;即可。可以将name修改为val下面的代码就不会有有问题\n  override var name: String &#x3D; &quot;&quot;\n&#125;\n\n匿名子类package io.github.itlab1024.scala.chapter06\n\nabstract class Test09_AnonymousClass &#123;\n  var name: String\n  def f1()\n&#125;\nobject Test09_AnonymousClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    new Test09_AnonymousClass &#123;\n      override var name: String &#x3D; &quot;&quot;\n\n      override def f1(): Unit &#x3D; &#123;&#125;\n    &#125;\n  &#125;\n&#125;\n\n跟java一样。\n单例对象（伴生对象）scala中没有static，因为他设计为完全面向对象，static并不符合面向对象的思想，但是为了兼容java的静态概念，scala就创造了伴生对象（也叫做单例对象）.\n单例对象使用object来定义\n示例：\npackage io.github.itlab1024.scala.chapter06\n\nimport io.github.itlab1024.scala.chapter06.Test09_Object.SCALA_NAME\n\n&#x2F;**\n * 伴生对象，举个例子，一个类的所有示例对象可能都有一个共同值，在java中，我们在类中定义一个static的变量，然后对象中通过类型.属性名进行访问\n * 在scala中使用伴生对象来解决，比如下面的Test09_Object有两个，一个是class修饰，一个是object修饰。\n * object是伴生对象，伴随class修饰的类而生，两者名字要相同\n *&#x2F;\nobject Test09_Object &#123;\n  &#x2F;&#x2F; 这就类似于java中的。 public staitc final String SCALA_NAME &#x3D; &quot;scala&quot;\n  val SCALA_NAME: String &#x3D; &quot;scala&quot;\n&#125;\n\nclass Test09_Object &#123;\n  val name: String &#x3D; SCALA_NAME\n&#125;\n\n通过伴生对象我们能够实现单例模式\n示例\npackage io.github.itlab1024.scala.chapter06\n\nobject Test10_Singleton &#123;\n  private val test10_Singleton: Test10_Singleton &#x3D; new Test10_Singleton(&quot;itlab1024&quot;)\n\n  def getInstance(): Test10_Singleton &#x3D; &#123;\n    test10_Singleton\n  &#125;\n\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(Test10_Singleton.getInstance().eq(Test10_Singleton.getInstance())) &#x2F;&#x2F; true 说明实例只有一个\n  &#125;\n&#125;\n\n&#x2F;&#x2F;主构造方法使用private修饰。\nclass Test10_Singleton private(val name: String) &#123;\n\n&#125;\n\n\n\n特质(Trait)scala中的特质就是接口，和java中的interface类似\nscala中的特质可以包含抽象属性和方法，也可以包含具体的属性和方法，感觉跟java中的abstract更相似。子类使用extends来实现特质，如果有多个特质，则with连接，如果又继承类，同时又实现特质的时候，应该把类紧跟在extends后。\npackage io.github.itlab1024.scala.chapter06\n\nobject Test11_Trait &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val s &#x3D; new S\n    s.f2()\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个父类\nclass P &#123;\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;p调用&quot;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义两个trait\ntrait t1 &#123;\n  var name: String\n\n  def f1(): Unit\n\n  val age: Int &#x3D; 10\n\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;t1调用&quot;)\n  &#125;\n&#125;\n\ntrait t2 &#123;\n  var  name: String\n\n  def f1(): Unit\n\n  val age: Int &#x3D; 10\n\n  def f2(): Unit &#x3D; &#123;\n    println(&quot;t2调用&quot;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子类,继承父类p，实现特质1和特质2,请注意下面的顺序\nclass S extends P with t1 with t2 &#123;\n  override var name: String &#x3D; &quot;&quot;\n\n  override def f1(): Unit &#x3D; &#123;&#125;\n\n  override val age: Int &#x3D; 10\n\n  override def f2(): Unit &#x3D; super.f2() &#x2F;&#x2F; f2方法在两个特质里都有， super.f2()调用的是谁呢？是特质t2\n&#125;\n\n需要注意的是如果一个类继承了父类，并且实现了多个特质，比如subClass extends ParentClass with trait1 with trait2 ,并且父类和两个特质都定义了相同的方法，那么子类的super.方法()。调用的是traint2的方法，这里可以理解为方法被覆盖了。\n特质叠加、特质钻石问题以后测试。\n类型检查和转换java中使用instanceOf 关键字，scala中使用的是函数isInstanceOf,转换则使用asInstanceOf。\n示例\npackage io.github.itlab1024.scala.chapter06\n\nobject Test11_TypeCheckAndConversion &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    val ball &#x3D; new Ball\n    println(&quot;ball是Ball类型吗?&quot; + ball.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball是BasketBall类型吗?&quot; + ball.isInstanceOf[BasketBall]) &#x2F;&#x2F; false\n    val ball2 &#x3D; new BasketBall\n\n    println(&quot;ball2是Ball类型吗?&quot; + ball2.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball2是BasketBall类型吗?&quot; + ball2.isInstanceOf[BasketBall]) &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 可以将父类型装置转化为子类型\n    val ball3: BasketBall &#x3D; new BasketBall\n    println(&quot;ball3是Ball类型吗?&quot; + ball3.isInstanceOf[Ball]) &#x2F;&#x2F; true\n    println(&quot;ball3是BasketBall类型吗?&quot; + ball3.isInstanceOf[BasketBall]) &#x2F;&#x2F; true\n    &#x2F;&#x2F;    转换\n    val ball4: Ball &#x3D; ball3.asInstanceOf[Ball]\n\n  &#125;\n&#125;\n\nclass Ball &#123;\n\n&#125;\n\nclass BasketBall extends Ball &#123;\n\n&#125;\n\n枚举类和应用类\n枚举类需要继承Enumeration\n应用类需要继承App\n\n示例\npackage io.github.itlab1024.scala.chapter06\n\nobject Test12_EnumAndAppClass &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    println(TimeUnit.YEAR) &#x2F;&#x2F;YEAR\n    println(TimeUnit.DAY) &#x2F;&#x2F; DAY\n    println(TimeUnit.HOUR) &#x2F;&#x2F; HOUR\n    println(TimeUnit.YEAR.id) &#x2F;&#x2F; 0\n    println(TimeUnit.DAY.id) &#x2F;&#x2F; 3\n    println(TimeUnit.HOUR.id) &#x2F;&#x2F; 4\n    println(TimeUnit.MONTH.id) &#x2F;&#x2F; 1\n\n    &#x2F;&#x2F; 通过名字获取到枚举\n    val value &#x3D; TimeUnit.withName(&quot;MONTH&quot;)\n    println(value)\n  &#125;\n&#125;\n\nobject TimeUnit extends Enumeration &#123;\n  val YEAR: TimeUnit.Value &#x3D; Value(&quot;YEAR&quot;)\n  val MONTH: TimeUnit.Value &#x3D; Value\n  val DAY: TimeUnit.Value &#x3D; Value(3, &quot;DAY&quot;)\n  val HOUR: TimeUnit.Value &#x3D; Value\n  val MINUTE: TimeUnit.Value &#x3D; Value(&quot;MINUTE&quot;)\n  val SECOND: TimeUnit.Value &#x3D; Value\n&#125;\n\n&#x2F;&#x2F; 应用类\nobject MyApp extends App &#123;\n  println(&quot;继承APP就省去了main的定义&quot;)\n&#125;\n\n集合\nscala中的集合有三大类，Seq，Set，Map。所有的集合都实现Iterable特质\n\n对于几乎所有的集合类，scala都提供可变和不可变两个版本，分别位于scala.collection.mutable和scala.collection.immutable中\n\nscala不可变集合，就是指该集合对象不可修改，每次修改就会返回一个新对象，而不会对原对象进行更改。\n\n可变集合，就是这个集合可以直接对原集合进行修改。不会返回新的对象\n\n\n建议：在集合操作的时候，不可变用符号，可变用方法。\n集合继承图\n\n数组不可变数组示例\npackage io.github.itlab1024.scala.chapter07\n\nobject Test01_ImmutableArray &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    var arr: Array[Int] &#x3D; new Array[Int](10)\n    &#x2F;&#x2F; 另一种创建的方式,使用apply方法\n    val array &#x3D; Array.apply(1, 2, 3) &#x2F;&#x2F; 可省略apply方法， Array(1, 2, 3)\n    println(array.length)\n    &#x2F;&#x2F; 访问数组中的元素\n    val i &#x3D; array(0)\n    println(&quot;第一个元素是:&quot; + i) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; 修改,不是说不可变吗，要注意的是不可变数组的不可变是说内存地址不变，大小不可变，索引上的元素还是可以变的\n    array(0) &#x3D; 4\n    println(array.mkString(&quot;,&quot;)) &#x2F;&#x2F; 4,2,3\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 循环数组\n    &#x2F;&#x2F; 普通for loop\n    for(i &lt;- 0 until array.length) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 上面代码提示我们可以使用array.indices\n    for (i &lt;- array.indices) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 我们也可以使用如下方法\n    for (i &lt;- array) &#123;\n      println(i)\n    &#125;\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 也可以使用foreach方法，函数式编程\n    array.foreach(println)\n\n    println(&quot;------------&quot;)\n    &#x2F;&#x2F; 迭代器\n    val iterator &#x3D; array.iterator\n    while (iterator.hasNext) &#123;\n      println(iterator.next())\n    &#125;\n    println(&quot;------------&quot;)\n\n    &#x2F;&#x2F; 添加元素(追加到最后，使用:+()方法)\n    val newArray &#x3D; array.:+(0) &#x2F;&#x2F; 返回新的数组\n    newArray.foreach(println)\n    println(&quot;------------&quot;)\n\n    &#x2F;&#x2F; 向最前面添加元素(使用+:()方法)\n    val newArray2 &#x3D; newArray.+:(-1)\n    newArray2.foreach(println)\n\n    &#x2F;&#x2F; 简化使用+:和:+\n    val ints &#x3D; newArray2 :+ 1\n    val ints2 &#x3D; 29 +: newArray2\n    \n    \n\n  &#125;\n&#125;\n\n可变数组可变数组ArrayBuffer\npackage io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable.ArrayBuffer\n\n&#x2F;**\n * 可变数组ArrayBuffer\n *&#x2F;\nobject Test02_ArrayBuffer &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建可变数组\n    val _ &#x3D; new ArrayBuffer[Int]()\n    &#x2F;&#x2F; 第二种方法使用伴生对象\n    val array &#x3D; ArrayBuffer(1, 2, 3)\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 访问数组的元素\n    val i &#x3D; array(0)\n    println(i)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 修改\n    array(0) &#x3D; -1\n    println(array)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 添加元素 可以使用:+和+:的方式，但是需要注意的是需要定义新的数组来接收。\n    val ints &#x3D; array :+ 2 &#x2F;&#x2F; 向后追加\n    println(ints)\n    println(&quot;---------&quot;)\n    &#x2F;&#x2F; 向前追加\n    val ints1 &#x3D; 1 +: array\n    println(ints1)\n\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 向后追加推荐使用+&#x3D;来实现\n    println(array) &#x2F;&#x2F; ArrayBuffer(-1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 向前追加使用+&#x3D;:\n    1 +&#x3D;: array\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, -1, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 也可使用append方法和prepend方法\n    array.append(1)\n    println(array) &#x2F;&#x2F; ArrayBuffer(1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n    array.prepend(0)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 插入值\n    array.insert(1, 100) &#x2F;&#x2F;在索引1的位置插入100，后面的值后移\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 100, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 删除元素\n    array.remove(1)\n    println(array) &#x2F;&#x2F;ArrayBuffer(0, 1, -1, 2, 3, 1)\n    println(&quot;---------&quot;)\n    &#x2F;&#x2F; 也可以删除索引后的几个值\n    array.remove(1, 2)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3, 1)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F;也可以根据值来删除\n    array -&#x3D; 1\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3)\n    println(&quot;---------&quot;)\n\n    &#x2F;&#x2F; 如果有多个相同的值呢，使用-&#x3D;只会删除一个，并且从左向右寻找。\n    array.append(1, 2, 1)\n    println(array) &#x2F;&#x2F; ArrayBuffer(0, 2, 3, 1, 2, 1)\n    array -&#x3D; 1\n    println(array) &#x2F;&#x2F;ArrayBuffer(0, 2, 3, 2, 1)\n    \n\n  &#125;\n&#125;\n\n可变数组与不可变数组的转换&#x2F;&#x2F; 可变数组与不可变数组的转换\nvar a1 &#x3D; ArrayBuffer[Int](1, 2, 3)\n&#x2F;&#x2F; 转换为不可变数组\nval array1: Array[Int] &#x3D; a1.toArray\n&#x2F;&#x2F; 将不可变数组转化为可变数组\nval buffer: mutable.Buffer[Int] &#x3D; array1.toBuffer\n\n多维数组package io.github.itlab1024.scala.chapter07\n\n&#x2F;**\n * 多维数组\n *&#x2F;\nobject Test03_MultiArray &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建一个二维数组\n    val array: Array[Array[Int]] &#x3D; Array.ofDim[Int](2, 2)\n\n    &#x2F;&#x2F; 设置元素\n    array(0)(1) &#x3D; 1\n\n    &#x2F;&#x2F; 访问元素\n    val i: Int &#x3D; array(0)(1)\n    println(i) &#x2F;&#x2F; 1\n    println(&quot;------&quot;)\n\n    &#x2F;&#x2F; 遍历二维数组\n    for (i &lt;- array.indices; j &lt;- array(i).indices) &#123;\n      println(array(i)(j) + &quot;\\t&quot;)\n      if (j &#x3D;&#x3D; array(i).length - 1) println()\n    &#125;\n\n    &#x2F;&#x2F; 使用foreach循环\n    array.foreach(_.foreach(println))\n  &#125;\n&#125;\n\n列表Listpackage io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable.ListBuffer\n\nobject Test04_List &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建一个不可变的List,可以使用apply。\n    val l: List[Int] &#x3D; List.apply(1, 2, 3)\n    &#x2F;&#x2F; 也可以使用伴生对象创建\n    val list: List[Int] &#x3D; List(1, 2, 3)\n\n    &#x2F;&#x2F; 访问list的元素\n    val i &#x3D; list(1)\n    println(i) &#x2F;&#x2F; 2\n\n    &#x2F;&#x2F; 赋值\n    &#x2F;&#x2F;    list(0) &#x3D; 10 &#x2F;&#x2F; 这是不允许的\n\n    &#x2F;&#x2F; 遍历，可以使用普通for循环，或foreach\n    for(i &lt;- list.indices) &#123;\n      println(i)\n    &#125;\n\n    &#x2F;&#x2F; 添加元素\n    &#x2F;&#x2F; 向最后添加\n    val list1 &#x3D; list :+ 10\n    println(list1) &#x2F;&#x2F; List(1, 2, 3, 10)\n    &#x2F;&#x2F; 向前添加\n    val list2 &#x3D; 11 +: list1\n    println(list2) &#x2F;&#x2F; List(11, 1, 2, 3, 10)\n\n\n    &#x2F;&#x2F; 合并列表\n    val l1 &#x3D; List(1)\n    val l2 &#x3D; List(2)\n    val l3 &#x3D; l1 ::: l2 &#x2F;&#x2F; 也可以使用l1 ++ l2\n    println(l3) &#x2F;&#x2F; List(1, 2)\n\n\n    &#x2F;&#x2F; 可变列表ListBuffer\n    val lb: ListBuffer[Int] &#x3D; ListBuffer[Int](1, 2, 3)\n    lb.append(4)\n    println(lb) &#x2F;&#x2F; ListBuffer(1, 2, 3, 4)\n    &#x2F;&#x2F;其他的不操作了。。。。。。，跟ArrayBuffer类似\n\n  &#125;\n&#125;\n\nSet不可变集合Set\npackage io.github.itlab1024.scala.chapter07\n\nobject Test05_ImmutableSet &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建Set\n    val s &#x3D; Set(1, 2)\n    &#x2F;&#x2F; 添加元素\n    val ns &#x3D; s + 3\n    println(ns) &#x2F;&#x2F; Set(1, 2, 3)\n  &#125;\n&#125;\n\n\n可变集合Set\npackage io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable\n\nobject Test06_MutableSet &#123;\n\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建可变set\n    val set &#x3D; mutable.Set(1, 2, 3)\n    &#x2F;&#x2F; 添加\n    set +&#x3D; 10\n    println(set) &#x2F;&#x2F;Set(1, 2, 3, 10)\n    &#x2F;&#x2F; 建议使用add方法\n    set.add(9)\n    println(set) &#x2F;&#x2F; Set(9, 1, 2, 3, 10)\n  &#125;\n&#125;\n\nMap可变Map\npackage io.github.itlab1024.scala.chapter07\n\nobject Test07_ImmutableMap &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建Map\n    val map: Map[Int, Int] &#x3D; Map[Int, Int]((1, 2), (3, 4)) &#x2F;&#x2F; 也可以使用-&gt;,比如1-&gt;2,3-&gt;4\n    println(map) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4)\n\n    &#x2F;&#x2F; 添加\n    val map1 &#x3D; map + (5 -&gt; 6)\n    println(map1) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4, 5 -&gt; 6)\n\n    &#x2F;&#x2F; 删除\n    val map2 &#x3D; map1 - 1\n    println(map2) &#x2F;&#x2F; Map(3 -&gt; 4, 5 -&gt; 6)\n\n    &#x2F;&#x2F; 通过key获取\n    val i &#x3D; map2(3)\n    println(i) &#x2F;&#x2F; 4, 如果key不存在会抛出异常\n\n    &#x2F;&#x2F; 循环\n    for((k, v) &lt;- map2) &#123;\n      println(s&quot;k&#x3D;$k, v&#x3D;$v&quot;)\n    &#125;\n\n\n  &#125;\n&#125;\n\n可变的Map\npackage io.github.itlab1024.scala.chapter07\n\nimport scala.collection.mutable\n\nobject Test08_MutableMap &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义可变的map\n    val map: mutable.Map[Int, Int] &#x3D; mutable.Map(1 -&gt; 2, 3 -&gt; 4)\n    &#x2F;&#x2F; 添加\n    map + (5 -&gt; 6)\n    println(map) &#x2F;&#x2F; Map(1 -&gt; 2, 3 -&gt; 4) 为啥没加进去，其实+这个函数就是为了不可变设计的。但是scala缺无法根据不同的map区分，其实list和set也是如此\n\n    &#x2F;&#x2F; 使用\n    map.put(5, 6)\n    println(map) &#x2F;&#x2F; Map(5 -&gt; 6, 1 -&gt; 2, 3 -&gt; 4)\n    \n    &#x2F;&#x2F; 懒了，其他的不试了，以后用的时候再积累吧\n  &#125;\n&#125;\n\n元组元组可以理解为一个容器，可以存放各种不同或者相同类型的数据。\npackage io.github.itlab1024.scala.chapter08\n\n&#x2F;**\n * 元组\n *&#x2F;\nobject Test01_Tuple &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 创建元组\n    val tuple1: (Int, String, Boolean) &#x3D; (1, &quot;a&quot;, true)\n    &#x2F;&#x2F; 获取元组元素，通过_index的方式\n    println(tuple1._1) &#x2F;&#x2F; 1\n    println(tuple1._2) &#x2F;&#x2F; a\n    println(tuple1._3) &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 遍历元组\n    for(e &lt;- tuple1.productIterator) &#123;\n      println(e)\n    &#125;\n  &#125;\n&#125;\n\n队列package io.github.itlab1024.scala.chapter08\n\nimport scala.collection.mutable\n\n&#x2F;**\n * scala中的队列\n *&#x2F;\nobject Test02_Queue &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; 定义队列\n    val queue: mutable.Queue[Int] &#x3D; mutable.Queue[Int]()\n    println(queue) &#x2F;&#x2F;Queue()\n\n    &#x2F;&#x2F; 入队\n    queue.enqueue(1)\n    println(queue) &#x2F;&#x2F; Queue(1)\n\n    &#x2F;&#x2F; 出队\n    val i &#x3D; queue.dequeue()\n    println(i) &#x2F;&#x2F; 1\n    println(queue) &#x2F;&#x2F;Queue()\n  &#125;\n&#125;\n\n模式匹配主要学习下样例类（case class）的匹配\npackage io.github.itlab1024.scala.chapter09\n\nobject Test01_PatternMatch &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    &#x2F;&#x2F; match默认是无法对普通类进行操作的，必须在类的伴生对象中实现自己的apply和unapply方法。scala中提供了样例类，这样的类默认就提供了这些方法\n    val t &#x3D; T(&quot;itlab1024&quot;)\n    t match &#123;\n      case T(&quot;1&quot;) &#x3D;&gt; println(&quot;匹配1&quot;)\n      case _ &#x3D;&gt;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 样例类\ncase class T(name: String) &#123;\n&#125;\n\n异常处理package io.github.itlab1024.scala.chapter10\n\nobject Test01_Exception &#123;\n  def main(args: Array[String]): Unit &#x3D; &#123;\n    try &#123;\n\n    &#125; catch &#123;\n      case e: NullPointerException &#x3D;&gt; println(&quot;空指针&quot;)\n      case ex: ClassNotFoundException &#x3D;&gt; println(&quot;类没没找到&quot;)\n    &#125; finally &#123;\n      &#x2F;&#x2F; 别忘了关闭流等操作。。。。\n    &#125;\n  &#125;\n&#125;\n\n泛型scala中的泛型比java稍微复杂点，会分为协变，逆变\nclass MyClass[+T] &#x2F;&#x2F; 协变\nclass MyClass[-T] &#x2F;&#x2F; 逆变\nclass MyClass[T]\t&#x2F;&#x2F; 不变\n\n协变：Son是Father的子类，则MyList[Son]也可以作为MyList[Father]的子类\n逆变：Son是Father的子类，则MyList[Son]作为MyList[Father]的父类\n不变：Son是Father的子类，则MyList[Son]和MyList[Father]没有关系\npackage io.github.itlab1024.scala.chapter11\n\nobject Test01_Generics &#123;\n  &#x2F;&#x2F; 协变和逆变\n  val l: MyList[Father] &#x3D; new MyList[Son] &#x2F;&#x2F; 这是不允许的，但是如果将MyList的泛型修改为+E则没有问题。\n  val n: MyList[Son] &#x3D; new MyList[Father] &#x2F;&#x2F; 这也是不允许的，，但是如果将MyList的泛型修改为-E则没有问题。\n&#125;\n\nclass Father &#123;\n\n&#125;\n\nclass Son extends Father &#123;\n\n&#125;\n\n&#x2F;&#x2F; 定义泛型的集合类型\nclass MyList[E] &#123; &#x2F;&#x2F; 此处现在是不变的泛型\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结，粗略的学习了下，感觉scala的设计有点复杂了，尤其里面各种方法，比如+=:,::,:::等，很难记。\n\n","slug":"scala2学习笔记（v2-12-11）","date":"2022-06-02T08:54:37.000Z","categories_index":"Scala","tags_index":"Scala2,2.12.11,BigData","author_index":"ITLab"},{"id":"ddc916691a7c6f09eafaf2d5a06c2348","title":"使用Kubeadm搭建Kubernetes集群（v1.22）","content":"版本说明\nv1.22\n准备三台机器\n使用Multipass（如何使用，请参考文章皮皮：使用Ubuntu Multipass创建虚拟机（方便快捷））创建三个vm。也就是三个节点node1， node2， node3\nmultipass launch -c 2 -m 2G -n node1\n\nmultipass launch -c 2 -m 2G -n node2\n\nmultipass launch -c 2 -m 2G -n node3\n\n\n\n系统设置、安装容器（本文使用Docker）、kubernetes工具（三个节点都需要执行）\n\n系统设置\n\ncat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;modules-load.d&#x2F;k8s.conf\nbr_netfilter\nEOF\n\ncat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf\nnet.bridge.bridge-nf-call-ip6tables &#x3D; 1\nnet.bridge.bridge-nf-call-iptables &#x3D; 1\nEOF\nsudo sysctl --system\n\n\n\n\ndocker安装\n\n根据官网文档进行安装，因为我我的vm是ubuntu，根据该连接进行安装：https://docs.docker.com/engine/install/ubuntu/\n\n如果安装过docker，使用下面的命令清理\n\nsudo apt-get remove docker docker-engine docker.io containerd runc\n \n \nsudo apt-get update\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n\n\ncurl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo gpg --dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg\n\n\necho \\\n  &quot;deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \\\n  $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null\n\n\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\n\n\n设置docker的cgroups systemd\n\nsudo mkdir &#x2F;etc&#x2F;docker\ncat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json\n&#123;\n  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],\n  &quot;log-driver&quot;: &quot;json-file&quot;,\n  &quot;log-opts&quot;: &#123;\n    &quot;max-size&quot;: &quot;100m&quot;\n  &#125;,\n  &quot;storage-driver&quot;: &quot;overlay2&quot;\n&#125;\nEOF\n\n\n\n\n重启docker并设置开机启动\n\nsudo systemctl enable docker\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n\n\n安装kubeadm\n\ncat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;modules-load.d&#x2F;k8s.conf\nbr_netfilter\nEOF\n\ncat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf\nnet.bridge.bridge-nf-call-ip6tables &#x3D; 1\nnet.bridge.bridge-nf-call-iptables &#x3D; 1\nEOF\nsudo sysctl --system\n\n\nsudo apt-get update\nsudo apt-get install -y apt-transport-https ca-certificates curl\n\n\nsudo curl -fsSLo &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg\n\n\necho &quot;deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg] https:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list\n\n\nsudo apt-get update\nsudo apt-get install -y kubelet kubeadm kubectl\nsudo apt-mark hold kubelet kubeadm kubectl\n\n\n\n以上操作各个节点都需要操作\n使用kubeadm指令初始化（master节点：node1）\nubuntu@node1:~$ sudo kubeadm init --pod-network-cidr&#x3D;10.244.0.0&#x2F;16\n[init] Using Kubernetes version: v1.22.2\n[preflight] Running pre-flight checks\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[preflight] This might take a minute or two, depending on the speed of your internet connection\n[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;\n[certs] Using certificateDir folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;pki&quot;\n[certs] Generating &quot;ca&quot; certificate and key\n[certs] Generating &quot;apiserver&quot; certificate and key\n[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local node1] and IPs [10.96.0.1 172.16.241.11]\n[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key\n[certs] Generating &quot;front-proxy-ca&quot; certificate and key\n[certs] Generating &quot;front-proxy-client&quot; certificate and key\n[certs] Generating &quot;etcd&#x2F;ca&quot; certificate and key\n[certs] Generating &quot;etcd&#x2F;server&quot; certificate and key\n[certs] etcd&#x2F;server serving cert is signed for DNS names [localhost node1] and IPs [172.16.241.11 127.0.0.1 ::1]\n[certs] Generating &quot;etcd&#x2F;peer&quot; certificate and key\n[certs] etcd&#x2F;peer serving cert is signed for DNS names [localhost node1] and IPs [172.16.241.11 127.0.0.1 ::1]\n[certs] Generating &quot;etcd&#x2F;healthcheck-client&quot; certificate and key\n[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key\n[certs] Generating &quot;sa&quot; key and public key\n[kubeconfig] Using kubeconfig folder &quot;&#x2F;etc&#x2F;kubernetes&quot;\n[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file\n[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;\n[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;\n[kubelet-start] Starting the kubelet\n[control-plane] Using manifest folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;\n[etcd] Creating static Pod manifest for local etcd in &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;. This can take up to 4m0s\n[kubelet-check] Initial timeout of 40s passed.\n[apiclient] All control plane components are healthy after 58.570622 seconds\n[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace\n[kubelet] Creating a ConfigMap &quot;kubelet-config-1.22&quot; in namespace kube-system with the configuration for the kubelets in the cluster\n[upload-certs] Skipping phase. Please see --upload-certs\n[mark-control-plane] Marking the node node1 as control-plane by adding the labels: [node-role.kubernetes.io&#x2F;master(deprecated) node-role.kubernetes.io&#x2F;control-plane node.kubernetes.io&#x2F;exclude-from-external-load-balancers]\n[mark-control-plane] Marking the node node1 as control-plane by adding the taints [node-role.kubernetes.io&#x2F;master:NoSchedule]\n[bootstrap-token] Using token: uyydwy.xlbh5ta1wdfecxjw\n[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles\n[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes\n[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials\n[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token\n[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster\n[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace\n[kubelet-finalize] Updating &quot;&#x2F;etc&#x2F;kubernetes&#x2F;kubelet.conf&quot; to point to a rotatable kubelet client certificate and key\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nAlternatively, if you are the root user, you can run:\n\n  export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\n  https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 172.16.241.11:6443 --token uyydwy.xlbh5ta1wdfecxjw \\\n    --discovery-token-ca-cert-hash sha256:5b3d416064c712ed79ecfc2f65ccc9f7cef745321ae03eb154e1ef880f3212a7\n\n\n\n\n配置\n\n按照上面的日志记录配置：\n如果非root用户执行\nmkdir -p $HOME&#x2F;.kube\nsudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\nsudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\n\n\n如果是root用户执行\nshell export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf\n\n\n\n\n验证主节点是否成功（加到环境变量中，否则机器重启后失败。）\n\nexport KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf\n\n\n\n\n正确返回，说明节点初始化成功。\n将从节点加入到集群（node2，node3 执行）\nsudo kubeadm join 172.16.241.11:6443 --token uyydwy.xlbh5ta1wdfecxjw --discovery-token-ca-cert-hash sha256:5b3d416064c712ed79ecfc2f65ccc9f7cef745321ae03eb154e1ef880f3212a7\n\n\n\n如果上面的token忘记了执行：\nkubeadm token list\n\n\n\n如果token-ca-cert-bash忘记了执行：\nopenssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;\n\n\n\n回到master(node1):\n执行kubectl get nodes\n\n可以看到node2节点已经加入集群。\n同理操作node3节点。\n\n配置网络\n网络有很多种，本人使用的是flannel\nkubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n\n\n\n查看节点：\n\n节点状态都变成了Ready\n部署应用（官方示例）\n\n发布应用\n\nkubectl create deployment kubernetes-bootcamp --image&#x3D;gcr.io&#x2F;google-samples&#x2F;kubernetes-bootcamp:v1\n\n\n\n查看是否发布成功（下载镜像有点满，而且还需要科学上网哟）\n\n\n浏览应用\n\n此时应用pod在一个私有的、隔离的网络上，无法外部访问。可以使用kubectl proxy 代理访问。\n\n开放应用程序\n\n使用serivce开发应用：\nkubectl expose deployment&#x2F;kubernetes-bootcamp --type&#x3D;&quot;ClusterIP&quot; --port 8080\n\n\n\n查询serivce\nkubectl get services\n\n\n\n\n查看下service的具体描述信息\n\n访问应用\n\n\n扩展应用\n\n查看pod数量\nkubectl get deployments\n\n\n\n\n查看副本：\n\n扩展到4个：\nkubectl scale deployments&#x2F;kubernetes-bootcamp --replicas&#x3D;4\n\n\n\n\n查看pod数量：\n\n我们能看到有些容器还在创建。\n查看这些pod都在哪些节点上\nkubectl get pods -o wide\n\n\n\n\n\n滚动更新应用\n\n上面使用的镜像是v1版本，接下来升级到v2版本\nkubectl set image deployments&#x2F;kubernetes-bootcamp kubernetes-bootcamp&#x3D;jocatalin&#x2F;kubernetes-bootcamp:v2\n\n\n\n\n访问：\n\n回滚操作\n当我们升级失败，或者升级版本有代码问题时，我们需要回滚到上一版本。\nkubectl rollout undo deployments&#x2F;kubernetes-bootcamp\n\n\n\n重新访问应用：\n\n我们看到版本已经回退到了v1。\nkubernetes集群搭建就完成了，本文只是基本使用。我也在初学中。kubernetes的知识还是挺多的。感觉学不动了 。分享给大家。\n\n梦想越是美丽，就越是显得遥不可及。可奇怪的是，一旦你下定了决心，很快地，那些梦想就一一成为了现实！\n","slug":"使用Kubeadm搭建Kubernetes集群（v1-22）","date":"2022-05-02T03:18:25.000Z","categories_index":"Kubernetes","tags_index":"Kubernetes,Container","author_index":"ITLab"},{"id":"ba590f4c595f20e0726c162dbce4dd2d","title":"ubuntu-multipass","content":"什么是Maultipass？\n官方说明：\nUbuntu VMs on demand for any workstation\nGet an instant Ubuntu VM with a single command. Multipass can launch and run virtual machines and configure them with cloud-init like a public cloud. Prototype your cloud launches locally for free.\n\n就是创建Ubuntu系统的虚拟机。\n\n\n\n\n\n\n\n\n\n以前搭建Kafka、zookeeper集群的时候，总是会用visual box ，fusion(mac)等虚拟机技术。\n1、下载镜像\n2、创建虚拟机，选择镜像、设置系统属性\n3、完成搭建\n很巧地，前几天看到了装了个Ubuntu、Windows双系统。看到了Ubuntu界面，感觉比以前使用Ubuntu的时候漂亮了挺多。于是打开了Ubuntu的官网。https://ubuntu.com/, 无意间看到了multipass工具。于是尝试了下。觉得特别好用。对于那些不想花钱购买机器、又想有自己的多个linux系统的朋友，multipass很好用。而且关键的一点是用起来特别方便。\n接下来我就把我使用multipass的操作记录下来。分享给大家。\n\n\n\n\n\n\n\n\n\n安装multipass\n打开https://multipass.run/\nmultipass支持linux、windows、mac平台使用。\n\n本人再次使用mac版本\n安装有两种方式：\n\n下载pkg包进行安装。\n\n\n\n使用brew命令安装\n\nbrew install --cask multipass\n\n\n\n\n验证安装是否成功\n执行multipass\n显示如下界面即代表成功\n\n完整日志如下：\nUsage: multipass [options] &lt;command&gt;\nCreate, control and connect to Ubuntu instances.\n\nThis is a command line utility for multipass, a\nservice that manages Ubuntu instances.\n\nOptions:\n  -h, --help     Displays help on commandline options.\n  --help-all     Displays help including Qt specific options.\n  -v, --verbose  Increase logging verbosity. Repeat the &#39;v&#39; in the short option\n                 for more detail. Maximum verbosity is obtained with 4 (or more)\n                 v&#39;s, i.e. -vvvv.\n\nAvailable commands:\n  delete    Delete instances\n  exec      Run a command on an instance\n  find      Display available images to create instances from\n  get       Get a configuration setting\n  help      Display help about a command\n  info      Display information about instances\n  launch    Create and start an Ubuntu instance\n  list      List all available instances\n  mount     Mount a local directory in the instance\n  networks  List available network interfaces\n  purge     Purge all deleted instances permanently\n  recover   Recover deleted instances\n  restart   Restart instances\n  set       Set a configuration setting\n  shell     Open a shell on a running instance\n  start     Start instances\n  stop      Stop running instances\n  suspend   Suspend running instances\n  transfer  Transfer files between the host and instances\n  umount    Unmount a directory from an instance\n  version   Show version details\n\n列出了所有的命令已经命令的含义。\n\n\n\n\n\n\n\n\n\n创建虚拟机\nmultipass launch -n vm1\n\nlaunch可选择参数可使用multipass launch -h查看。\n这里介绍几个主要参数：\n-n：指定虚拟机名称\n-c：指定cpu核数\n-m：指定内存大小\n-d：指定硬盘大小\n执行结果：\n\n\n进入虚拟机\nmultipass shell vm1\n\n也可以使用exec指令。\n\n\n关闭虚拟机\n\n\n启动虚拟机\n\n\n删除虚拟机\n\n\n清楚删除的虚拟机\n删除虚拟机后，重新使用一样的名字创建vm，是不成功的。\n\n这时候需要清理删除的虚拟机后才能成功。\n\n\n\n\n\n\n\n\n\n\n\n\n至此，multipass基本使用介绍完成。\n本人使用该方式搭建各种集群。例如redis、kafka、zookeeper、kubernetes等。方便快捷！\n\n梦想越是美丽，就越是显得遥不可及。可奇怪的是，一旦你下定了决心，很快地，那些梦想就一一成为了现实！","slug":"ubuntu-multipass","date":"2022-04-24T08:42:43.000Z","categories_index":"ubuntu,multipass,虚拟机","tags_index":"multipass,ubuntu","author_index":"ITLab"},{"id":"40ea842bde81b9af210ab16629bae6dd","title":"Spring-Secutity-Oauth2实现Auth Server(旧版)","content":"\n\n\n\n\n\n\n\n\n前言\nOauth2授权是项目中使用很多的协议，在三方授权中有这很大的应用。\n\nspring 官方宣布在spring-security5以后删除掉Authorization Server相关功能，官方推荐使用第三方oauth2服务器，例如keycloak。作为spring的忠实舔狗，我跟很多开发者一样对spring的这个宣布不能认同，spring 迫于对广大开发者强烈不满和迫切需求，觉得另开一个项目（Spring Authorization Server）. 时间过去很久了。社区一直在开发中。\n\n在开发过程中社区将jar包上传到maven central，例如0.1.0-0.1.2版本，但是都未明文说明可以使用到生产环境。\n\n近期spring 官方发布了几个通知：\n\n\n2021年8月17日，通知：Spring Authorization Server迁移到spring projects\n  \n\n2021年8月19日，通知Spring Authorization Server 生产环境可用。（其实这几天官方的通知有变化，比如先发的文档，上面未写maven central上的jar地址。也可以理解，事情要一步一步做的嘛😁）\n\n看到该通知后，想尝试下。于是进入仓库地址（https://github.com/spring-projects/spring-authorization-server），未发现有使用文档，只有源码和使用示例。\n因此有些抵触，没有文档使用难度较大，无法深入理解开发者思想。所以想再等等。\n\n此时想起以前的oauth2实现方案，想做个复习，所以想写个demo。记录下来。也给其他学者一个参考。因此写下此demo。\n\n之后我会使用Spring Authorization Server 依赖，再次实现跟本demo一样的例子，敬请关注。\n\n\n\n什么是Oauth2.0\n本文不作赘述，网上文章较多。推荐几个，https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html， https://oauth.net/2/ 。https://zhuanlan.zhihu.com/p/84670338。\n\n\n使用Spring Security和Spring Security Oauth2依赖实现\n\n说明\nspring Boot： 2.3.4.RELEASE\nspring-Security-oauth2：2.5.1.RELEASE\njdk: 1.8\n开发工具: IDEA\n包管理工具：MAVEN\n\n项目结构\nauthorization-server \t\t\t\t\t\t&#x2F;&#x2F;授权服务器module根目录\n├── README.md\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 说明文档\t\t\t\t\n├── authorization-server.iml\t\t&#x2F;&#x2F; idea系统文件（忽略）\n├── pom.xml\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; maven依赖（注意父级依赖）\n└── src\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 源码路径\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── xpp\n    │   │           └── sslt5\n    │   │               └── as\n    │   │                   ├── AuthorizationServerApplication.java &#x2F;&#x2F; 启动类\n    │   │                   ├── config\n    │   │                   │   ├── AuthorizationServerConfig.java  &#x2F;&#x2F; 授权服务器配置类\n    │   │                   │   └── SecurityConfig.java\t\t\t\t\t\t\t&#x2F;&#x2F;security安全配置\n    │   │                   ├── entity\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    │   │                   │   └── Account.java\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;用户实体类\t\t\t\t\t\t\t\n    │   │                   ├── repository\n    │   │                   │   └── UserRepository.java\t\t\t\t\t\t\t&#x2F;&#x2F; 账户Dao\n    │   │                   └── svc\n    │   │                       └── UserDetailSvc.java\t\t\t\t\t\t\t&#x2F;&#x2F; security user Details类\n    │   └── resources\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 源文件目录\n    │       ├── application.yml\t\t\t\t\t\t\t&#x2F;&#x2F; spring boot 配置文件\n    │       ├── oauth2-data.sql\t\t\t\t&#x2F;&#x2F; 初始化oauth2数据sql\n    │       ├── import.sql\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; jpa初始化Account表语句\n    │       └── oauth2-schema.sql\t\t\t&#x2F;&#x2F; 初始化创建oauth2相关表语句\n    └── test\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 测试源码路径\n        └── java\n\nMaven依赖：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;spring-security-lt5-oauth2&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.xpp&lt;&#x2F;groupId&gt;\n        &lt;version&gt;0.0.1&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;authorization-server&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1&lt;&#x2F;version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-security-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.security.oauth&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-security-oauth2&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.5.1.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n          &lt;groupId&gt;com.h2database&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;h2&lt;&#x2F;artifactId&gt;\n          &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nSecurity config类\npackage com.xpp.sslt5.as.config;\n\nimport com.xpp.sslt5.as.svc.UserDetailSvc;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Bean\n    public PasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Autowired\n    private UserDetailSvc userDetailSvc;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(userDetailSvc).passwordEncoder(passwordEncoder());\n    &#125;\n\n\n    &#x2F;&#x2F; AuthenticationManager 对象在 OAuth2 认证服务中要使用，提前放入 IOC 容器中\n   \t&#x2F;&#x2F; 必须使用@Bean注入IOC容器中，否则password grant_type无效。\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n\n\n\n\nAuthorization Server Config 配置类\npackage com.xpp.sslt5.as.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;\nimport org.springframework.security.oauth2.provider.ClientDetailsService;\nimport org.springframework.security.oauth2.provider.approval.ApprovalStore;\nimport org.springframework.security.oauth2.provider.approval.JdbcApprovalStore;\nimport org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;\nimport org.springframework.security.oauth2.provider.code.AuthorizationCodeServices;\nimport org.springframework.security.oauth2.provider.code.JdbcAuthorizationCodeServices;\nimport org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;\nimport org.springframework.security.oauth2.provider.token.DefaultTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;\n    &#x2F;&#x2F; 数据库连接池对象，SpringBoot 配置完成后自动注入\n    @Autowired\n    private DataSource dataSource;\n\n    &#x2F;&#x2F; 授权模式专用对象，在 Security 配置中注入容器\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    &#x2F;&#x2F; 客户端信息来源\n    @Bean\n    public ClientDetailsService jdbcClientDetailsService() &#123;\n        return new JdbcClientDetailsService(dataSource);\n    &#125;\n\n    &#x2F;&#x2F; token 保存策略，指你生成的 Token 要往哪里存储\n    &#x2F;&#x2F;JdbcTokenStore ， InMemoryTokenStore， JwkTokenStore，JwtTokenStore, RedisTokenStore\n    @Bean\n    public TokenStore tokenStore() &#123;\n        return new JdbcTokenStore(dataSource);\n    &#125;\n\n    &#x2F;&#x2F; 指定客户端信息的数据库来源\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;\n        clients.withClientDetails(jdbcClientDetailsService());\n    &#125;\n\n\n    &#x2F;&#x2F; 授权信息保存策略\n    @Bean\n    public ApprovalStore approvalStore() &#123;\n        return new JdbcApprovalStore(dataSource);\n    &#125;\n\n    &#x2F;&#x2F; 授权码模式数据来源\n    @Bean\n    public AuthorizationCodeServices authorizationCodeServices() &#123;\n        return new JdbcAuthorizationCodeServices(dataSource);\n    &#125;\n\n\n    &#x2F;&#x2F; 令牌管理\n    @Bean\n    public AuthorizationServerTokenServices tokenServices() &#123;\n        DefaultTokenServices tokenServices &#x3D; new DefaultTokenServices();\n        &#x2F;&#x2F; token 保存策略\n        tokenServices.setTokenStore(tokenStore());\n        &#x2F;&#x2F; 支持刷新模式\n        tokenServices.setSupportRefreshToken(true);\n        &#x2F;&#x2F; 客户端信息来源\n        tokenServices.setClientDetailsService(jdbcClientDetailsService());\n        &#x2F;&#x2F; token 有效期自定义设置，默认 12 小时\n        tokenServices.setAccessTokenValiditySeconds(60 * 60 * 12);\n        &#x2F;&#x2F; refresh token 有效期自定义设置，默认 30 天\n        tokenServices.setRefreshTokenValiditySeconds(60 * 60 * 24 * 7);\n\n        return tokenServices;\n    &#125;\n\n    &#x2F;&#x2F; 检查 token 的策略，即配置令牌端点的安全约束\n    &#x2F;&#x2F; 就是这个端点谁能访问，谁不能访问\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer security) &#123;\n        &#x2F;&#x2F; 此时指 endpoint 完全公开\n        security.tokenKeyAccess(&quot;permitAll()&quot;);\n        &#x2F;&#x2F; checkToken 这个 endpoint 完全公开\n        security.checkTokenAccess(&quot;permitAll()&quot;);\n        &#x2F;&#x2F; 是否允许表单认证\n        security.allowFormAuthenticationForClients();\n\n    &#125;\n\n    &#x2F;&#x2F; OAuth2 的主配置信息\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;\n        endpoints\n                .approvalStore(approvalStore())\n                .authenticationManager(authenticationManager)\n                .authorizationCodeServices(authorizationCodeServices())\n                .tokenServices(tokenServices());\n    &#125;\n&#125;\n\n\nUserDetailSvc类\npackage com.xpp.sslt5.as.svc;\n\nimport com.xpp.sslt5.as.entity.Account;\nimport com.xpp.sslt5.as.repository.AccountRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.stereotype.Component;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@Component\npublic class UserDetailSvc implements UserDetailsService &#123;\n    @Autowired\n    private AccountRepository userRepository;\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        List&lt;GrantedAuthority&gt; grantedAuths &#x3D; new ArrayList&lt;&gt;();\n        Account account &#x3D; userRepository.findByUsername(s);\n        if (Objects.isNull(account)) &#123;\n            throw new UsernameNotFoundException(&quot;No user found with username: &quot; + s);\n        &#125;\n        Arrays.stream(account.getRoleIdentifies().split(&quot;,&quot;)).collect(Collectors.toSet())\n                .forEach(x-&gt; grantedAuths.add(new SimpleGrantedAuthority(x)));\n        return new User(account.getUsername(), account.getPassword(), grantedAuths);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        System.out.println(new BCryptPasswordEncoder().encode(&quot;xpp&quot;));\n    &#125;\n&#125;\n\n以上只是简单的累出来重要文件，其他配置文件请自行去github上查看。\n\n\n\n测试（重点）\n\n授权码模式\n启动项目后，打开浏览器输入：\nhttp://localhost:8080/oauth/authorize?response_type=code&amp;client_id=xpp\n出现如下界面：\n\n出现上述界面后，输入用户名密码(a1,a2,a3皆可，密码都是xpp):\n\n按照上图点击，Authorize按钮。\n因为我配置的redirect_uri是百度，如图：\n\n我们看到百度后面跟了个code，复制这个code值，打开postman获取token：\n注意client和secret的授权\n\n传递参数界面：\n\n发送请求返回的界面：\n\n测试刷新token：\n\n我们看到access_token跟之前获取的变化了，refresh_token未变化。\n\n简化模式\n访问简化模式地址：http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=xpp\n输入用户名密码（同一个client下的用户如果授权过不会出现登录界面），输入密码登录后, 点击授权和authorize按钮，浏览器自动跳转到百度，地址来为：https://www.baidu.com/#access_token=Pfa4YiIoN3Z1C2e1q-GV_E023C4&amp;token_type=bearer&amp;expires_in=43199&amp;scope=read\n我们看到省去了请求oauth&#x2F;token，直接在回调地址中看到了access_token. 这就是简化模式。\n\n密码模式\n\n\n刷新token此处不再举例测试。\n\n客户端模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n以上就讲oauth2的功能基本完成，对于inmemory和redis的方式没有举例。\n这里还有两个问题，第一个：获取的token如何使用，也就是authorization client和 resource server，后期慢慢补充。\n第二个：登录用户和client维护应该通过接口提供创建更新等方位方式。后期慢慢补充。\n\n\n\n\n\n\n\n\n\n本文使用的事spring-security-oauth2实现，在spring security 5以后已经弃用，后续会单独使用security实现。敬请期待，期待您的关注。期待您的意见。\n\n\n\n\n\n\n\n\n\n源码地址：https://github.com/ITLab1024/spring-security-lt5-oauth2\n","slug":"Spring-Secutity-Oauth2-Demo","date":"2022-04-23T13:35:50.000Z","categories_index":"Java,Spring Security,Spring-Secutiry-Oauth2","tags_index":"Spring Security Oauth2","author_index":"ITLab"},{"id":"c6e4902349bc052e9c4272ae807ca5e6","title":"kubernetes-黑马程序员","content":"Kubernetes\n1. Kubernetes介绍1.1 应用部署方式演变在部署应用程序的方式上，主要经历了三个时代：\n\n传统部署：互联网早期，会直接将应用程序部署在物理机上\n\n\n\n\n\n\n\n\n\n优点：简单，不需要其它技术的参与\n缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响\n\n虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境\n\n\n\n\n\n\n\n\n\n优点：程序环境不会相互产生影响，提供了一定程度的安全性\n缺点：增加了操作系统，浪费了部分资源\n\n容器化部署：与虚拟化类似，但是共享了操作系统\n\n\n\n\n\n\n\n\n\n优点：\n可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等\n运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦\n容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署\n\n\n\n容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：\n\n一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器\n当并发访问量变大的时候，怎么样做到横向扩展容器数量\n\n这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：\n\nSwarm：Docker自己的容器编排工具\nMesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用\nKubernetes：Google开源的的容器编排工具\n\n\n1.2 kubernetes简介\nkubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。\nkubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：\n\n自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器\n弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整\n服务发现：服务可以通过自动发现的形式找到它所依赖的服务\n负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡\n版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本\n存储编排：可以根据容器自身的需求自动创建存储卷\n\n1.3 kubernetes组件一个kubernetes集群主要是由**控制节点(master)、工作节点(node)**构成，每个节点上都会安装不同的组件。\nmaster：集群的控制平面，负责集群的决策 ( 管理 )\n\n\n\n\n\n\n\n\n\nApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制\nScheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上\nControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等\nEtcd ：负责存储集群中各种资源对象的信息\nnode：集群的数据平面，负责为容器提供运行环境 ( 干活 )\n\n\n\n\n\n\n\n\n\nKubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器\nKubeProxy : 负责提供集群内部的服务发现和负载均衡\nDocker : 负责节点上容器的各种操作\n\n下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：\n\n首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中\n\n一个nginx服务的安装请求会首先被发送到master节点的apiServer组件\n\napiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上\n在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer\n\napiServer调用controller-manager去调度Node节点安装nginx服务\n\nkubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod\npod是kubernetes的最小操作单元，容器必须跑在pod中至此，\n\n一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理\n\n\n这样，外界用户就可以访问集群中的nginx服务了\n1.4 kubernetes概念Master：集群控制节点，每个集群需要至少一个master节点负责集群的管控\nNode：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行\nPod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器\nController：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等\nService：pod对外服务的统一入口，下面可以维护者同一类的多个pod\nLabel：标签，用于对pod进行分类，同一类pod会拥有相同的标签\nNameSpace：命名空间，用来隔离pod的运行环境\n2. kubernetes集群环境搭建2.1 前置知识点目前生产部署Kubernetes 集群主要有两种方式：\nkubeadm\nKubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。\n官方地址：https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/\n二进制包\n从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。\nKubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。\n\n2.2 kubeadm 部署方式介绍kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：\n\n创建一个Master 节点kubeadm init\n将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;\n\n2.3 安装要求在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：\n\n一台或多台机器，操作系统CentOS7.x-86_x64\n硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多\n集群中所有机器之间网络互通\n可以访问外网，需要拉取镜像\n禁止swap 分区\n\n2.4 最终目标\n在所有节点上安装Docker 和kubeadm\n部署Kubernetes Master\n部署容器网络插件\n部署Kubernetes Node，将节点加入Kubernetes 集群中\n部署Dashboard Web 页面，可视化查看Kubernetes 资源\n\n2.5 准备环境\n\n\n\n角色\nIP地址\n组件\n\n\n\nk8s-master01\n192.168.5.3\ndocker，kubectl，kubeadm，kubelet\n\n\nk8s-node01\n192.168.5.4\ndocker，kubectl，kubeadm，kubelet\n\n\nk8s-node02\n192.168.5.5\ndocker，kubectl，kubeadm，kubelet\n\n\n2.6 系统初始化2.6.1 设置系统主机名以及 Host 文件的相互解析hostnamectl set-hostname k8s-master01 &amp;&amp; bash\nhostnamectl set-hostname k8s-node01 &amp;&amp; bash\nhostnamectl set-hostname k8s-node02 &amp;&amp; bash\n\ncat &lt;&lt;EOF&gt;&gt; &#x2F;etc&#x2F;hosts\n192.168.5.3     k8s-master01\n192.168.5.4     k8s-node01\n192.168.5.5     k8s-node02\nEOF\n\nscp &#x2F;etc&#x2F;hosts root@192.168.5.4:&#x2F;etc&#x2F;hosts \nscp &#x2F;etc&#x2F;hosts root@192.168.5.5:&#x2F;etc&#x2F;hosts \n\n2.6.2 安装依赖文件（所有节点都要操作）yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git\n\n2.6.3 设置防火墙为 Iptables 并设置空规则（所有节点都要操作）systemctl stop firewalld &amp;&amp; systemctl disable firewalld\n\nyum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save\n\n2.6.4 关闭 SELINUX（所有节点都要操作）swapoff -a &amp;&amp; sed -i &#39;&#x2F; swap &#x2F; s&#x2F;^\\(.*\\)$&#x2F;#\\1&#x2F;g&#39; &#x2F;etc&#x2F;fstab\n\nsetenforce 0 &amp;&amp; sed -i &#39;s&#x2F;^SELINUX&#x3D;.*&#x2F;SELINUX&#x3D;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config\n\n2.6.5 调整内核参数，对于 K8S（所有节点都要操作）modprobe br_netfilter\n\ncat &lt;&lt;EOF&gt; kubernetes.conf \nnet.bridge.bridge-nf-call-iptables&#x3D;1\nnet.bridge.bridge-nf-call-ip6tables&#x3D;1\nnet.ipv4.ip_forward&#x3D;1\nnet.ipv4.tcp_tw_recycle&#x3D;0\nvm.swappiness&#x3D;0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它\nvm.overcommit_memory&#x3D;1 # 不检查物理内存是否够用\nvm.panic_on_oom&#x3D;0 # 开启 OOM\nfs.inotify.max_user_instances&#x3D;8192\nfs.inotify.max_user_watches&#x3D;1048576\nfs.file-max&#x3D;52706963\nfs.nr_open&#x3D;52706963\nnet.ipv6.conf.all.disable_ipv6&#x3D;1\nnet.netfilter.nf_conntrack_max&#x3D;2310720\nEOF\n\ncp kubernetes.conf &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf\n\nsysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf\n\n2.6.6 调整系统时区（所有节点都要操作）# 设置系统时区为 中国&#x2F;上海\ntimedatectl set-timezone Asia&#x2F;Shanghai\n# 将当前的 UTC 时间写入硬件时钟\ntimedatectl set-local-rtc 0\n# 重启依赖于系统时间的服务\nsystemctl restart rsyslog\nsystemctl restart crond\n\n2.6.7 设置 rsyslogd 和 systemd journald（所有节点都要操作）# 持久化保存日志的目录\nmkdir &#x2F;var&#x2F;log&#x2F;journal \nmkdir &#x2F;etc&#x2F;systemd&#x2F;journald.conf.d\ncat &gt; &#x2F;etc&#x2F;systemd&#x2F;journald.conf.d&#x2F;99-prophet.conf &lt;&lt;EOF\n[Journal]\n# 持久化保存到磁盘\nStorage&#x3D;persistent\n\n# 压缩历史日志\nCompress&#x3D;yes\n\nSyncIntervalSec&#x3D;5m\nRateLimitInterval&#x3D;30s\nRateLimitBurst&#x3D;1000\n\n# 最大占用空间 10G\nSystemMaxUse&#x3D;10G\n\n# 单日志文件最大 200M\nSystemMaxFileSize&#x3D;200M\n\n# 日志保存时间 2 周\nMaxRetentionSec&#x3D;2week\n\n# 不将日志转发到 syslog\nForwardToSyslog&#x3D;no\nEOF\n\nsystemctl restart systemd-journald\n\n2.6.8 kube-proxy开启ipvs的前置条件（所有节点都要操作）cat &lt;&lt;EOF&gt; &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules \n#!&#x2F;bin&#x2F;bash\nmodprobe -- ip_vs\nmodprobe -- ip_vs_rr\nmodprobe -- ip_vs_wrr\nmodprobe -- ip_vs_sh\nmodprobe -- nf_conntrack_ipv4\nEOF\n\nchmod 755 &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &amp;&amp; bash &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4\n\n2.6.9 安装 Docker 软件（所有节点都要操作）yum install -y yum-utils device-mapper-persistent-data lvm2\n\nyum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\nyum install -y docker-ce\n\n## 创建 &#x2F;etc&#x2F;docker 目录\nmkdir &#x2F;etc&#x2F;docker\n\ncat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF\n&#123;\n&quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],\n&quot;log-driver&quot;: &quot;json-file&quot;,\n&quot;log-opts&quot;: &#123;\n&quot;max-size&quot;: &quot;100m&quot;\n&#125;\n&#125;\nEOF\nmkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d\n# 重启docker服务\nsystemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker\n上传文件到/etc/yum.repos.d/目录下，也可以 代替 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 命令\ndocker-ce.repo\n[docker-ce-stable]\nname&#x3D;Docker CE Stable - $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;stable\nenabled&#x3D;1\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-stable-debuginfo]\nname&#x3D;Docker CE Stable - Debuginfo $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;debug-$basearch&#x2F;stable\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-stable-source]\nname&#x3D;Docker CE Stable - Sources\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;source&#x2F;stable\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-test]\nname&#x3D;Docker CE Test - $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;test\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-test-debuginfo]\nname&#x3D;Docker CE Test - Debuginfo $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;debug-$basearch&#x2F;test\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-test-source]\nname&#x3D;Docker CE Test - Sources\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;source&#x2F;test\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-nightly]\nname&#x3D;Docker CE Nightly - $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;nightly\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-nightly-debuginfo]\nname&#x3D;Docker CE Nightly - Debuginfo $basearch\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;debug-$basearch&#x2F;nightly\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n[docker-ce-nightly-source]\nname&#x3D;Docker CE Nightly - Sources\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;$releasever&#x2F;source&#x2F;nightly\nenabled&#x3D;0\ngpgcheck&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg\n\n2.6.10 安装 Kubeadm （所有节点都要操作）cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo\n[kubernetes]\nname&#x3D;Kubernetes\nbaseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64\nenabled&#x3D;1\ngpgcheck&#x3D;0\nrepo_gpgcheck&#x3D;0\ngpgkey&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg\nhttp:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg\nEOF\n\nyum install -y kubelet kubeadm kubectl &amp;&amp; systemctl enable kubelet\n\n2.7 部署Kubernetes Master2.7.1 初始化主节点（主节点操作）kubeadm init --apiserver-advertise-address&#x3D;192.168.5.3 --image-repository registry.aliyuncs.com&#x2F;google_containers --kubernetes-version v1.21.1 --service-cidr&#x3D;10.96.0.0&#x2F;12 --pod-network-cidr&#x3D;10.244.0.0&#x2F;16\n\nmkdir -p $HOME&#x2F;.kube\n\nsudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n\nsudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\n2.7.2 加入主节点以及其余工作节点kubeadm join 192.168.5.3:6443 --token h0uelc.l46qp29nxscke7f7 \\\n        --discovery-token-ca-cert-hash sha256:abc807778e24bff73362ceeb783cc7f6feec96f20b4fd707c3f8e8312294e28f \n\n2.7.3 部署网络kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n\n下边是文件\n---\napiVersion: policy&#x2F;v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: psp.flannel.unprivileged\n  annotations:\n    seccomp.security.alpha.kubernetes.io&#x2F;allowedProfileNames: docker&#x2F;default\n    seccomp.security.alpha.kubernetes.io&#x2F;defaultProfileName: docker&#x2F;default\n    apparmor.security.beta.kubernetes.io&#x2F;allowedProfileNames: runtime&#x2F;default\n    apparmor.security.beta.kubernetes.io&#x2F;defaultProfileName: runtime&#x2F;default\nspec:\n  privileged: false\n  volumes:\n  - configMap\n  - secret\n  - emptyDir\n  - hostPath\n  allowedHostPaths:\n  - pathPrefix: &quot;&#x2F;etc&#x2F;cni&#x2F;net.d&quot;\n  - pathPrefix: &quot;&#x2F;etc&#x2F;kube-flannel&quot;\n  - pathPrefix: &quot;&#x2F;run&#x2F;flannel&quot;\n  readOnlyRootFilesystem: false\n  # Users and groups\n  runAsUser:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  # Privilege Escalation\n  allowPrivilegeEscalation: false\n  defaultAllowPrivilegeEscalation: false\n  # Capabilities\n  allowedCapabilities: [&#39;NET_ADMIN&#39;, &#39;NET_RAW&#39;]\n  defaultAddCapabilities: []\n  requiredDropCapabilities: []\n  # Host namespaces\n  hostPID: false\n  hostIPC: false\n  hostNetwork: true\n  hostPorts:\n  - min: 0\n    max: 65535\n  # SELinux\n  seLinux:\n    # SELinux is unused in CaaSP\n    rule: &#39;RunAsAny&#39;\n---\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io&#x2F;v1\nmetadata:\n  name: flannel\nrules:\n- apiGroups: [&#39;extensions&#39;]\n  resources: [&#39;podsecuritypolicies&#39;]\n  verbs: [&#39;use&#39;]\n  resourceNames: [&#39;psp.flannel.unprivileged&#39;]\n- apiGroups:\n  - &quot;&quot;\n  resources:\n  - pods\n  verbs:\n  - get\n- apiGroups:\n  - &quot;&quot;\n  resources:\n  - nodes\n  verbs:\n  - list\n  - watch\n- apiGroups:\n  - &quot;&quot;\n  resources:\n  - nodes&#x2F;status\n  verbs:\n  - patch\n---\nkind: ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io&#x2F;v1\nmetadata:\n  name: flannel\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: flannel\nsubjects:\n- kind: ServiceAccount\n  name: flannel\n  namespace: kube-system\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: flannel\n  namespace: kube-system\n---\nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: kube-flannel-cfg\n  namespace: kube-system\n  labels:\n    tier: node\n    app: flannel\ndata:\n  cni-conf.json: |\n    &#123;\n      &quot;name&quot;: &quot;cbr0&quot;,\n      &quot;cniVersion&quot;: &quot;0.3.1&quot;,\n      &quot;plugins&quot;: [\n        &#123;\n          &quot;type&quot;: &quot;flannel&quot;,\n          &quot;delegate&quot;: &#123;\n            &quot;hairpinMode&quot;: true,\n            &quot;isDefaultGateway&quot;: true\n          &#125;\n        &#125;,\n        &#123;\n          &quot;type&quot;: &quot;portmap&quot;,\n          &quot;capabilities&quot;: &#123;\n            &quot;portMappings&quot;: true\n          &#125;\n        &#125;\n      ]\n    &#125;\n  net-conf.json: |\n    &#123;\n      &quot;Network&quot;: &quot;10.244.0.0&#x2F;16&quot;,\n      &quot;Backend&quot;: &#123;\n        &quot;Type&quot;: &quot;vxlan&quot;\n      &#125;\n    &#125;\n---\napiVersion: apps&#x2F;v1\nkind: DaemonSet\nmetadata:\n  name: kube-flannel-ds\n  namespace: kube-system\n  labels:\n    tier: node\n    app: flannel\nspec:\n  selector:\n    matchLabels:\n      app: flannel\n  template:\n    metadata:\n      labels:\n        tier: node\n        app: flannel\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: kubernetes.io&#x2F;os\n                operator: In\n                values:\n                - linux\n      hostNetwork: true\n      priorityClassName: system-node-critical\n      tolerations:\n      - operator: Exists\n        effect: NoSchedule\n      serviceAccountName: flannel\n      initContainers:\n      - name: install-cni\n        image: quay.io&#x2F;coreos&#x2F;flannel:v0.14.0\n        command:\n        - cp\n        args:\n        - -f\n        - &#x2F;etc&#x2F;kube-flannel&#x2F;cni-conf.json\n        - &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-flannel.conflist\n        volumeMounts:\n        - name: cni\n          mountPath: &#x2F;etc&#x2F;cni&#x2F;net.d\n        - name: flannel-cfg\n          mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;\n      containers:\n      - name: kube-flannel\n        image: quay.io&#x2F;coreos&#x2F;flannel:v0.14.0\n        command:\n        - &#x2F;opt&#x2F;bin&#x2F;flanneld\n        args:\n        - --ip-masq\n        - --kube-subnet-mgr\n        resources:\n          requests:\n            cpu: &quot;100m&quot;\n            memory: &quot;50Mi&quot;\n          limits:\n            cpu: &quot;100m&quot;\n            memory: &quot;50Mi&quot;\n        securityContext:\n          privileged: false\n          capabilities:\n            add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;]\n        env:\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.name\n        - name: POD_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n        volumeMounts:\n        - name: run\n          mountPath: &#x2F;run&#x2F;flannel\n        - name: flannel-cfg\n          mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;\n      volumes:\n      - name: run\n        hostPath:\n          path: &#x2F;run&#x2F;flannel\n      - name: cni\n        hostPath:\n          path: &#x2F;etc&#x2F;cni&#x2F;net.d\n      - name: flannel-cfg\n        configMap:\n          name: kube-flannel-cfg\n\n\n\n2.8 测试kubernetes 集群2.8.1 部署nginx 测试kubectl create deployment nginx --image&#x3D;nginx\n\nkubectl expose deployment nginx --port&#x3D;80 --type&#x3D;NodePort\n\nkubectl get pod,svc\n\n3. 资源管理3.1 资源管理介绍在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。\n\n\n\n\n\n\n\n\n\nkubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。\nkubernetes的最小管理单元是pod而不是容器，所以只能将容器放在Pod中，而kubernetes一般也不会直接管理Pod，而是通过Pod控制器来管理Pod的。\nPod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了Service资源实现这个功能。\n当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种存储系统。\n\n\n\n\n\n\n\n\n\n\n学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作\n3.2 YAML语言介绍YAML是一个类似 XML、JSON 的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称”一种人性化的数据格式语言”。\n&lt;heima&gt;\n    &lt;age&gt;15&lt;&#x2F;age&gt;\n    &lt;address&gt;Beijing&lt;&#x2F;address&gt;\n&lt;&#x2F;heima&gt;\n\nheima:\n  age: 15\n  address: Beijing\n\nYAML的语法比较简单，主要有下面几个：\n\n大小写敏感\n使用缩进表示层级关系\n缩进不允许使用tab，只允许空格( 低版本限制 )\n缩进的空格数不重要，只要相同层级的元素左对齐即可\n‘#’表示注释\n\nYAML支持以下几种数据类型：\n\n纯量：单个的、不可再分的值\n对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hash） &#x2F; 字典（dictionary）\n数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）\n\n# 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期\n# 1 布尔类型\nc1: true (或者True)\n# 2 整型\nc2: 234\n# 3 浮点型\nc3: 3.14\n# 4 null类型 \nc4: ~  # 使用~表示null\n# 5 日期类型\nc5: 2018-02-17    # 日期必须使用ISO 8601格式，即yyyy-MM-dd\n# 6 时间类型\nc6: 2018-02-17T15:02:31+08:00  # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n# 7 字符串类型\nc7: heima     # 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 \nc8: line1\n    line2     # 字符串过多的情况可以拆成多行，每一行会被转化成一个空格\n\n# 对象\n# 形式一(推荐):\nheima:\n  age: 15\n  address: Beijing\n# 形式二(了解):\nheima: &#123;age: 15,address: Beijing&#125;\n\n# 数组\n# 形式一(推荐):\naddress:\n  - 顺义\n  - 昌平  \n# 形式二(了解):\naddress: [顺义,昌平]\n\n\n\n\n\n\n\n\n\n\n小提示：\n1 书写yaml切记: 后面要加一个空格\n2 如果需要将多段yaml配置放在一个文件中，中间要使用---分隔\n3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确\nhttps://www.json2yaml.com/convert-yaml-to-json\n3.3 资源管理方式\n命令式对象管理：直接使用命令去操作kubernetes资源\nkubectl run nginx-pod --image=nginx:1.17.1 --port=80\n\n命令式对象配置：通过命令配置和配置文件去操作kubernetes资源\nkubectl create/patch -f nginx-pod.yaml\n\n声明式对象配置：通过apply命令和配置文件去操作kubernetes资源\nkubectl apply -f nginx-pod.yaml\n\n\n\n\n\n类型\n操作对象\n适用环境\n优点\n缺点\n\n\n\n命令式对象管理\n对象\n测试\n简单\n只能操作活动对象，无法审计、跟踪\n\n\n命令式对象配置\n文件\n开发\n可以审计、跟踪\n项目大时，配置文件多，操作麻烦\n\n\n声明式对象配置\n目录\n开发\n支持目录操作\n意外情况下难以调试\n\n\n3.3.1 命令式对象管理kubectl命令\nkubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：\nkubectl [command] [type] [name] [flags]\n\ncomand：指定要对资源执行的操作，例如create、get、delete\ntype：指定资源类型，比如deployment、pod、service\nname：指定资源的名称，名称大小写敏感\nflags：指定额外的可选参数\n# 查看所有pod\nkubectl get pod \n\n# 查看某个pod\nkubectl get pod pod_name\n\n# 查看某个pod,以yaml格式展示结果\nkubectl get pod pod_name -o yaml\n\n资源类型\nkubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:\nkubectl api-resources\n\n经常使用的资源有下面这些：\n\n\n\n资源分类\n资源名称\n缩写\n资源作用\n\n\n\n集群级别资源\nnodes\nno\n集群组成部分\n\n\nnamespaces\nns\n隔离Pod\n\n\n\npod资源\npods\npo\n装载容器\n\n\npod资源控制器\nreplicationcontrollers\nrc\n控制pod资源\n\n\n\nreplicasets\nrs\n控制pod资源\n\n\n\ndeployments\ndeploy\n控制pod资源\n\n\n\ndaemonsets\nds\n控制pod资源\n\n\n\njobs\n\n控制pod资源\n\n\n\ncronjobs\ncj\n控制pod资源\n\n\n\nhorizontalpodautoscalers\nhpa\n控制pod资源\n\n\n\nstatefulsets\nsts\n控制pod资源\n\n\n服务发现资源\nservices\nsvc\n统一pod对外接口\n\n\n\ningress\ning\n统一pod对外接口\n\n\n存储资源\nvolumeattachments\n\n存储\n\n\n\npersistentvolumes\npv\n存储\n\n\n\npersistentvolumeclaims\npvc\n存储\n\n\n配置资源\nconfigmaps\ncm\n配置\n\n\n\nsecrets\n\n配置\n\n\n操作\nkubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令\nkubectl --help\n\n经常使用的操作有下面这些：\n\n\n\n命令分类\n命令\n翻译\n命令作用\n\n\n\n基本命令\ncreate\n创建\n创建一个资源\n\n\n\nedit\n编辑\n编辑一个资源\n\n\n\nget\n获取\n获取一个资源\n\n\n\npatch\n更新\n更新一个资源\n\n\n\ndelete\n删除\n删除一个资源\n\n\n\nexplain\n解释\n展示资源文档\n\n\n运行和调试\nrun\n运行\n在集群中运行一个指定的镜像\n\n\n\nexpose\n暴露\n暴露资源为Service\n\n\n\ndescribe\n描述\n显示资源内部信息\n\n\n\nlogs\n日志输出容器在 pod 中的日志\n输出容器在 pod 中的日志\n\n\n\nattach\n缠绕进入运行中的容器\n进入运行中的容器\n\n\n\nexec\n执行容器中的一个命令\n执行容器中的一个命令\n\n\n\ncp\n复制\n在Pod内外复制文件\n\n\n\nrollout\n首次展示\n管理资源的发布\n\n\n\nscale\n规模\n扩(缩)容Pod的数量\n\n\n\nautoscale\n自动调整\n自动调整Pod的数量\n\n\n高级命令\napply\nrc\n通过文件对资源进行配置\n\n\n\nlabel\n标签\n更新资源上的标签\n\n\n其他命令\ncluster-info\n集群信息\n显示集群信息\n\n\n\nversion\n版本\n显示当前Server和Client的版本\n\n\n下面以一个namespace &#x2F; pod的创建和删除简单演示下命令的使用：\n# 创建一个namespace\n[root@master ~]# kubectl create namespace dev\nnamespace&#x2F;dev created\n\n# 获取namespace\n[root@master ~]# kubectl get ns\nNAME              STATUS   AGE\ndefault           Active   21h\ndev               Active   21s\nkube-node-lease   Active   21h\nkube-public       Active   21h\nkube-system       Active   21h\n\n# 在此namespace下创建并运行一个nginx的Pod\n[root@master ~]# kubectl run pod --image&#x3D;nginx:latest -n dev\nkubectl run --generator&#x3D;deployment&#x2F;apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator&#x3D;run-pod&#x2F;v1 or kubectl create instead.\ndeployment.apps&#x2F;pod created\n\n# 查看新创建的pod\n[root@master ~]# kubectl get pod -n dev\nNAME  READY   STATUS    RESTARTS   AGE\npod   1&#x2F;1     Running   0          21s\n\n# 删除指定的pod\n[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x\npod &quot;pod&quot; deleted\n\n# 删除指定的namespace\n[root@master ~]# kubectl delete ns dev\nnamespace &quot;dev&quot; deleted\n\n3.3.2 命令式对象配置命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。\n1） 创建一个nginxpod.yaml，内容如下：\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: dev\n\n---\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginxpod\n  namespace: dev\nspec:\n  containers:\n  - name: nginx-containers\n    image: nginx:latest\n\n2）执行create命令，创建资源：\n[root@master ~]# kubectl create -f nginxpod.yaml\nnamespace&#x2F;dev created\npod&#x2F;nginxpod created\n\n此时发现创建了两个资源对象，分别是namespace和pod\n3）执行get命令，查看资源：\n[root@master ~]#  kubectl get -f nginxpod.yaml\nNAME            STATUS   AGE\nnamespace&#x2F;dev   Active   18s\n\nNAME            READY   STATUS    RESTARTS   AGE\npod&#x2F;nginxpod    1&#x2F;1     Running   0          17s\n\n这样就显示了两个资源对象的信息\n4）执行delete命令，删除资源：\n[root@master ~]# kubectl delete -f nginxpod.yaml\nnamespace &quot;dev&quot; deleted\npod &quot;nginxpod&quot; deleted\n\n此时发现两个资源对象被删除了\n总结:\n    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）\n\n3.3.3 声明式对象配置声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。\n# 首先执行一次kubectl apply -f yaml文件，发现创建了资源\n[root@master ~]#  kubectl apply -f nginxpod.yaml\nnamespace&#x2F;dev created\npod&#x2F;nginxpod created\n\n# 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动\n[root@master ~]#  kubectl apply -f nginxpod.yaml\nnamespace&#x2F;dev unchanged\npod&#x2F;nginxpod unchanged\n\n总结:\n    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）\n    使用apply操作资源：\n        如果资源不存在，就创建，相当于 kubectl create\n        如果资源已存在，就更新，相当于 kubectl patch\n\n\n\n\n\n\n\n\n\n\n扩展：kubectl可以在node节点上运行吗 ?\nkubectl的运行是需要进行配置的，它的配置文件是$HOME&#x2F;.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：\nscp  -r  HOME&#x2F;.kube   node1: HOME&#x2F;\n\n\n\n\n\n\n\n\n\n\n使用推荐: 三种方式应该怎么用 ?\n创建&#x2F;更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml\n删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml\n查询资源 使用命令式对象管理 kubectl get(describe) 资源名称\n4. 实战入门本章节将介绍如何在kubernetes集群中部署一个nginx服务，并且能够对其进行访问。\n4.1 NamespaceNamespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离。\n默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。\n可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。\n\nkubernetes在集群启动之后，会默认创建几个namespace\n[root@master ~]# kubectl  get namespace\nNAME              STATUS   AGE\ndefault           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间\nkube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入\nkube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）\nkube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间\n\n下面来看namespace资源的具体操作：\n查看\n# 1 查看所有的ns  命令：kubectl get ns\n[root@master ~]# kubectl get ns\nNAME              STATUS   AGE\ndefault           Active   45h\nkube-node-lease   Active   45h\nkube-public       Active   45h     \nkube-system       Active   45h     \n\n# 2 查看指定的ns   命令：kubectl get ns ns名称\n[root@master ~]# kubectl get ns default\nNAME      STATUS   AGE\ndefault   Active   45h\n\n# 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数\n# kubernetes支持的格式有很多，比较常见的是wide、json、yaml\n[root@master ~]# kubectl get ns default -o yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  creationTimestamp: &quot;2021-05-08T04:44:16Z&quot;\n  name: default\n  resourceVersion: &quot;151&quot;\n  selfLink: &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default\n  uid: 7405f73a-e486-43d4-9db6-145f1409f090\nspec:\n  finalizers:\n  - kubernetes\nstatus:\n  phase: Active\n  \n# 4 查看ns详情  命令：kubectl describe ns ns名称\n[root@master ~]# kubectl describe ns default\nName:         default\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nStatus:       Active  # Active 命名空间正在使用中  Terminating 正在删除命名空间\n\n# ResourceQuota 针对namespace做的资源限制\n# LimitRange针对namespace中的每个组件做的资源限制\nNo resource quota.\nNo LimitRange resource.\n\n创建\n# 创建namespace\n[root@master ~]# kubectl create ns dev\nnamespace&#x2F;dev created\n\n删除\n# 删除namespace\n[root@master ~]# kubectl delete ns dev\nnamespace &quot;dev&quot; deleted\n\n配置方式\n首先准备一个yaml文件：ns-dev.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: dev\n\n然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f ns-dev.yaml\n删除：kubectl delete -f ns-dev.yaml\n4.2 PodPod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。\nPod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。\n\nkubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：\n[root@master ~]# kubectl get pod -n kube-system\nNAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE\nkube-system   coredns-6955765f44-68g6v         1&#x2F;1     Running   0          2d1h\nkube-system   coredns-6955765f44-cs5r8         1&#x2F;1     Running   0          2d1h\nkube-system   etcd-master                      1&#x2F;1     Running   0          2d1h\nkube-system   kube-apiserver-master            1&#x2F;1     Running   0          2d1h\nkube-system   kube-controller-manager-master   1&#x2F;1     Running   0          2d1h\nkube-system   kube-flannel-ds-amd64-47r25      1&#x2F;1     Running   0          2d1h\nkube-system   kube-flannel-ds-amd64-ls5lh      1&#x2F;1     Running   0          2d1h\nkube-system   kube-proxy-685tk                 1&#x2F;1     Running   0          2d1h\nkube-system   kube-proxy-87spt                 1&#x2F;1     Running   0          2d1h\nkube-system   kube-scheduler-master            1&#x2F;1     Running   0          2d1h\n\n创建并运行\nkubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的\n# 命令格式： kubectl run (pod控制器名称) [参数] \n# --image  指定Pod的镜像\n# --port   指定端口\n# --namespace  指定namespace\n[root@master ~]# kubectl run nginx --image&#x3D;nginx:latest --port&#x3D;80 --namespace dev \ndeployment.apps&#x2F;nginx created\n\n查看pod信息\n# 查看Pod基本信息\n[root@master ~]# kubectl get pods -n dev\nNAME    READY   STATUS    RESTARTS   AGE\nnginx   1&#x2F;1     Running   0          43s\n\n# 查看Pod的详细信息\n[root@master ~]# kubectl describe pod nginx -n dev\nName:         nginx\nNamespace:    dev\nPriority:     0\nNode:         node1&#x2F;192.168.5.4\nStart Time:   Wed, 08 May 2021 09:29:24 +0800\nLabels:       pod-template-hash&#x3D;5ff7956ff6\n              run&#x3D;nginx\nAnnotations:  &lt;none&gt;\nStatus:       Running\nIP:           10.244.1.23\nIPs:\n  IP:           10.244.1.23\nControlled By:  ReplicaSet&#x2F;nginx\nContainers:\n  nginx:\n    Container ID:   docker:&#x2F;&#x2F;4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c\n    Image:          nginx:latest\n    Image ID:       docker-pullable:&#x2F;&#x2F;nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7\n    Port:           80&#x2F;TCP\n    Host Port:      0&#x2F;TCP\n    State:          Running\n      Started:      Wed, 08 May 2021 09:30:01 +0800\n    Ready:          True\n    Restart Count:  0\n    Environment:    &lt;none&gt;\n    Mounts:\n      &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount from default-token-hwvvw (ro)\nConditions:\n  Type              Status\n  Initialized       True\n  Ready             True\n  ContainersReady   True\n  PodScheduled      True\nVolumes:\n  default-token-hwvvw:\n    Type:        Secret (a volume populated by a Secret)\n    SecretName:  default-token-hwvvw\n    Optional:    false\nQoS Class:       BestEffort\nNode-Selectors:  &lt;none&gt;\nTolerations:     node.kubernetes.io&#x2F;not-ready:NoExecute for 300s\n                 node.kubernetes.io&#x2F;unreachable:NoExecute for 300s\nEvents:\n  Type    Reason     Age        From               Message\n  ----    ------     ----       ----               -------\n  Normal  Scheduled  &lt;unknown&gt;  default-scheduler  Successfully assigned dev&#x2F;nginx-5ff7956ff6-fg2db to node1\n  Normal  Pulling    4m11s      kubelet, node1     Pulling image &quot;nginx:latest&quot;\n  Normal  Pulled     3m36s      kubelet, node1     Successfully pulled image &quot;nginx:latest&quot;\n  Normal  Created    3m36s      kubelet, node1     Created container nginx\n  Normal  Started    3m36s      kubelet, node1     Started container nginx\n\n访问Pod\n# 获取podIP\n[root@master ~]# kubectl get pods -n dev -o wide\nNAME    READY   STATUS    RESTARTS   AGE    IP             NODE    ... \nnginx   1&#x2F;1     Running   0          190s   10.244.1.23   node1   ...\n\n#访问POD\n[root@master ~]# curl http:&#x2F;&#x2F;10.244.1.23:80\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n删除指定Pod\n# 删除指定Pod\n[root@master ~]# kubectl delete pod nginx -n dev\npod &quot;nginx&quot; deleted\n\n# 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 \n[root@master ~]# kubectl get pods -n dev\nNAME    READY   STATUS    RESTARTS   AGE\nnginx   1&#x2F;1     Running   0          21s\n\n# 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建\n# 此时要想删除Pod，必须删除Pod控制器\n\n# 先来查询一下当前namespace下的Pod控制器\n[root@master ~]# kubectl get deploy -n  dev\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\nnginx   1&#x2F;1     1            1           9m7s\n\n# 接下来，删除此PodPod控制器\n[root@master ~]# kubectl delete deploy nginx -n dev\ndeployment.apps &quot;nginx&quot; deleted\n\n# 稍等片刻，再查询Pod，发现Pod被删除了\n[root@master ~]# kubectl get pods -n dev\nNo resources found in dev namespace.\n\n配置操作\n创建一个pod-nginx.yaml，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  namespace: dev\nspec:\n  containers:\n  - image: nginx:latest\n    name: pod\n    ports:\n    - name: nginx-port\n      containerPort: 80\n      protocol: TCP\n\n然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f pod-nginx.yaml\n删除：kubectl delete -f pod-nginx.yaml\n4.3 LabelLabel是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。\nLabel的特点：\n\n一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等\n一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去\nLabel通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除\n\n可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。\n\n\n\n\n\n\n\n\n\n一些常用的Label 示例如下：\n\n版本标签：”version”:”release”, “version”:”stable”……\n环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”\n架构标签：”tier”:”frontend”，”tier”:”backend”\n\n标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：\nLabel用于给某个资源对象定义标识\nLabel Selector用于查询和筛选拥有某些标签的资源对象\n当前有两种Label Selector：\n\n基于等式的Label Selector\nname &#x3D; slave: 选择所有包含Label中key&#x3D;”name”且value&#x3D;”slave”的对象\nenv !&#x3D; production: 选择所有包括Label中的key&#x3D;”env”且value不等于”production”的对象\n\n基于集合的Label Selector\nname in (master, slave): 选择所有包含Label中的key&#x3D;”name”且value&#x3D;”master”或”slave”的对象\nname not in (frontend): 选择所有包含Label中的key&#x3D;”name”且value不等于”frontend”的对象\n\n\n标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：\nname&#x3D;slave，env!&#x3D;production\nname not in (frontend)，env!&#x3D;production\n命令方式\n# 为pod资源打标签\n[root@master ~]# kubectl label pod nginx-pod version&#x3D;1.0 -n dev\npod&#x2F;nginx-pod labeled\n\n# 为pod资源更新标签\n[root@master ~]# kubectl label pod nginx-pod version&#x3D;2.0 -n dev --overwrite\npod&#x2F;nginx-pod labeled\n\n# 查看标签\n[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labels\nNAME        READY   STATUS    RESTARTS   AGE   LABELS\nnginx-pod   1&#x2F;1     Running   0          10m   version&#x3D;2.0\n\n# 筛选标签\n[root@master ~]# kubectl get pod -n dev -l version&#x3D;2.0  --show-labels\nNAME        READY   STATUS    RESTARTS   AGE   LABELS\nnginx-pod   1&#x2F;1     Running   0          17m   version&#x3D;2.0\n[root@master ~]# kubectl get pod -n dev -l version!&#x3D;2.0 --show-labels\nNo resources found in dev namespace.\n\n#删除标签\n[root@master ~]# kubectl label pod nginx-pod version- -n dev\npod&#x2F;nginx-pod labeled\n\n配置方式\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  namespace: dev\n  labels:\n    version: &quot;3.0&quot; \n    env: &quot;test&quot;\nspec:\n  containers:\n  - image: nginx:latest\n    name: pod\n    ports:\n    - name: nginx-port\n      containerPort: 80\n      protocol: TCP\n\n然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml\n4.4 Deployment在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。\n在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。\n\n命令操作\n# 命令格式: kubectl create deployment 名称  [参数] \n# --image  指定pod的镜像\n# --port   指定端口\n# --replicas  指定创建pod数量\n# --namespace  指定namespace\n[root@master ~]# kubectl create deploy nginx --image&#x3D;nginx:latest --port&#x3D;80 --replicas&#x3D;3 -n dev\ndeployment.apps&#x2F;nginx created\n\n# 查看创建的Pod\n[root@master ~]# kubectl get pods -n dev\nNAME                     READY   STATUS    RESTARTS   AGE\nnginx-5ff7956ff6-6k8cb   1&#x2F;1     Running   0          19s\nnginx-5ff7956ff6-jxfjt   1&#x2F;1     Running   0          19s\nnginx-5ff7956ff6-v6jqw   1&#x2F;1     Running   0          19s\n\n# 查看deployment的信息\n[root@master ~]# kubectl get deploy -n dev\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\nnginx   3&#x2F;3     3            3           2m42s\n\n# UP-TO-DATE：成功升级的副本数量\n# AVAILABLE：可用副本的数量\n[root@master ~]# kubectl get deploy -n dev -o wide\nNAME    READY UP-TO-DATE  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR\nnginx   3&#x2F;3     3         3           2m51s   nginx        nginx:latest        run&#x3D;nginx\n\n# 查看deployment的详细信息\n[root@master ~]# kubectl describe deploy nginx -n dev\nName:                   nginx\nNamespace:              dev\nCreationTimestamp:      Wed, 08 May 2021 11:14:14 +0800\nLabels:                 run&#x3D;nginx\nAnnotations:            deployment.kubernetes.io&#x2F;revision: 1\nSelector:               run&#x3D;nginx\nReplicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable\nStrategyType:           RollingUpdate\nMinReadySeconds:        0\nRollingUpdateStrategy:  25% max unavailable, 25% max surge\nPod Template:\n  Labels:  run&#x3D;nginx\n  Containers:\n   nginx:\n    Image:        nginx:latest\n    Port:         80&#x2F;TCP\n    Host Port:    0&#x2F;TCP\n    Environment:  &lt;none&gt;\n    Mounts:       &lt;none&gt;\n  Volumes:        &lt;none&gt;\nConditions:\n  Type           Status  Reason\n  ----           ------  ------\n  Available      True    MinimumReplicasAvailable\n  Progressing    True    NewReplicaSetAvailable\nOldReplicaSets:  &lt;none&gt;\nNewReplicaSet:   nginx-5ff7956ff6 (3&#x2F;3 replicas created)\nEvents:\n  Type    Reason             Age    From                   Message\n  ----    ------             ----   ----                   -------\n  Normal  ScalingReplicaSet  5m43s  deployment-controller  Scaled up replicaset nginx-5ff7956ff6 to 3\n  \n# 删除 \n[root@master ~]# kubectl delete deploy nginx -n dev\ndeployment.apps &quot;nginx&quot; deleted\n\n配置操作\n创建一个deploy-nginx.yaml，内容如下：\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: nginx\n  namespace: dev\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      run: nginx\n  template:\n    metadata:\n      labels:\n        run: nginx\n    spec:\n      containers:\n      - image: nginx:latest\n        name: nginx\n        ports:\n        - containerPort: 80\n          protocol: TCP\n\n然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f deploy-nginx.yaml\n删除：kubectl delete -f deploy-nginx.yaml\n4.5 Service通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。\n虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：\n\nPod IP 会随着Pod的重建产生变化\nPod IP 仅仅是集群内可见的虚拟IP，外部无法访问\n\n这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。\nService可以看作是一组同类Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。\n\n操作一：创建集群内部可访问的Service\n# 暴露Service\n[root@master ~]# kubectl expose deploy nginx --name&#x3D;svc-nginx1 --type&#x3D;ClusterIP --port&#x3D;80 --target-port&#x3D;80 -n dev\nservice&#x2F;svc-nginx1 exposed\n\n# 查看service\n[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide\nNAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR\nsvc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80&#x2F;TCP    3m51s   run&#x3D;nginx\n\n# 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的\n# 可以通过这个IP访问当前service对应的POD\n[root@master ~]# curl 10.109.179.231:80\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n.......\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n操作二：创建集群外部也可访问的Service\n# 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问\n# 如果需要创建外部也可以访问的Service，需要修改type为NodePort\n[root@master ~]# kubectl expose deploy nginx --name&#x3D;svc-nginx2 --type&#x3D;NodePort --port&#x3D;80 --target-port&#x3D;80 -n dev\nservice&#x2F;svc-nginx2 exposed\n\n# 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928&#x2F;TC）\n[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wide\nNAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTOR\nsvc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928&#x2F;TCP   9s     run&#x3D;nginx\n\n# 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了\n# 例如在的电脑主机上通过浏览器访问下面的地址\nhttp:&#x2F;&#x2F;192.168.5.4:31928&#x2F;\n\n删除Service\n[root@master ~]# kubectl delete svc svc-nginx-1 -n dev service &quot;svc-nginx-1&quot; deleted\n\n配置方式\n创建一个svc-nginx.yaml，内容如下：\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc-nginx\n  namespace: dev\nspec:\n  clusterIP: 10.109.179.231 #固定svc的内网ip\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    run: nginx\n  type: ClusterIP\n\n然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f svc-nginx.yaml\n删除：kubectl delete -f svc-nginx.yaml\n\n\n\n\n\n\n\n\n\n小结\n至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。\n5. Pod详解5.1 Pod介绍5.1.1 Pod结构\n每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：\n\n用户程序所在的容器，数量可多可少\n\nPause容器，这是每个Pod都会有的一个根容器，它的作用有两个：\n\n可以以它为依据，评估整个Pod的健康状态\n\n可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信\n这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel\n\n\n\n5.1.2 Pod定义下面是Pod的资源清单：\napiVersion: v1     #必选，版本号，例如v1\nkind: Pod       　 #必选，资源类型，例如 Pod\nmetadata:       　 #必选，元数据\n  name: string     #必选，Pod名称\n  namespace: string  #Pod所属的命名空间,默认为&quot;default&quot;\n  labels:       　　  #自定义标签列表\n    - name: string      　          \nspec:  #必选，Pod中容器的详细定义\n  containers:  #必选，Pod中容器列表\n  - name: string   #必选，容器名称\n    image: string  #必选，容器的镜像名称\n    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 \n    command: [string]   #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]      #容器的启动命令参数列表\n    workingDir: string  #容器的工作目录\n    volumeMounts:       #挂载到容器内部的存储卷配置\n    - name: string      #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean #是否为只读模式\n    ports: #需要暴露的端口库号列表\n    - name: string        #端口的名称\n      containerPort: int  #容器需要监听的端口号\n      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string    #端口协议，支持TCP和UDP，默认TCP\n    env:   #容器运行前需设置的环境变量列表\n    - name: string  #环境变量名称\n      value: string #环境变量的值\n    resources: #资源限制和请求的设置\n      limits:  #资源限制的设置\n        cpu: string     #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string  #内存限制，单位可以为Mib&#x2F;Gib，将用于docker run --memory参数\n      requests: #资源请求的设置\n        cpu: string    #Cpu请求，容器启动的初始可用数量\n        memory: string #内存请求,容器启动的初始可用数量\n    lifecycle: #生命周期钩子\n        postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启\n        preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止\n    livenessProbe:  #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器\n      exec:       　 #对Pod容器内检查方式设置为exec方式\n        command: [string]  #exec方式需要制定的命令或脚本\n      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged: false\n  restartPolicy: [Always | Never | OnFailure]  #Pod的重启策略\n  nodeName: &lt;string&gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上\n  nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上\n  imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定\n  - name: string\n  hostNetwork: false   #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n  volumes:   #在该pod上定义共享存储卷列表\n  - name: string    #共享存储卷名称 （volumes类型有很多种）\n    emptyDir: &#123;&#125;       #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n    hostPath: string   #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n      path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录\n    secret:       　　　#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部\n      scretname: string  \n      items:     \n      - key: string\n        path: string\n    configMap:         #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n      name: string\n      items:\n      - key: string\n        path: string\n\n#小提示：\n#   在这里，可通过一个命令来查看每种资源的可配置项\n#   kubectl explain 资源类型         查看某种资源可以配置的一级属性\n#   kubectl explain 资源类型.属性     查看属性的子属性\n[root@k8s-master01 ~]# kubectl explain pod\nKIND:     Pod\nVERSION:  v1\nFIELDS:\n   apiVersion   &lt;string&gt;\n   kind &lt;string&gt;\n   metadata     &lt;Object&gt;\n   spec &lt;Object&gt;\n   status       &lt;Object&gt;\n\n[root@k8s-master01 ~]# kubectl explain pod.metadata\nKIND:     Pod\nVERSION:  v1\nRESOURCE: metadata &lt;Object&gt;\nFIELDS:\n   annotations  &lt;map[string]string&gt;\n   clusterName  &lt;string&gt;\n   creationTimestamp    &lt;string&gt;\n   deletionGracePeriodSeconds   &lt;integer&gt;\n   deletionTimestamp    &lt;string&gt;\n   finalizers   &lt;[]string&gt;\n   generateName &lt;string&gt;\n   generation   &lt;integer&gt;\n   labels       &lt;map[string]string&gt;\n   managedFields        &lt;[]Object&gt;\n   name &lt;string&gt;\n   namespace    &lt;string&gt;\n   ownerReferences      &lt;[]Object&gt;\n   resourceVersion      &lt;string&gt;\n   selfLink     &lt;string&gt;\n   uid  &lt;string&gt;\n\n在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：\n\napiVersion  版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到\nkind  类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到\nmetadata  元数据，主要是资源标识和说明，常用的有name、namespace、labels等\nspec  描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述\nstatus  状态信息，里面的内容不需要定义，由kubernetes自动生成\n\n在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:\n\ncontainers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息\nnodeName  根据nodeName的值将pod调度到指定的Node节点上\nnodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上\nhostNetwork  是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\nvolumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息\nrestartPolicy  重启策略，表示Pod在遇到故障的时候的处理策略\n\n5.2 Pod配置本小节主要来研究pod.spec.containers属性，这也是pod配置中最为关键的一项配置。\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers\nKIND:     Pod\nVERSION:  v1\nRESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器\nFIELDS:\n   name  &lt;string&gt;     # 容器名称\n   image &lt;string&gt;     # 容器需要的镜像地址\n   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 \n   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令\n   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表\n   env      &lt;[]Object&gt; # 容器环境变量的配置\n   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表\n   resources &lt;Object&gt;      # 资源限制和资源请求的设置\n\n5.2.1 基本配置创建pod-base.yaml文件，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-base\n  namespace: dev\n  labels:\n    user: heima\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  - name: busybox\n    image: busybox:1.30\n\n\n上面定义了一个比较简单Pod的配置，里面有两个容器：\n\nnginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）\nbusybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）\n\n# 创建Pod\n[root@k8s-master01 pod]# kubectl apply -f pod-base.yaml\npod&#x2F;pod-base created\n\n# 查看Pod状况\n# READY 1&#x2F;2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪\n# RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它\n[root@k8s-master01 pod]# kubectl get pod -n dev\nNAME       READY   STATUS    RESTARTS   AGE\npod-base   1&#x2F;2     Running   4          95s\n\n# 可以通过describe查看内部的详情\n# 此时已经运行起来了一个基本的Pod，虽然它暂时有问题\n[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev\n\n5.2.2 镜像拉取创建pod-imagepullpolicy.yaml文件，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-imagepullpolicy\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    imagePullPolicy: Never # 用于设置镜像拉取策略\n  - name: busybox\n    image: busybox:1.30\n\n\nimagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：\n\nAlways：总是从远程仓库拉取镜像（一直远程下载）\nIfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载）\nNever：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）\n\n\n\n\n\n\n\n\n\n\n默认值说明：\n如果镜像tag为具体版本号， 默认策略是：IfNotPresent\n如果镜像tag为：latest（最终版本） ，默认策略是always\n# 创建Pod\n[root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yaml\npod&#x2F;pod-imagepullpolicy created\n\n# 查看Pod详情\n# 此时明显可以看到nginx镜像有一步Pulling image &quot;nginx:1.17.1&quot;的过程\n[root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev\n......\nEvents:\n  Type     Reason     Age               From               Message\n  ----     ------     ----              ----               -------\n  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev&#x2F;pod-imagePullPolicy to node1\n  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;\n  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;\n  Normal   Created    26s               kubelet, node1     Created container nginx\n  Normal   Started    25s               kubelet, node1     Started container nginx\n  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine\n  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox\n  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox\n\n5.2.3 启动命令在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？\n原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。\n创建pod-command.yaml文件，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-command\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;touch &#x2F;tmp&#x2F;hello.txt;while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done;&quot;]\n\n\ncommand，用于在pod中的容器初始化完毕之后运行一个命令。\n\n\n\n\n\n\n\n\n\n稍微解释下上面命令的意思：\n“&#x2F;bin&#x2F;sh”,”-c”, 使用sh执行命令\ntouch &#x2F;tmp&#x2F;hello.txt; 创建一个&#x2F;tmp&#x2F;hello.txt 文件\nwhile true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间\n# 创建Pod\n[root@k8s-master01 pod]# kubectl create  -f pod-command.yaml\npod&#x2F;pod-command created\n\n# 查看Pod状态\n# 此时发现两个pod都正常运行了\n[root@k8s-master01 pod]# kubectl get pods pod-command -n dev\nNAME          READY   STATUS   RESTARTS   AGE\npod-command   2&#x2F;2     Runing   0          2s\n\n# 进入pod中的busybox容器，查看文件内容\n# 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 &#x2F;bin&#x2F;sh  在容器内部执行命令\n# 使用这个命令就可以进入某个容器的内部，然后进行相关操作了\n# 比如，可以查看txt文件的内容\n[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox &#x2F;bin&#x2F;sh\n&#x2F; # tail -f &#x2F;tmp&#x2F;hello.txt\n14:44:19\n14:44:22\n14:44:25\n\n特别说明：\n    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。\n 1 如果command和args均没有写，那么用Dockerfile的配置。\n 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command\n 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数\n 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数\n\n5.2.4 环境变量创建pod-env.yaml文件，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-env\n  namespace: dev\nspec:\n  containers:\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;while true;do &#x2F;bin&#x2F;echo $(date +%T);sleep 60; done;&quot;]\n    env: # 设置环境变量列表\n    - name: &quot;username&quot;\n      value: &quot;admin&quot;\n    - name: &quot;password&quot;\n      value: &quot;123456&quot;\n\nenv，环境变量，用于在pod中的容器设置环境变量。\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-env.yaml\npod&#x2F;pod-env created\n\n# 进入容器，输出环境变量\n[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it &#x2F;bin&#x2F;sh\n&#x2F; # echo $username\nadmin\n&#x2F; # echo $password\n123456\n\n这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。\n5.2.5 端口设置本小节来介绍容器的端口设置，也就是containers的ports选项。\n首先看下ports支持的子选项：\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers.ports\nKIND:     Pod\nVERSION:  v1\nRESOURCE: ports &lt;[]Object&gt;\nFIELDS:\n   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的\t\t\n   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)\n   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) \n   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)\n   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。\n\n接下来，编写一个测试案例，创建pod-ports.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-ports\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports: # 设置容器暴露的端口列表\n    - name: nginx-port\n      containerPort: 80\n      protocol: TCP\n\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-ports.yaml\npod&#x2F;pod-ports created\n\n# 查看pod\n# 在下面可以明显看到配置信息\n[root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml\n......\nspec:\n  containers:\n  - image: nginx:1.17.1\n    imagePullPolicy: IfNotPresent\n    name: nginx\n    ports:\n    - containerPort: 80\n      name: nginx-port\n      protocol: TCP\n......\n\n访问容器中的程序需要使用的是Podip:containerPort\n5.2.6 资源配额容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：\n\nlimits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启\nrequests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动\n\n可以通过上面两个选项设置资源的上下限。\n接下来，编写一个测试案例，创建pod-resources.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-resources\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    resources: # 资源配额\n      limits:  # 限制资源（上限）\n        cpu: &quot;2&quot; # CPU限制，单位是core数\n        memory: &quot;10Gi&quot; # 内存限制\n      requests: # 请求资源（下限）\n        cpu: &quot;1&quot;  # CPU限制，单位是core数\n        memory: &quot;10Mi&quot;  # 内存限制\n\n在这对cpu和memory的单位做一个说明：\n\ncpu：core数，可以为整数或小数\nmemory： 内存大小，可以使用Gi、Mi、G、M等形式\n\n# 运行Pod\n[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml\npod&#x2F;pod-resources created\n\n# 查看发现pod运行正常\n[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev\nNAME            READY   STATUS    RESTARTS   AGE  \npod-resources   1&#x2F;1     Running   0          39s   \n\n# 接下来，停止Pod\n[root@k8s-master01 ~]# kubectl delete  -f pod-resources.yaml\npod &quot;pod-resources&quot; deleted\n\n# 编辑pod，修改resources.requests.memory的值为10Gi\n[root@k8s-master01 ~]# vim pod-resources.yaml\n\n# 再次启动pod\n[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml\npod&#x2F;pod-resources created\n\n# 查看Pod状态，发现Pod启动失败\n[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide\nNAME            READY   STATUS    RESTARTS   AGE          \npod-resources   0&#x2F;1     Pending   0          20s    \n\n# 查看pod详情会发现，如下提示\n[root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev\n......\nWarning  FailedScheduling  35s   default-scheduler  0&#x2F;3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io&#x2F;master: &#125;, that the pod didn&#39;t tolerate, 2 Insufficient memory.(内存不足)\n\n5.3 Pod生命周期我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：\n\npod创建过程\n运行初始化容器（init container）过程\n运行主容器（main container）\n容器启动后钩子（post start）、容器终止前钩子（pre stop）\n容器的存活性探测（liveness probe）、就绪性探测（readiness probe）\n\n\npod终止过程\n\n\n在整个生命周期中，Pod会出现5种状态（相位），分别如下：\n\n挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中\n运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成\n成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启\n失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态\n未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致\n\n5.3.1 创建和终止pod的创建过程\n\n用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer\n\napiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端\n\napiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动\n\nscheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer\n\nnode节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer\n\napiServer将接收到的pod状态信息存入etcd中\n\n\n\npod的终止过程\n\n用户向apiServer发送删除pod对象的命令\napiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead\n将pod标记为terminating状态\nkubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程\n端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除\n如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行\npod对象中的容器进程收到停止信号\n宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号\nkubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见\n\n5.3.2 初始化容器初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：\n\n初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成\n初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行\n\n初始化容器有很多的应用场景，下面列出的是最常见的几个：\n\n提供主容器镜像中不具备的工具程序或自定义代码\n初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足\n\n接下来做一个案例，模拟下面这个需求：\n假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器\n为了简化测试，事先规定好mysql(192.168.5.4)和redis(192.168.5.5)服务器的地址\n创建pod-initcontainer.yaml，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-initcontainer\n  namespace: dev\nspec:\n  containers:\n  - name: main-container\n    image: nginx:1.17.1\n    ports: \n    - name: nginx-port\n      containerPort: 80\n  initContainers:\n  - name: test-mysql\n    image: busybox:1.30\n    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until ping 192.168.5.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#39;]\n  - name: test-redis\n    image: busybox:1.30\n    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until ping 192.168.5.15 -c 1 ; do echo waiting for reids...; sleep 2; done;&#39;]\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yaml\npod&#x2F;pod-initcontainer created\n\n# 查看pod状态\n# 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行\nroot@k8s-master01 ~]# kubectl describe pod  pod-initcontainer -n dev\n........\nEvents:\n  Type    Reason     Age   From               Message\n  ----    ------     ----  ----               -------\n  Normal  Scheduled  49s   default-scheduler  Successfully assigned dev&#x2F;pod-initcontainer to node1\n  Normal  Pulled     48s   kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine\n  Normal  Created    48s   kubelet, node1     Created container test-mysql\n  Normal  Started    48s   kubelet, node1     Started container test-mysql\n\n# 动态查看pod\n[root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -w\nNAME                             READY   STATUS     RESTARTS   AGE\npod-initcontainer                0&#x2F;1     Init:0&#x2F;2   0          15s\npod-initcontainer                0&#x2F;1     Init:1&#x2F;2   0          52s\npod-initcontainer                0&#x2F;1     Init:1&#x2F;2   0          53s\npod-initcontainer                0&#x2F;1     PodInitializing   0          89s\npod-initcontainer                1&#x2F;1     Running           0          90s\n\n# 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化\n[root@k8s-master01 ~]# ifconfig ens33:1 192.168.5.14 netmask 255.255.255.0 up\n[root@k8s-master01 ~]# ifconfig ens33:2 192.168.5.15 netmask 255.255.255.0 up\n\n5.3.3 钩子函数钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。\nkubernetes在主容器的启动之后和停止之前提供了两个钩子函数：\n\npost start：容器创建之后执行，如果失败了会重启容器\npre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作\n\n钩子处理器支持使用下面三种方式定义动作：\n\nExec命令：在容器内执行一次命令\n……\n  lifecycle:\n    postStart: \n      exec:\n        command:\n        - cat\n        - &#x2F;tmp&#x2F;healthy\n……\n\nTCPSocket：在当前容器尝试访问指定的socket\n……      \n  lifecycle:\n    postStart:\n      tcpSocket:\n        port: 8080\n……\n\nHTTPGet：在当前容器中向某url发起http请求\n……\n  lifecycle:\n    postStart:\n      httpGet:\n        path: &#x2F; #URI地址\n        port: 80 #端口号\n        host: 192.168.5.3 #主机地址\n        scheme: HTTP #支持的协议，http或者https\n……\n\n接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-hook-exec\n  namespace: dev\nspec:\n  containers:\n  - name: main-container\n    image: nginx:1.17.1\n    ports:\n    - name: nginx-port\n      containerPort: 80\n    lifecycle:\n      postStart: \n        exec: # 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容\n          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo postStart... &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&quot;]\n      preStop:\n        exec: # 在容器停止之前停止nginx服务\n          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yaml\npod&#x2F;pod-hook-exec created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods  pod-hook-exec -n dev -o wide\nNAME           READY   STATUS     RESTARTS   AGE    IP            NODE    \npod-hook-exec  1&#x2F;1     Running    0          29s    10.244.2.48   node2   \n\n# 访问pod\n[root@k8s-master01 ~]# curl 10.244.2.48\npostStart...\n\n5.3.4 容器探测容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：\n\nliveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器\nreadiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量\n\n\n\n\n\n\n\n\n\n\nlivenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。\n上面两种探针目前均支持三种探测方式：\n\nExec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常\n……\n  livenessProbe:\n    exec:\n      command:\n      - cat\n      - &#x2F;tmp&#x2F;healthy\n……\n\nTCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常\n……      \n  livenessProbe:\n    tcpSocket:\n      port: 8080\n……\n\nHTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常\n……\n  livenessProbe:\n    httpGet:\n      path: &#x2F; #URI地址\n      port: 80 #端口号\n      host: 127.0.0.1 #主机地址\n      scheme: HTTP #支持的协议，http或者https\n……\n\n下面以liveness probes为例，做几个演示：\n方式一：Exec\n创建pod-liveness-exec.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-liveness-exec\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports: \n    - name: nginx-port\n      containerPort: 80\n    livenessProbe:\n      exec:\n        command: [&quot;&#x2F;bin&#x2F;cat&quot;,&quot;&#x2F;tmp&#x2F;hello.txt&quot;] # 执行一个查看文件的命令\n\n创建pod，观察效果\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yaml\npod&#x2F;pod-liveness-exec created\n\n# 查看Pod详情\n[root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev\n......\n  Normal   Created    20s (x2 over 50s)  kubelet, node1     Created container nginx\n  Normal   Started    20s (x2 over 50s)  kubelet, node1     Started container nginx\n  Normal   Killing    20s                kubelet, node1     Container nginx failed liveness probe, will be restarted\n  Warning  Unhealthy  0s (x5 over 40s)   kubelet, node1     Liveness probe failed: cat: can&#39;t open &#39;&#x2F;tmp&#x2F;hello11.txt&#39;: No such file or directory\n  \n# 观察上面的信息就会发现nginx容器启动之后就进行了健康检查\n# 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解）\n# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长\n[root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n dev\nNAME                READY   STATUS             RESTARTS   AGE\npod-liveness-exec   0&#x2F;1     CrashLoopBackOff   2          3m19s\n\n# 当然接下来，可以修改成一个存在的文件，比如&#x2F;tmp&#x2F;hello.txt，再试，结果就正常了......\n\n方式二：TCPSocket\n创建pod-liveness-tcpsocket.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-liveness-tcpsocket\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports: \n    - name: nginx-port\n      containerPort: 80\n    livenessProbe:\n      tcpSocket:\n        port: 8080 # 尝试访问8080端口\n\n创建pod，观察效果\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yaml\npod&#x2F;pod-liveness-tcpsocket created\n\n# 查看Pod详情\n[root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev\n......\n  Normal   Scheduled  31s                            default-scheduler  Successfully assigned dev&#x2F;pod-liveness-tcpsocket to node2\n  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine\n  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx\n  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx\n  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused\n  \n# 观察上面的信息，发现尝试访问8080端口,但是失败了\n# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长\n[root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket  -n dev\nNAME                     READY   STATUS             RESTARTS   AGE\npod-liveness-tcpsocket   0&#x2F;1     CrashLoopBackOff   2          3m19s\n\n# 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......\n\n方式三：HTTPGet\n创建pod-liveness-httpget.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-liveness-httpget\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - name: nginx-port\n      containerPort: 80\n    livenessProbe:\n      httpGet:  # 其实就是访问http:&#x2F;&#x2F;127.0.0.1:80&#x2F;hello  \n        scheme: HTTP #支持的协议，http或者https\n        port: 80 #端口号\n        path: &#x2F;hello #URI地址\n\n创建pod，观察效果\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yaml\npod&#x2F;pod-liveness-httpget created\n\n# 查看Pod详情\n[root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev\n.......\n  Normal   Pulled     6s (x3 over 64s)  kubelet, node1     Container image &quot;nginx:1.17.1&quot; already present on machine\n  Normal   Created    6s (x3 over 64s)  kubelet, node1     Created container nginx\n  Normal   Started    6s (x3 over 63s)  kubelet, node1     Started container nginx\n  Warning  Unhealthy  6s (x6 over 56s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404\n  Normal   Killing    6s (x2 over 36s)  kubelet, node1     Container nginx failed liveness probe, will be restarted\n  \n# 观察上面信息，尝试访问路径，但是未找到,出现404错误\n# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长\n[root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n dev\nNAME                   READY   STATUS    RESTARTS   AGE\npod-liveness-httpget   1&#x2F;1     Running   5          3m17s\n\n# 当然接下来，可以修改成一个可以访问的路径path，比如&#x2F;，再试，结果就正常了......\n\n至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbe\nFIELDS:\n   exec &lt;Object&gt;  \n   tcpSocket    &lt;Object&gt;\n   httpGet      &lt;Object&gt;\n   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测\n   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒\n   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒\n   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1\n   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1\n\n下面稍微配置两个，演示下效果即可：\n[root@k8s-master01 ~]# more pod-liveness-httpget.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-liveness-httpget\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - name: nginx-port\n      containerPort: 80\n    livenessProbe:\n      httpGet:\n        scheme: HTTP\n        port: 80 \n        path: &#x2F;\n      initialDelaySeconds: 30 # 容器启动后30s开始探测\n      timeoutSeconds: 5 # 探测超时时间为5s\n\n5.3.5 重启策略在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：\n\nAlways ：容器失效时，自动重启该容器，这也是默认值。\nOnFailure ： 容器终止运行且退出码不为0时重启\nNever ： 不论状态为何，都不重启该容器\n\n重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。\n创建pod-restartpolicy.yaml：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-restartpolicy\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - name: nginx-port\n      containerPort: 80\n    livenessProbe:\n      httpGet:\n        scheme: HTTP\n        port: 80\n        path: &#x2F;hello\n  restartPolicy: Never # 设置重启策略为Never\n\n运行Pod测试\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yaml\npod&#x2F;pod-restartpolicy created\n\n# 查看Pod详情，发现nginx容器失败\n[root@k8s-master01 ~]# kubectl  describe pods pod-restartpolicy  -n dev\n......\n  Warning  Unhealthy  15s (x3 over 35s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404\n  Normal   Killing    15s                kubelet, node1     Container nginx failed liveness probe\n  \n# 多等一会，再观察pod的重启次数，发现一直是0，并未重启   \n[root@k8s-master01 ~]# kubectl  get pods pod-restartpolicy -n dev\nNAME                   READY   STATUS    RESTARTS   AGE\npod-restartpolicy      0&#x2F;1     Running   0          5min42s\n\n5.4 Pod调度在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：\n\n自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出\n定向调度：NodeName、NodeSelector\n亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity\n污点（容忍）调度：Taints、Toleration\n\n5.4.1 定向调度定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。\nNodeName\nNodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。\n接下来，实验一下：创建一个pod-nodename.yaml文件\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nodename\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  nodeName: node1 # 指定调度到node1节点上\n\n#创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml\npod&#x2F;pod-nodename created\n\n#查看Pod调度到NODE属性，确实是调度到了node1节点上\n[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide\nNAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......\npod-nodename   1&#x2F;1     Running   0          56s   10.244.1.87   node1     ......   \n\n# 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）\n[root@k8s-master01 ~]# kubectl delete -f pod-nodename.yaml\npod &quot;pod-nodename&quot; deleted\n[root@k8s-master01 ~]# vim pod-nodename.yaml\n[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml\npod&#x2F;pod-nodename created\n\n#再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行\n[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide\nNAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......\npod-nodename   0&#x2F;1     Pending   0          6s    &lt;none&gt;   node3   ......           \n\nNodeSelector\nNodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。\n接下来，实验一下：\n1 首先分别为node节点添加标签\n[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv&#x3D;pro\nnode&#x2F;node2 labeled\n[root@k8s-master01 ~]# kubectl label nodes node2 nodeenv&#x3D;test\nnode&#x2F;node2 labeled\n\n2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nodeselector\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  nodeSelector: \n    nodeenv: pro # 指定调度到具有nodeenv&#x3D;pro标签的节点上\n\n#创建Pod\n[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml\npod&#x2F;pod-nodeselector created\n\n#查看Pod调度到NODE属性，确实是调度到了node1节点上\n[root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wide\nNAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......\npod-nodeselector   1&#x2F;1     Running   0          47s   10.244.1.87   node1   ......\n\n# 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）\n[root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yaml\npod &quot;pod-nodeselector&quot; deleted\n[root@k8s-master01 ~]# vim pod-nodeselector.yaml\n[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml\npod&#x2F;pod-nodeselector created\n\n#再次查看，发现pod无法正常运行,Node的值为none\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME               READY   STATUS    RESTARTS   AGE     IP       NODE    \npod-nodeselector   0&#x2F;1     Pending   0          2m20s   &lt;none&gt;   &lt;none&gt;\n\n# 查看详情,发现node selector匹配失败的提示\n[root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev\n.......\nEvents:\n  Type     Reason            Age        From               Message\n  ----     ------            ----       ----               -------\n  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0&#x2F;3 nodes are available: 3 node(s) didn&#39;t match node selector.\n\n5.4.2 亲和性调度上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。\n基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。\nAffinity主要分为三类：\n\nnodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题\npodAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题\npodAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题\n\n\n\n\n\n\n\n\n\n\n关于亲和性(反亲和性)使用场景的说明：\n亲和性：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。\n反亲和性：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。\nNodeAffinity\n首先来看一下NodeAffinity的可配置项：\npod.spec.affinity.nodeAffinity\n  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制\n    nodeSelectorTerms  节点选择列表\n      matchFields   按节点字段列出的节点选择器要求列表\n      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)\n        key    键\n        values 值\n        operator 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt\n  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)\n    preference   一个节点选择器项，与相应的权重相关联\n      matchFields   按节点字段列出的节点选择器要求列表\n      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)\n        key    键\n        values 值\n        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt\n\tweight 倾向权重，在范围1-100。\n\n关系符的使用说明:\n\n- matchExpressions:\n  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点\n    operator: Exists\n  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点\n    operator: In\n    values: [&quot;xxx&quot;,&quot;yyy&quot;]\n  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点\n    operator: Gt\n    values: &quot;xxx&quot;\n\n接下来首先演示一下requiredDuringSchedulingIgnoredDuringExecution ,\n创建pod-nodeaffinity-required.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nodeaffinity-required\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  affinity:  #亲和性设置\n    nodeAffinity: #设置node亲和性\n      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制\n        nodeSelectorTerms:\n        - matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签\n          - key: nodeenv\n            operator: In\n            values: [&quot;xxx&quot;,&quot;yyy&quot;]\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml\npod&#x2F;pod-nodeaffinity-required created\n\n# 查看pod状态 （运行失败）\n[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide\nNAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... \npod-nodeaffinity-required   0&#x2F;1     Pending   0          16s   &lt;none&gt;   &lt;none&gt;  ......\n\n# 查看Pod的详情\n# 发现调度失败，提示node选择失败\n[root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev\n......\n  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0&#x2F;3 nodes are available: 3 node(s) didn&#39;t match node selector.\n  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0&#x2F;3 nodes are available: 3 node(s) didn&#39;t match node selector.\n\n#接下来，停止pod\n[root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yaml\npod &quot;pod-nodeaffinity-required&quot; deleted\n\n# 修改文件，将values: [&quot;xxx&quot;,&quot;yyy&quot;]------&gt; [&quot;pro&quot;,&quot;yyy&quot;]\n[root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml\n\n# 再次启动\n[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml\npod&#x2F;pod-nodeaffinity-required created\n\n# 此时查看，发现调度成功，已经将pod调度到了node1上\n[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide\nNAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... \npod-nodeaffinity-required   1&#x2F;1     Running   0          11s   10.244.1.89   node1 ......\n\n接下来再演示一下requiredDuringSchedulingIgnoredDuringExecution ,\n创建pod-nodeaffinity-preferred.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nodeaffinity-preferred\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  affinity:  #亲和性设置\n    nodeAffinity: #设置node亲和性\n      preferredDuringSchedulingIgnoredDuringExecution: # 软限制\n      - weight: 1\n        preference:\n          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)\n          - key: nodeenv\n            operator: In\n            values: [&quot;xxx&quot;,&quot;yyy&quot;]\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yaml\npod&#x2F;pod-nodeaffinity-preferred created\n\n# 查看pod状态 （运行成功）\n[root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n dev\nNAME                         READY   STATUS    RESTARTS   AGE\npod-nodeaffinity-preferred   1&#x2F;1     Running   0          40s\n\nNodeAffinity规则设置的注意事项：\n    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上\n    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可\n    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功\n    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化\n\nPodAffinity\nPodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。\n首先来看一下PodAffinity的可配置项：\npod.spec.affinity.podAffinity\n  requiredDuringSchedulingIgnoredDuringExecution  硬限制\n    namespaces       指定参照pod的namespace\n    topologyKey      指定调度作用域\n    labelSelector    标签选择器\n      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)\n        key    键\n        values 值\n        operator 关系符 支持In, NotIn, Exists, DoesNotExist.\n      matchLabels    指多个matchExpressions映射的内容\n  preferredDuringSchedulingIgnoredDuringExecution 软限制\n    podAffinityTerm  选项\n      namespaces      \n      topologyKey\n      labelSelector\n        matchExpressions  \n          key    键\n          values 值\n          operator\n        matchLabels \n    weight 倾向权重，在范围1-100\n\ntopologyKey用于指定调度时作用域,例如:\n    如果指定为kubernetes.io&#x2F;hostname，那就是以Node节点为区分范围\n\t如果指定为beta.kubernetes.io&#x2F;os,则以Node节点的操作系统类型来区分\n\n接下来，演示下requiredDuringSchedulingIgnoredDuringExecution,\n1）首先创建一个参照Pod，pod-podaffinity-target.yaml：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-podaffinity-target\n  namespace: dev\n  labels:\n    podenv: pro #设置标签\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  nodeName: node1 # 将目标pod名确指定到node1上\n\n# 启动目标pod\n[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yaml\npod&#x2F;pod-podaffinity-target created\n\n# 查看pod状况\n[root@k8s-master01 ~]# kubectl get pods  pod-podaffinity-target -n dev\nNAME                     READY   STATUS    RESTARTS   AGE\npod-podaffinity-target   1&#x2F;1     Running   0          4s\n\n2）创建pod-podaffinity-required.yaml，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-podaffinity-required\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  affinity:  #亲和性设置\n    podAffinity: #设置pod亲和性\n      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制\n      - labelSelector:\n          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签\n          - key: podenv\n            operator: In\n            values: [&quot;xxx&quot;,&quot;yyy&quot;]\n        topologyKey: kubernetes.io&#x2F;hostname\n\n上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。\n# 启动pod\n[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml\npod&#x2F;pod-podaffinity-required created\n\n# 查看pod状态，发现未运行\n[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev\nNAME                       READY   STATUS    RESTARTS   AGE\npod-podaffinity-required   0&#x2F;1     Pending   0          9s\n\n# 查看详细信息\n[root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required  -n dev\n......\nEvents:\n  Type     Reason            Age        From               Message\n  ----     ------            ----       ----               -------\n  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0&#x2F;3 nodes are available: 2 node(s) didn&#39;t match pod affinity rules, 1 node(s) had taints that the pod didn&#39;t tolerate.\n\n# 接下来修改  values: [&quot;xxx&quot;,&quot;yyy&quot;]-----&gt;values:[&quot;pro&quot;,&quot;yyy&quot;]\n# 意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上\n[root@k8s-master01 ~]# vim pod-podaffinity-required.yaml\n\n# 然后重新创建pod，查看效果\n[root@k8s-master01 ~]# kubectl delete -f  pod-podaffinity-required.yaml\npod &quot;pod-podaffinity-required&quot; deleted\n[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml\npod&#x2F;pod-podaffinity-required created\n\n# 发现此时Pod运行正常\n[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev\nNAME                       READY   STATUS    RESTARTS   AGE   LABELS\npod-podaffinity-required   1&#x2F;1     Running   0          6s    &lt;none&gt;\n\n关于PodAffinity的 preferredDuringSchedulingIgnoredDuringExecution，这里不再演示。\nPodAntiAffinity\nPodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。\n它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。\n1）继续使用上个案例中目标pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels\nNAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS\npod-podaffinity-required 1&#x2F;1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     \npod-podaffinity-target   1&#x2F;1     Running   0          9m25s   10.244.1.37   node1   podenv&#x3D;pro\n\n2）创建pod-podantiaffinity-required.yaml，内容如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-podantiaffinity-required\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  affinity:  #亲和性设置\n    podAntiAffinity: #设置pod亲和性\n      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制\n      - labelSelector:\n          matchExpressions: # 匹配podenv的值在[&quot;pro&quot;]中的标签\n          - key: podenv\n            operator: In\n            values: [&quot;pro&quot;]\n        topologyKey: kubernetes.io&#x2F;hostname\n\n上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;pro的pod不在同一Node上，运行测试一下。\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yaml\npod&#x2F;pod-podantiaffinity-required created\n\n# 查看pod\n# 发现调度到了node2上\n[root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide\nNAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. \npod-podantiaffinity-required   1&#x2F;1     Running   0          30s   10.244.1.96   node2  ..\n\n5.4.3 污点和容忍污点（Taints）\n前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加污点属性，来决定是否允许Pod调度过来。\nNode被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。\n污点的格式为：key=value:effect, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：\n\nPreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度\nNoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod\nNoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离\n\n\n使用kubectl设置和去除污点的命令示例如下：\n# 设置污点\nkubectl taint nodes node1 key&#x3D;value:effect\n\n# 去除污点\nkubectl taint nodes node1 key:effect-\n\n# 去除所有污点\nkubectl taint nodes node1 key-\n\n接下来，演示下污点的效果：\n\n准备节点node1（为了演示效果更加明显，暂时停止node2节点）\n为node1节点设置一个污点: tag=heima:PreferNoSchedule；然后创建pod1( pod1 可以 )\n修改为node1节点设置一个污点: tag=heima:NoSchedule；然后创建pod2( pod1 正常 pod2 失败 )\n修改为node1节点设置一个污点: tag=heima:NoExecute；然后创建pod3 ( 3个pod都失败 )\n\n# 为node1设置污点(PreferNoSchedule)\n[root@k8s-master01 ~]# kubectl taint nodes node1 tag&#x3D;heima:PreferNoSchedule\n\n# 创建pod1\n[root@k8s-master01 ~]# kubectl run taint1 --image&#x3D;nginx:1.17.1 -n dev\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   \ntaint1-7665f7fd85-574h4   1&#x2F;1     Running   0          2m24s   10.244.1.59   node1    \n\n# 为node1设置污点(取消PreferNoSchedule，设置NoSchedule)\n[root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule-\n[root@k8s-master01 ~]# kubectl taint nodes node1 tag&#x3D;heima:NoSchedule\n\n# 创建pod2\n[root@k8s-master01 ~]# kubectl run taint2 --image&#x3D;nginx:1.17.1 -n dev\n[root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide\nNAME                      READY   STATUS    RESTARTS   AGE     IP            NODE\ntaint1-7665f7fd85-574h4   1&#x2F;1     Running   0          2m24s   10.244.1.59   node1 \ntaint2-544694789-6zmlf    0&#x2F;1     Pending   0          21s     &lt;none&gt;        &lt;none&gt;   \n\n# 为node1设置污点(取消NoSchedule，设置NoExecute)\n[root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule-\n[root@k8s-master01 ~]# kubectl taint nodes node1 tag&#x3D;heima:NoExecute\n\n# 创建pod3\n[root@k8s-master01 ~]# kubectl run taint3 --image&#x3D;nginx:1.17.1 -n dev\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED \ntaint1-7665f7fd85-htkmp   0&#x2F;1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    \ntaint2-544694789-bn7wb    0&#x2F;1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     \ntaint3-6d78dbd749-tktkq   0&#x2F;1     Pending   0          6s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     \n\n小提示：\n    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.\n\n容忍（Toleration）\n上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到容忍。\n\n\n\n\n\n\n\n\n\n\n污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝\n下面先通过一个案例看下效果：\n\n上一小节，已经在node1节点上打上了NoExecute的污点，此时pod是调度不上去的\n本小节，可以通过给pod添加容忍，然后将其调度上去\n\n创建pod-toleration.yaml,内容如下\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-toleration\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n  tolerations:      # 添加容忍\n  - key: &quot;tag&quot;        # 要容忍的污点的key\n    operator: &quot;Equal&quot; # 操作符\n    value: &quot;heima&quot;    # 容忍的污点的value\n    effect: &quot;NoExecute&quot;   # 添加容忍的规则，这里必须和标记的污点规则相同\n\n# 添加容忍之前的pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED \npod-toleration   0&#x2F;1     Pending   0          3s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           \n\n# 添加容忍之后的pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED\npod-toleration   1&#x2F;1     Running   0          3s    10.244.1.62   node1   &lt;none&gt;        \n\n下面看一下容忍的详细配置:\n[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations\n......\nFIELDS:\n   key       # 对应着要容忍的污点的键，空意味着匹配所有的键\n   value     # 对应着要容忍的污点的值\n   operator  # key-value的运算符，支持Equal和Exists（默认）\n   effect    # 对应污点的effect，空意味着匹配所有影响\n   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间\n\n6. Pod控制器详解6.1 Pod控制器介绍Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：\n\n自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建\n控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建\n\n\n\n\n\n\n\n\n\n\n什么是Pod控制器\nPod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。\n在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：\n\nReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代\nReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级\nDeployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本\nHorizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷\nDaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务\nJob：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务\nCronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行\nStatefulSet：管理有状态应用\n\n6.2 ReplicaSet(RS)ReplicaSet的主要作用是保证一定数量的pod正常运行，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。\n\nReplicaSet的资源清单文件：\napiVersion: apps&#x2F;v1 # 版本号\nkind: ReplicaSet # 类型       \nmetadata: # 元数据\n  name: # rs名称 \n  namespace: # 所属命名空间 \n  labels: #标签\n    controller: rs\nspec: # 详情描述\n  replicas: 3 # 副本数量\n  selector: # 选择器，通过它指定该控制器管理哪些pod\n    matchLabels:      # Labels匹配规则\n      app: nginx-pod\n    matchExpressions: # Expressions匹配规则\n      - &#123;key: app, operator: In, values: [nginx-pod]&#125;\n  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        ports:\n        - containerPort: 80\n\n在这里面，需要新了解的配置项就是spec下面几个选项：\n\nreplicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1\n\nselector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制\n在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了\n\ntemplate：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义\n\n\n创建ReplicaSet\n创建pc-replicaset.yaml文件，内容如下：\napiVersion: apps&#x2F;v1\nkind: ReplicaSet   \nmetadata:\n  name: pc-replicaset\n  namespace: dev\nspec:\n  replicas: 3\n  selector: \n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n\n# 创建rs\n[root@k8s-master01 ~]# kubectl create -f pc-replicaset.yaml\nreplicaset.apps&#x2F;pc-replicaset created\n\n# 查看rs\n# DESIRED:期望副本数量  \n# CURRENT:当前副本数量  \n# READY:已经准备好提供服务的副本数量\n[root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wide\nNAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR\npc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app&#x3D;nginx-pod\n\n# 查看当前控制器创建出来的pod\n# 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码\n[root@k8s-master01 ~]# kubectl get pod -n dev\nNAME                          READY   STATUS    RESTARTS   AGE\npc-replicaset-6vmvt   1&#x2F;1     Running   0          54s\npc-replicaset-fmb8f   1&#x2F;1     Running   0          54s\npc-replicaset-snrk2   1&#x2F;1     Running   0          54s\n\n扩缩容\n# 编辑rs的副本数量，修改spec:replicas: 6即可\n[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev\nreplicaset.apps&#x2F;pc-replicaset edited\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                          READY   STATUS    RESTARTS   AGE\npc-replicaset-6vmvt   1&#x2F;1     Running   0          114m\npc-replicaset-cftnp   1&#x2F;1     Running   0          10s\npc-replicaset-fjlm6   1&#x2F;1     Running   0          10s\npc-replicaset-fmb8f   1&#x2F;1     Running   0          114m\npc-replicaset-s2whj   1&#x2F;1     Running   0          10s\npc-replicaset-snrk2   1&#x2F;1     Running   0          114m\n\n# 当然也可以直接使用命令实现\n# 使用scale命令实现扩缩容， 后面--replicas&#x3D;n直接指定目标数量即可\n[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas&#x3D;2 -n dev\nreplicaset.apps&#x2F;pc-replicaset scaled\n\n# 命令运行完毕，立即查看，发现已经有4个开始准备退出了\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                       READY   STATUS        RESTARTS   AGE\npc-replicaset-6vmvt   0&#x2F;1     Terminating   0          118m\npc-replicaset-cftnp   0&#x2F;1     Terminating   0          4m17s\npc-replicaset-fjlm6   0&#x2F;1     Terminating   0          4m17s\npc-replicaset-fmb8f   1&#x2F;1     Running       0          118m\npc-replicaset-s2whj   0&#x2F;1     Terminating   0          4m17s\npc-replicaset-snrk2   1&#x2F;1     Running       0          118m\n\n#稍等片刻，就只剩下2个了\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                       READY   STATUS    RESTARTS   AGE\npc-replicaset-fmb8f   1&#x2F;1     Running   0          119m\npc-replicaset-snrk2   1&#x2F;1     Running   0          119m\n\n镜像升级\n# 编辑rs的容器镜像 - image: nginx:1.17.2\n[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev\nreplicaset.apps&#x2F;pc-replicaset edited\n\n# 再次查看，发现镜像版本已经变更了\n[root@k8s-master01 ~]# kubectl get rs -n dev -o wide\nNAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...\npc-replicaset       2        2         2       140m   nginx         nginx:1.17.2  ...\n\n# 同样的道理，也可以使用命令完成这个工作\n# kubectl set image rs rs名称 容器&#x3D;镜像版本 -n namespace\n[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx&#x3D;nginx:1.17.1  -n dev\nreplicaset.apps&#x2F;pc-replicaset image updated\n\n# 再次查看，发现镜像版本已经变更了\n[root@k8s-master01 ~]# kubectl get rs -n dev -o wide\nNAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...\npc-replicaset        2        2         2       145m   nginx        nginx:1.17.1 ... \n\n删除ReplicaSet\n# 使用kubectl delete命令会删除此RS以及它管理的Pod\n# 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除\n[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev\nreplicaset.apps &quot;pc-replicaset&quot; deleted\n[root@k8s-master01 ~]# kubectl get pod -n dev -o wide\nNo resources found in dev namespace.\n\n# 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade&#x3D;false选项（不推荐）。\n[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade&#x3D;false\nreplicaset.apps &quot;pc-replicaset&quot; deleted\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                  READY   STATUS    RESTARTS   AGE\npc-replicaset-cl82j   1&#x2F;1     Running   0          75s\npc-replicaset-dslhb   1&#x2F;1     Running   0          75s\n\n# 也可以使用yaml直接删除(推荐)\n[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml\nreplicaset.apps &quot;pc-replicaset&quot; deleted\n\n6.3 Deployment(Deploy)为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。\n\nDeployment主要功能有下面几个：\n\n支持ReplicaSet的所有功能\n支持发布的停止、继续\n支持滚动升级和回滚版本\n\nDeployment的资源清单文件：\napiVersion: apps&#x2F;v1 # 版本号\nkind: Deployment # 类型       \nmetadata: # 元数据\n  name: # rs名称 \n  namespace: # 所属命名空间 \n  labels: #标签\n    controller: deploy\nspec: # 详情描述\n  replicas: 3 # 副本数量\n  revisionHistoryLimit: 3 # 保留历史版本\n  paused: false # 暂停部署，默认是false\n  progressDeadlineSeconds: 600 # 部署超时时间（s），默认是600\n  strategy: # 策略\n    type: RollingUpdate # 滚动更新策略\n    rollingUpdate: # 滚动更新\n      maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数\n      maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数\n  selector: # 选择器，通过它指定该控制器管理哪些pod\n    matchLabels:      # Labels匹配规则\n      app: nginx-pod\n    matchExpressions: # Expressions匹配规则\n      - &#123;key: app, operator: In, values: [nginx-pod]&#125;\n  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        ports:\n        - containerPort: 80\n\n创建deployment\n创建pc-deployment.yaml，内容如下：\napiVersion: apps&#x2F;v1\nkind: Deployment      \nmetadata:\n  name: pc-deployment\n  namespace: dev\nspec: \n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n\n# 创建deployment\n[root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record&#x3D;true\ndeployment.apps&#x2F;pc-deployment created\n\n# 查看deployment\n# UP-TO-DATE 最新版本的pod的数量\n# AVAILABLE  当前可用的pod的数量\n[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev\nNAME            READY   UP-TO-DATE   AVAILABLE   AGE\npc-deployment   3&#x2F;3     3            3           15s\n\n# 查看rs\n# 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串\n[root@k8s-master01 ~]# kubectl get rs -n dev\nNAME                       DESIRED   CURRENT   READY   AGE\npc-deployment-6696798b78   3         3         3       23s\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-6696798b78-d2c8n   1&#x2F;1     Running   0          107s\npc-deployment-6696798b78-smpvp   1&#x2F;1     Running   0          107s\npc-deployment-6696798b78-wvjd8   1&#x2F;1     Running   0          107s\n\n扩缩容\n# 变更副本数量为5个\n[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas&#x3D;5  -n dev\ndeployment.apps&#x2F;pc-deployment scaled\n\n# 查看deployment\n[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev\nNAME            READY   UP-TO-DATE   AVAILABLE   AGE\npc-deployment   5&#x2F;5     5            5           2m\n\n# 查看pod\n[root@k8s-master01 ~]#  kubectl get pods -n dev\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-6696798b78-d2c8n   1&#x2F;1     Running   0          4m19s\npc-deployment-6696798b78-jxmdq   1&#x2F;1     Running   0          94s\npc-deployment-6696798b78-mktqv   1&#x2F;1     Running   0          93s\npc-deployment-6696798b78-smpvp   1&#x2F;1     Running   0          4m19s\npc-deployment-6696798b78-wvjd8   1&#x2F;1     Running   0          4m19s\n\n# 编辑deployment的副本数量，修改spec:replicas: 4即可\n[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev\ndeployment.apps&#x2F;pc-deployment edited\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-6696798b78-d2c8n   1&#x2F;1     Running   0          5m23s\npc-deployment-6696798b78-jxmdq   1&#x2F;1     Running   0          2m38s\npc-deployment-6696798b78-smpvp   1&#x2F;1     Running   0          5m23s\npc-deployment-6696798b78-wvjd8   1&#x2F;1     Running   0          5m23s\n\n镜像更新\ndeployment支持两种更新策略:重建更新和滚动更新,可以通过strategy指定策略类型,支持两个属性:\nstrategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：\n  type：指定策略类型，支持两种策略\n    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod\n    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod\n  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：\n    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。\n    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。\n\n重建更新\n\n编辑pc-deployment.yaml,在spec节点下添加更新策略\n\nspec:\n  strategy: # 策略\n    type: Recreate # 重建更新\n\n\n创建deploy进行验证\n\n# 变更镜像\n[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx&#x3D;nginx:1.17.2 -n dev\ndeployment.apps&#x2F;pc-deployment image updated\n\n# 观察升级过程\n[root@k8s-master01 ~]#  kubectl get pods -n dev -w\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-5d89bdfbf9-65qcw   1&#x2F;1     Running   0          31s\npc-deployment-5d89bdfbf9-w5nzv   1&#x2F;1     Running   0          31s\npc-deployment-5d89bdfbf9-xpt7w   1&#x2F;1     Running   0          31s\n\npc-deployment-5d89bdfbf9-xpt7w   1&#x2F;1     Terminating   0          41s\npc-deployment-5d89bdfbf9-65qcw   1&#x2F;1     Terminating   0          41s\npc-deployment-5d89bdfbf9-w5nzv   1&#x2F;1     Terminating   0          41s\n\npc-deployment-675d469f8b-grn8z   0&#x2F;1     Pending       0          0s\npc-deployment-675d469f8b-hbl4v   0&#x2F;1     Pending       0          0s\npc-deployment-675d469f8b-67nz2   0&#x2F;1     Pending       0          0s\n\npc-deployment-675d469f8b-grn8z   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-675d469f8b-hbl4v   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-675d469f8b-67nz2   0&#x2F;1     ContainerCreating   0          0s\n\npc-deployment-675d469f8b-grn8z   1&#x2F;1     Running             0          1s\npc-deployment-675d469f8b-67nz2   1&#x2F;1     Running             0          1s\npc-deployment-675d469f8b-hbl4v   1&#x2F;1     Running             0          2s\n\n滚动更新\n\n编辑pc-deployment.yaml,在spec节点下添加更新策略\n\nspec:\n  strategy: # 策略\n    type: RollingUpdate # 滚动更新策略\n    rollingUpdate:\n      maxSurge: 25% \n      maxUnavailable: 25%\n\n\n创建deploy进行验证\n\n# 变更镜像\n[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx&#x3D;nginx:1.17.3 -n dev \ndeployment.apps&#x2F;pc-deployment image updated\n\n# 观察升级过程\n[root@k8s-master01 ~]# kubectl get pods -n dev -w\nNAME                           READY   STATUS    RESTARTS   AGE\npc-deployment-c848d767-8rbzt   1&#x2F;1     Running   0          31m\npc-deployment-c848d767-h4p68   1&#x2F;1     Running   0          31m\npc-deployment-c848d767-hlmz4   1&#x2F;1     Running   0          31m\npc-deployment-c848d767-rrqcn   1&#x2F;1     Running   0          31m\n\npc-deployment-966bf7f44-226rx   0&#x2F;1     Pending             0          0s\npc-deployment-966bf7f44-226rx   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-966bf7f44-226rx   1&#x2F;1     Running             0          1s\npc-deployment-c848d767-h4p68    0&#x2F;1     Terminating         0          34m\n\npc-deployment-966bf7f44-cnd44   0&#x2F;1     Pending             0          0s\npc-deployment-966bf7f44-cnd44   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-966bf7f44-cnd44   1&#x2F;1     Running             0          2s\npc-deployment-c848d767-hlmz4    0&#x2F;1     Terminating         0          34m\n\npc-deployment-966bf7f44-px48p   0&#x2F;1     Pending             0          0s\npc-deployment-966bf7f44-px48p   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-966bf7f44-px48p   1&#x2F;1     Running             0          0s\npc-deployment-c848d767-8rbzt    0&#x2F;1     Terminating         0          34m\n\npc-deployment-966bf7f44-dkmqp   0&#x2F;1     Pending             0          0s\npc-deployment-966bf7f44-dkmqp   0&#x2F;1     ContainerCreating   0          0s\npc-deployment-966bf7f44-dkmqp   1&#x2F;1     Running             0          2s\npc-deployment-c848d767-rrqcn    0&#x2F;1     Terminating         0          34m\n\n# 至此，新版本的pod创建完毕，就版本的pod销毁完毕\n# 中间过程是滚动进行的，也就是边销毁边创建\n\n滚动更新的过程：\n\n镜像更新中rs的变化\n# 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4\n# 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释\n[root@k8s-master01 ~]# kubectl get rs -n dev\nNAME                       DESIRED   CURRENT   READY   AGE\npc-deployment-6696798b78   0         0         0       7m37s\npc-deployment-6696798b11   0         0         0       5m37s\npc-deployment-c848d76789   4         4         4       72s\n\n版本回退\ndeployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.\nkubectl rollout： 版本升级相关功能，支持下面的选项：\n\nstatus 显示当前升级状态\nhistory 显示 升级历史记录\npause 暂停版本升级过程\nresume 继续已经暂停的版本升级过程\nrestart 重启版本升级过程\nundo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）\n\n# 查看当前升级版本的状态\n[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev\ndeployment &quot;pc-deployment&quot; successfully rolled out\n\n# 查看升级历史记录\n[root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev\ndeployment.apps&#x2F;pc-deployment\nREVISION  CHANGE-CAUSE\n1         kubectl create --filename&#x3D;pc-deployment.yaml --record&#x3D;true\n2         kubectl create --filename&#x3D;pc-deployment.yaml --record&#x3D;true\n3         kubectl create --filename&#x3D;pc-deployment.yaml --record&#x3D;true\n# 可以发现有三次版本记录，说明完成过两次升级\n\n# 版本回滚\n# 这里直接使用--to-revision&#x3D;1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本\n[root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment --to-revision&#x3D;1 -n dev\ndeployment.apps&#x2F;pc-deployment rolled back\n\n# 查看发现，通过nginx镜像版本可以发现到了第一版\n[root@k8s-master01 ~]# kubectl get deploy -n dev -o wide\nNAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         \npc-deployment   4&#x2F;4     4            4           74m   nginx        nginx:1.17.1   \n\n# 查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行\n# 其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，\n# 一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了\n[root@k8s-master01 ~]# kubectl get rs -n dev\nNAME                       DESIRED   CURRENT   READY   AGE\npc-deployment-6696798b78   4         4         4       78m\npc-deployment-966bf7f44    0         0         0       37m\npc-deployment-c848d767     0         0         0       71m\n\n金丝雀发布\nDeployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。\n比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。\n# 更新deployment的版本，并配置暂停deployment\n[root@k8s-master01 ~]#  kubectl set image deploy pc-deployment nginx&#x3D;nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev\ndeployment.apps&#x2F;pc-deployment image updated\ndeployment.apps&#x2F;pc-deployment paused\n\n#观察更新状态\n[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　\nWaiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...\n\n# 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令\n\n[root@k8s-master01 ~]# kubectl get rs -n dev -o wide\nNAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         \npc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   \npc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   \npc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   \n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-5d89bdfbf9-rj8sq   1&#x2F;1     Running   0          7m33s\npc-deployment-5d89bdfbf9-ttwgg   1&#x2F;1     Running   0          7m35s\npc-deployment-5d89bdfbf9-v4wvc   1&#x2F;1     Running   0          7m34s\npc-deployment-6c9f56fcfb-996rt   1&#x2F;1     Running   0          3m31s\npc-deployment-6c9f56fcfb-j2gtj   1&#x2F;1     Running   0          3m31s\n\n# 确保更新的pod没问题了，继续更新\n[root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n dev\ndeployment.apps&#x2F;pc-deployment resumed\n\n# 查看最后的更新情况\n[root@k8s-master01 ~]# kubectl get rs -n dev -o wide\nNAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         \npc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   \npc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   \npc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   \n\n[root@k8s-master01 ~]# kubectl get pods -n dev\nNAME                             READY   STATUS    RESTARTS   AGE\npc-deployment-6c9f56fcfb-7bfwh   1&#x2F;1     Running   0          37s\npc-deployment-6c9f56fcfb-996rt   1&#x2F;1     Running   0          5m27s\npc-deployment-6c9f56fcfb-j2gtj   1&#x2F;1     Running   0          5m27s\npc-deployment-6c9f56fcfb-rf84v   1&#x2F;1     Running   0          37s\n\n删除Deployment\n# 删除deployment，其下的rs和pod也将被删除\n[root@k8s-master01 ~]# kubectl delete -f pc-deployment.yaml\ndeployment.apps &quot;pc-deployment&quot; deleted\n\n6.4 Horizontal Pod Autoscaler(HPA)在前面的课程中，我们已经可以实现通过手工执行kubectl scale命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。\nHPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。\n\n接下来，我们来做一个实验\n1 安装metrics-server\nmetrics-server可以用来收集集群中的资源使用情况\n# 安装git\n[root@k8s-master01 ~]# yum install git -y\n# 获取metrics-server, 注意使用的版本\n[root@k8s-master01 ~]# git clone -b v0.3.6 https:&#x2F;&#x2F;github.com&#x2F;kubernetes-incubator&#x2F;metrics-server\n# 修改deployment, 注意修改的是镜像和初始化参数\n[root@k8s-master01 ~]# cd &#x2F;root&#x2F;metrics-server&#x2F;deploy&#x2F;1.8+&#x2F;\n[root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml\n按图中添加下面选项\nhostNetwork: true\nimage: registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;metrics-server-amd64:v0.3.6\nargs:\n- --kubelet-insecure-tls\n- --kubelet-preferred-address-types&#x3D;InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP\n\n\n# 安装metrics-server\n[root@k8s-master01 1.8+]# kubectl apply -f .&#x2F;\n\n# 查看pod运行情况\n[root@k8s-master01 1.8+]# kubectl get pod -n kube-system\nmetrics-server-6b976979db-2xwbj   1&#x2F;1     Running   0          90s\n\n# 使用kubectl top node 查看资源使用情况\n[root@k8s-master01 1.8+]# kubectl top node\nNAME           CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%\nk8s-master01   289m         14%    1582Mi          54%       \nk8s-node01     81m          4%     1195Mi          40%       \nk8s-node02     72m          3%     1211Mi          41%  \n[root@k8s-master01 1.8+]# kubectl top pod -n kube-system\nNAME                              CPU(cores)   MEMORY(bytes)\ncoredns-6955765f44-7ptsb          3m           9Mi\ncoredns-6955765f44-vcwr5          3m           8Mi\netcd-master                       14m          145Mi\n...\n# 至此,metrics-server安装完成\n\n2 准备deployment和servie\n创建pc-hpa-pod.yaml文件，内容如下：\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: nginx\n  namespace: dev\nspec:\n  strategy: # 策略\n    type: RollingUpdate # 滚动更新策略\n  replicas: 1\n  selector:\n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        resources: # 资源配额\n          limits:  # 限制资源（上限）\n            cpu: &quot;1&quot; # CPU限制，单位是core数\n          requests: # 请求资源（下限）\n            cpu: &quot;100m&quot;  # CPU限制，单位是core数\n\n# 创建service\n[root@k8s-master01 1.8+]# kubectl expose deployment nginx --type&#x3D;NodePort --port&#x3D;80 -n dev\n\n# 查看\n[root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n dev\nNAME                    READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps&#x2F;nginx   1&#x2F;1     1            1           47s\n\nNAME                         READY   STATUS    RESTARTS   AGE\npod&#x2F;nginx-7df9756ccc-bh8dr   1&#x2F;1     Running   0          47s\n\nNAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nservice&#x2F;nginx   NodePort   10.101.18.29   &lt;none&gt;        80:31830&#x2F;TCP   35s\n\n3 部署HPA\n创建pc-hpa.yaml文件，内容如下：\napiVersion: autoscaling&#x2F;v1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: pc-hpa\n  namespace: dev\nspec:\n  minReplicas: 1  #最小pod数量\n  maxReplicas: 10 #最大pod数量\n  targetCPUUtilizationPercentage: 3 # CPU使用率指标\n  scaleTargetRef:   # 指定要控制的nginx信息\n    apiVersion: apps&#x2F;v1\n    kind: Deployment\n    name: nginx\n\n# 创建hpa\n[root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yaml\nhorizontalpodautoscaler.autoscaling&#x2F;pc-hpa created\n\n# 查看hpa\n    [root@k8s-master01 1.8+]# kubectl get hpa -n dev\nNAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE\npc-hpa   Deployment&#x2F;nginx   0%&#x2F;3%     1         10        1          62s\n\n4 测试\n使用压测工具对service地址192.168.5.4:31830进行压测，然后通过控制台查看hpa和pod的变化\nhpa变化\n[root@k8s-master01 ~]# kubectl get hpa -n dev -w\nNAME   REFERENCE      TARGETS  MINPODS  MAXPODS  REPLICAS  AGE\npc-hpa  Deployment&#x2F;nginx  0%&#x2F;3%   1     10     1      4m11s\npc-hpa  Deployment&#x2F;nginx  0%&#x2F;3%   1     10     1      5m19s\npc-hpa  Deployment&#x2F;nginx  22%&#x2F;3%   1     10     1      6m50s\npc-hpa  Deployment&#x2F;nginx  22%&#x2F;3%   1     10     4      7m5s\npc-hpa  Deployment&#x2F;nginx  22%&#x2F;3%   1     10     8      7m21s\npc-hpa  Deployment&#x2F;nginx  6%&#x2F;3%   1     10     8      7m51s\npc-hpa  Deployment&#x2F;nginx  0%&#x2F;3%   1     10     8      9m6s\npc-hpa  Deployment&#x2F;nginx  0%&#x2F;3%   1     10     8      13m\npc-hpa  Deployment&#x2F;nginx  0%&#x2F;3%   1     10     1      14m\n\ndeployment变化\n[root@k8s-master01 ~]# kubectl get deployment -n dev -w\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\nnginx   1&#x2F;1     1            1           11m\nnginx   1&#x2F;4     1            1           13m\nnginx   1&#x2F;4     1            1           13m\nnginx   1&#x2F;4     1            1           13m\nnginx   1&#x2F;4     4            1           13m\nnginx   1&#x2F;8     4            1           14m\nnginx   1&#x2F;8     4            1           14m\nnginx   1&#x2F;8     4            1           14m\nnginx   1&#x2F;8     8            1           14m\nnginx   2&#x2F;8     8            2           14m\nnginx   3&#x2F;8     8            3           14m\nnginx   4&#x2F;8     8            4           14m\nnginx   5&#x2F;8     8            5           14m\nnginx   6&#x2F;8     8            6           14m\nnginx   7&#x2F;8     8            7           14m\nnginx   8&#x2F;8     8            8           15m\nnginx   8&#x2F;1     8            8           20m\nnginx   8&#x2F;1     8            8           20m\nnginx   1&#x2F;1     1            1           20m\n\npod变化\n[root@k8s-master01 ~]# kubectl get pods -n dev -w\nNAME                     READY   STATUS    RESTARTS   AGE\nnginx-7df9756ccc-bh8dr   1&#x2F;1     Running   0          11m\nnginx-7df9756ccc-cpgrv   0&#x2F;1     Pending   0          0s\nnginx-7df9756ccc-8zhwk   0&#x2F;1     Pending   0          0s\nnginx-7df9756ccc-rr9bn   0&#x2F;1     Pending   0          0s\nnginx-7df9756ccc-cpgrv   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-8zhwk   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-rr9bn   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-m9gsj   0&#x2F;1     Pending             0          0s\nnginx-7df9756ccc-g56qb   0&#x2F;1     Pending             0          0s\nnginx-7df9756ccc-sl9c6   0&#x2F;1     Pending             0          0s\nnginx-7df9756ccc-fgst7   0&#x2F;1     Pending             0          0s\nnginx-7df9756ccc-g56qb   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-m9gsj   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-sl9c6   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-fgst7   0&#x2F;1     ContainerCreating   0          0s\nnginx-7df9756ccc-8zhwk   1&#x2F;1     Running             0          19s\nnginx-7df9756ccc-rr9bn   1&#x2F;1     Running             0          30s\nnginx-7df9756ccc-m9gsj   1&#x2F;1     Running             0          21s\nnginx-7df9756ccc-cpgrv   1&#x2F;1     Running             0          47s\nnginx-7df9756ccc-sl9c6   1&#x2F;1     Running             0          33s\nnginx-7df9756ccc-g56qb   1&#x2F;1     Running             0          48s\nnginx-7df9756ccc-fgst7   1&#x2F;1     Running             0          66s\nnginx-7df9756ccc-fgst7   1&#x2F;1     Terminating         0          6m50s\nnginx-7df9756ccc-8zhwk   1&#x2F;1     Terminating         0          7m5s\nnginx-7df9756ccc-cpgrv   1&#x2F;1     Terminating         0          7m5s\nnginx-7df9756ccc-g56qb   1&#x2F;1     Terminating         0          6m50s\nnginx-7df9756ccc-rr9bn   1&#x2F;1     Terminating         0          7m5s\nnginx-7df9756ccc-m9gsj   1&#x2F;1     Terminating         0          6m50s\nnginx-7df9756ccc-sl9c6   1&#x2F;1     Terminating         0          6m50s\n\n6.5 DaemonSet(DS)DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。\n\nDaemonSet控制器的特点：\n\n每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上\n当节点从集群中移除时，Pod 也就被垃圾回收了\n\n下面先来看下DaemonSet的资源清单文件\napiVersion: apps&#x2F;v1 # 版本号\nkind: DaemonSet # 类型       \nmetadata: # 元数据\n  name: # rs名称 \n  namespace: # 所属命名空间 \n  labels: #标签\n    controller: daemonset\nspec: # 详情描述\n  revisionHistoryLimit: 3 # 保留历史版本\n  updateStrategy: # 更新策略\n    type: RollingUpdate # 滚动更新策略\n    rollingUpdate: # 滚动更新\n      maxUnavailable: 1 # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数\n  selector: # 选择器，通过它指定该控制器管理哪些pod\n    matchLabels:      # Labels匹配规则\n      app: nginx-pod\n    matchExpressions: # Expressions匹配规则\n      - &#123;key: app, operator: In, values: [nginx-pod]&#125;\n  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        ports:\n        - containerPort: 80\n\n创建pc-daemonset.yaml，内容如下：\napiVersion: apps&#x2F;v1\nkind: DaemonSet      \nmetadata:\n  name: pc-daemonset\n  namespace: dev\nspec: \n  selector:\n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n\n# 创建daemonset\n[root@k8s-master01 ~]# kubectl create -f  pc-daemonset.yaml\ndaemonset.apps&#x2F;pc-daemonset created\n\n# 查看daemonset\n[root@k8s-master01 ~]#  kubectl get ds -n dev -o wide\nNAME        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE   AGE   CONTAINERS   IMAGES         \npc-daemonset   2        2        2      2           2        24s   nginx        nginx:1.17.1   \n\n# 查看pod,发现在每个Node上都运行一个pod\n[root@k8s-master01 ~]#  kubectl get pods -n dev -o wide\nNAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    \npc-daemonset-9bck8   1&#x2F;1     Running   0          37s   10.244.1.43   node1     \npc-daemonset-k224w   1&#x2F;1     Running   0          37s   10.244.2.74   node2      \n\n# 删除daemonset\n[root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yaml\ndaemonset.apps &quot;pc-daemonset&quot; deleted\n\n6.6 JobJob，主要用于负责**批量处理(一次要处理指定数量任务)短暂的一次性(每个任务仅运行一次就结束)**任务。Job特点如下：\n\n当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量\n当成功结束的pod达到指定的数量时，Job将完成执行\n\n\nJob的资源清单文件：\napiVersion: batch&#x2F;v1 # 版本号\nkind: Job # 类型       \nmetadata: # 元数据\n  name: # rs名称 \n  namespace: # 所属命名空间 \n  labels: #标签\n    controller: job\nspec: # 详情描述\n  completions: 1 # 指定job需要成功运行Pods的次数。默认值: 1\n  parallelism: 1 # 指定job在任一时刻应该并发运行Pods的数量。默认值: 1\n  activeDeadlineSeconds: 30 # 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。\n  backoffLimit: 6 # 指定job失败后进行重试的次数。默认是6\n  manualSelector: true # 是否可以使用selector选择器选择pod，默认是false\n  selector: # 选择器，通过它指定该控制器管理哪些pod\n    matchLabels:      # Labels匹配规则\n      app: counter-pod\n    matchExpressions: # Expressions匹配规则\n      - &#123;key: app, operator: In, values: [counter-pod]&#125;\n  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本\n    metadata:\n      labels:\n        app: counter-pod\n    spec:\n      restartPolicy: Never # 重启策略只能设置为Never或者OnFailure\n      containers:\n      - name: counter\n        image: busybox:1.30\n        command: [&quot;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;]\n\n关于重启策略设置的说明：\n    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变\n    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1\n    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always\n\n创建pc-job.yaml，内容如下：\napiVersion: batch&#x2F;v1\nkind: Job      \nmetadata:\n  name: pc-job\n  namespace: dev\nspec:\n  manualSelector: true\n  selector:\n    matchLabels:\n      app: counter-pod\n  template:\n    metadata:\n      labels:\n        app: counter-pod\n    spec:\n      restartPolicy: Never\n      containers:\n      - name: counter\n        image: busybox:1.30\n        command: [&quot;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]\n\n# 创建job\n[root@k8s-master01 ~]# kubectl create -f pc-job.yaml\njob.batch&#x2F;pc-job created\n\n# 查看job\n[root@k8s-master01 ~]# kubectl get job -n dev -o wide  -w\nNAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR\npc-job   0&#x2F;1           21s        21s   counter      busybox:1.30   app&#x3D;counter-pod\npc-job   1&#x2F;1           31s        79s   counter      busybox:1.30   app&#x3D;counter-pod\n\n# 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态\n[root@k8s-master01 ~]# kubectl get pods -n dev -w\nNAME           READY   STATUS     RESTARTS      AGE\npc-job-rxg96   1&#x2F;1     Running     0            29s\npc-job-rxg96   0&#x2F;1     Completed   0            33s\n\n# 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项\n#  completions: 6 # 指定job需要成功运行Pods的次数为6\n#  parallelism: 3 # 指定job并发运行Pods的数量为3\n#  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -w\nNAME           READY   STATUS    RESTARTS   AGE\npc-job-684ft   1&#x2F;1     Running   0          5s\npc-job-jhj49   1&#x2F;1     Running   0          5s\npc-job-pfcvh   1&#x2F;1     Running   0          5s\npc-job-684ft   0&#x2F;1     Completed   0          11s\npc-job-v7rhr   0&#x2F;1     Pending     0          0s\npc-job-v7rhr   0&#x2F;1     Pending     0          0s\npc-job-v7rhr   0&#x2F;1     ContainerCreating   0          0s\npc-job-jhj49   0&#x2F;1     Completed           0          11s\npc-job-fhwf7   0&#x2F;1     Pending             0          0s\npc-job-fhwf7   0&#x2F;1     Pending             0          0s\npc-job-pfcvh   0&#x2F;1     Completed           0          11s\npc-job-5vg2j   0&#x2F;1     Pending             0          0s\npc-job-fhwf7   0&#x2F;1     ContainerCreating   0          0s\npc-job-5vg2j   0&#x2F;1     Pending             0          0s\npc-job-5vg2j   0&#x2F;1     ContainerCreating   0          0s\npc-job-fhwf7   1&#x2F;1     Running             0          2s\npc-job-v7rhr   1&#x2F;1     Running             0          2s\npc-job-5vg2j   1&#x2F;1     Running             0          3s\npc-job-fhwf7   0&#x2F;1     Completed           0          12s\npc-job-v7rhr   0&#x2F;1     Completed           0          12s\npc-job-5vg2j   0&#x2F;1     Completed           0          12s\n\n# 删除job\n[root@k8s-master01 ~]# kubectl delete -f pc-job.yaml\njob.batch &quot;pc-job&quot; deleted\n\n6.7 CronJob(CJ)CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行时间点及重复运行的方式。也就是说，CronJob可以在特定的时间点(反复的)去运行job任务。\n\nCronJob的资源清单文件：\napiVersion: batch&#x2F;v1beta1 # 版本号\nkind: CronJob # 类型       \nmetadata: # 元数据\n  name: # rs名称 \n  namespace: # 所属命名空间 \n  labels: #标签\n    controller: cronjob\nspec: # 详情描述\n  schedule: # cron格式的作业调度运行时间点,用于控制任务在什么时间执行\n  concurrencyPolicy: # 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业\n  failedJobHistoryLimit: # 为失败的任务执行保留的历史记录数，默认为1\n  successfulJobHistoryLimit: # 为成功的任务执行保留的历史记录数，默认为3\n  startingDeadlineSeconds: # 启动作业错误的超时时长\n  jobTemplate: # job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义\n    metadata:\n    spec:\n      completions: 1\n      parallelism: 1\n      activeDeadlineSeconds: 30\n      backoffLimit: 6\n      manualSelector: true\n      selector:\n        matchLabels:\n          app: counter-pod\n        matchExpressions: 规则\n          - &#123;key: app, operator: In, values: [counter-pod]&#125;\n      template:\n        metadata:\n          labels:\n            app: counter-pod\n        spec:\n          restartPolicy: Never \n          containers:\n          - name: counter\n            image: busybox:1.30\n            command: [&quot;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;]\n\n需要重点解释的几个选项：\nschedule: cron表达式，用于指定任务的执行时间\n    *&#x2F;1    *      *    *     *\n    &lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;\n\n    分钟 值从 0 到 59.\n    小时 值从 0 到 23.\n    日 值从 1 到 31.\n    月 值从 1 到 12.\n    星期 值从 0 到 6, 0 代表星期日\n    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； &#x2F;表示每...\nconcurrencyPolicy:\n    Allow:   允许Jobs并发运行(默认)\n    Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行\n    Replace: 替换，取消当前正在运行的作业并用新作业替换它\n\n创建pc-cronjob.yaml，内容如下：\napiVersion: batch&#x2F;v1beta1\nkind: CronJob\nmetadata:\n  name: pc-cronjob\n  namespace: dev\n  labels:\n    controller: cronjob\nspec:\n  schedule: &quot;*&#x2F;1 * * * *&quot;\n  jobTemplate:\n    metadata:\n    spec:\n      template:\n        spec:\n          restartPolicy: Never\n          containers:\n          - name: counter\n            image: busybox:1.30\n            command: [&quot;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]\n\n# 创建cronjob\n[root@k8s-master01 ~]# kubectl create -f pc-cronjob.yaml\ncronjob.batch&#x2F;pc-cronjob created\n\n# 查看cronjob\n[root@k8s-master01 ~]# kubectl get cronjobs -n dev\nNAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE\npc-cronjob   *&#x2F;1 * * * *   False     0        &lt;none&gt;          6s\n\n# 查看job\n[root@k8s-master01 ~]# kubectl get jobs -n dev\nNAME                    COMPLETIONS   DURATION   AGE\npc-cronjob-1592587800   1&#x2F;1           28s        3m26s\npc-cronjob-1592587860   1&#x2F;1           28s        2m26s\npc-cronjob-1592587920   1&#x2F;1           28s        86s\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods -n dev\npc-cronjob-1592587800-x4tsm   0&#x2F;1     Completed   0          2m24s\npc-cronjob-1592587860-r5gv4   0&#x2F;1     Completed   0          84s\npc-cronjob-1592587920-9dxxq   1&#x2F;1     Running     0          24s\n\n\n# 删除cronjob\n[root@k8s-master01 ~]# kubectl  delete -f pc-cronjob.yaml\ncronjob.batch &quot;pc-cronjob&quot; deleted\n\n7. Service详解7.1 Service介绍在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。\n为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。\n\nService在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。\n\n# 10.97.97.97:80 是service提供的访问入口\n# 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，\n# kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去\n# 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。\n[root@node1 ~]# ipvsadm -Ln\nIP Virtual Server version 1.2.1 (size&#x3D;4096)\nProt LocalAddress:Port Scheduler Flags\n  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\nTCP  10.97.97.97:80 rr\n  -&gt; 10.244.1.39:80               Masq    1      0          0\n  -&gt; 10.244.1.40:80               Masq    1      0          0\n  -&gt; 10.244.2.33:80               Masq    1      0          0\n\nkube-proxy目前支持三种工作模式:\nuserspace 模式\nuserspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。  该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。\n\niptables 模式\niptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。\n\nipvs 模式\nipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。\n\n# 此模式必须安装ipvs内核模块，否则会降级为iptables\n# 开启ipvs\n[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system\n# 修改mode: &quot;ipvs&quot;\n[root@k8s-master01 ~]# kubectl delete pod -l k8s-app&#x3D;kube-proxy -n kube-system\n[root@node1 ~]# ipvsadm -Ln\nIP Virtual Server version 1.2.1 (size&#x3D;4096)\nProt LocalAddress:Port Scheduler Flags\n  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\nTCP  10.97.97.97:80 rr\n  -&gt; 10.244.1.39:80               Masq    1      0          0\n  -&gt; 10.244.1.40:80               Masq    1      0          0\n  -&gt; 10.244.2.33:80               Masq    1      0          0\n\n7.2 Service类型Service的资源清单文件：\nkind: Service  # 资源类型\napiVersion: v1  # 资源版本\nmetadata: # 元数据\n  name: service # 资源名称\n  namespace: dev # 命名空间\nspec: # 描述\n  selector: # 标签选择器，用于确定当前service代理哪些pod\n    app: nginx\n  type: # Service类型，指定service的访问方式\n  clusterIP:  # 虚拟服务的ip地址\n  sessionAffinity: # session亲和性，支持ClientIP、None两个选项\n  ports: # 端口信息\n    - protocol: TCP \n      port: 3017  # service端口\n      targetPort: 5003 # pod端口\n      nodePort: 31122 # 主机端口\n\n\nClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问\nNodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务\nLoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持\nExternalName： 把集群外部的服务引入集群内部，直接使用\n\n7.3 Service使用7.3.1 实验环境准备在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置app=nginx-pod的标签\n创建deployment.yaml，内容如下：\napiVersion: apps&#x2F;v1\nkind: Deployment      \nmetadata:\n  name: pc-deployment\n  namespace: dev\nspec: \n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        ports:\n        - containerPort: 80\n\n[root@k8s-master01 ~]# kubectl create -f deployment.yaml\ndeployment.apps&#x2F;pc-deployment created\n\n# 查看pod详情\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels\nNAME                             READY   STATUS     IP            NODE     LABELS\npc-deployment-66cb59b984-8p84h   1&#x2F;1     Running    10.244.1.39   node1    app&#x3D;nginx-pod\npc-deployment-66cb59b984-vx8vx   1&#x2F;1     Running    10.244.2.33   node2    app&#x3D;nginx-pod\npc-deployment-66cb59b984-wnncx   1&#x2F;1     Running    10.244.1.40   node1    app&#x3D;nginx-pod\n\n# 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）\n# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev &#x2F;bin&#x2F;sh\n# echo &quot;10.244.1.39&quot; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html\n\n#修改完毕之后，访问测试\n[root@k8s-master01 ~]# curl 10.244.1.39\n10.244.1.39\n[root@k8s-master01 ~]# curl 10.244.2.33\n10.244.2.33\n[root@k8s-master01 ~]# curl 10.244.1.40\n10.244.1.40\n\n7.3.2 ClusterIP类型的Service创建service-clusterip.yaml文件\napiVersion: v1\nkind: Service\nmetadata:\n  name: service-clusterip\n  namespace: dev\nspec:\n  selector:\n    app: nginx-pod\n  clusterIP: 10.97.97.97 # service的ip地址，如果不写，默认会生成一个\n  type: ClusterIP\n  ports:\n  - port: 80  # Service端口       \n    targetPort: 80 # pod端口\n\n# 创建service\n[root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml\nservice&#x2F;service-clusterip created\n\n# 查看service\n[root@k8s-master01 ~]# kubectl get svc -n dev -o wide\nNAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR\nservice-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80&#x2F;TCP    13s   app&#x3D;nginx-pod\n\n# 查看service的详细信息\n# 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口\n[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev\nName:              service-clusterip\nNamespace:         dev\nLabels:            &lt;none&gt;\nAnnotations:       &lt;none&gt;\nSelector:          app&#x3D;nginx-pod\nType:              ClusterIP\nIP:                10.97.97.97\nPort:              &lt;unset&gt;  80&#x2F;TCP\nTargetPort:        80&#x2F;TCP\nEndpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80\nSession Affinity:  None\nEvents:            &lt;none&gt;\n\n# 查看ipvs的映射规则\n[root@k8s-master01 ~]# ipvsadm -Ln\nTCP  10.97.97.97:80 rr\n  -&gt; 10.244.1.39:80               Masq    1      0          0\n  -&gt; 10.244.1.40:80               Masq    1      0          0\n  -&gt; 10.244.2.33:80               Masq    1      0          0\n\n# 访问10.97.97.97:80观察效果\n[root@k8s-master01 ~]# curl 10.97.97.97:80\n10.244.2.33\n\nEndpoint\nEndpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。\n一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，Endpoints是实现实际服务的端点集合。换句话说，service和pod之间的联系是通过endpoints实现的。\n\n负载分发策略\n对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：\n\n如果不定义，默认使用kube-proxy的策略，比如随机、轮询\n\n基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上\n此模式可以使在spec中添加sessionAffinity:ClientIP选项\n\n\n# 查看ipvs的映射规则【rr 轮询】\n[root@k8s-master01 ~]# ipvsadm -Ln\nTCP  10.97.97.97:80 rr\n  -&gt; 10.244.1.39:80               Masq    1      0          0\n  -&gt; 10.244.1.40:80               Masq    1      0          0\n  -&gt; 10.244.2.33:80               Masq    1      0          0\n\n# 循环访问测试\n[root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done;\n10.244.1.40\n10.244.1.39\n10.244.2.33\n10.244.1.40\n10.244.1.39\n10.244.2.33\n\n# 修改分发策略----sessionAffinity:ClientIP\n\n# 查看ipvs规则【persistent 代表持久】\n[root@k8s-master01 ~]# ipvsadm -Ln\nTCP  10.97.97.97:80 rr persistent 10800\n  -&gt; 10.244.1.39:80               Masq    1      0          0\n  -&gt; 10.244.1.40:80               Masq    1      0          0\n  -&gt; 10.244.2.33:80               Masq    1      0          0\n\n# 循环访问测试\n[root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done;\n10.244.2.33\n10.244.2.33\n10.244.2.33\n  \n# 删除service\n[root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml\nservice &quot;service-clusterip&quot; deleted\n\n7.3.3 HeadLiness类型的Service在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。\n创建service-headliness.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: service-headliness\n  namespace: dev\nspec:\n  selector:\n    app: nginx-pod\n  clusterIP: None # 将clusterIP设置为None，即可创建headliness Service\n  type: ClusterIP\n  ports:\n  - port: 80    \n    targetPort: 80\n\n# 创建service\n[root@k8s-master01 ~]# kubectl create -f service-headliness.yaml\nservice&#x2F;service-headliness created\n\n# 获取service， 发现CLUSTER-IP未分配\n[root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wide\nNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR\nservice-headliness   ClusterIP   None         &lt;none&gt;        80&#x2F;TCP    11s   app&#x3D;nginx-pod\n\n# 查看service详情\n[root@k8s-master01 ~]# kubectl describe svc service-headliness  -n dev\nName:              service-headliness\nNamespace:         dev\nLabels:            &lt;none&gt;\nAnnotations:       &lt;none&gt;\nSelector:          app&#x3D;nginx-pod\nType:              ClusterIP\nIP:                None\nPort:              &lt;unset&gt;  80&#x2F;TCP\nTargetPort:        80&#x2F;TCP\nEndpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80\nSession Affinity:  None\nEvents:            &lt;none&gt;\n\n# 查看域名的解析情况\n[root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev &#x2F;bin&#x2F;sh\n&#x2F; # cat &#x2F;etc&#x2F;resolv.conf\nnameserver 10.96.0.10\nsearch dev.svc.cluster.local svc.cluster.local cluster.local\n\n[root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.local\nservice-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40\nservice-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39\nservice-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33\n\n7.3.4 NodePort类型的Service在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。\n\n创建service-nodeport.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: service-nodeport\n  namespace: dev\nspec:\n  selector:\n    app: nginx-pod\n  type: NodePort # service类型\n  ports:\n  - port: 80\n    nodePort: 30002 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n    targetPort: 80\n\n# 创建service\n[root@k8s-master01 ~]# kubectl create -f service-nodeport.yaml\nservice&#x2F;service-nodeport created\n\n# 查看service\n[root@k8s-master01 ~]# kubectl get svc -n dev -o wide\nNAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)       SELECTOR\nservice-nodeport   NodePort   10.105.64.191   &lt;none&gt;        80:30002&#x2F;TCP  app&#x3D;nginx-pod\n\n# 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod\n\n7.3.5 LoadBalancer类型的ServiceLoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。\n\n7.3.6 ExternalName类型的ServiceExternalName类型的Service用于引入集群外部的服务，它通过externalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: service-externalname\n  namespace: dev\nspec:\n  type: ExternalName # service类型\n  externalName: www.baidu.com  #改成ip地址也可以\n\n# 创建service\n[root@k8s-master01 ~]# kubectl  create -f service-externalname.yaml\nservice&#x2F;service-externalname created\n\n# 域名解析\n[root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.local\nservice-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com.\nwww.baidu.com.          30      IN      CNAME   www.a.shifen.com.\nwww.a.shifen.com.       30      IN      A       39.156.66.18\nwww.a.shifen.com.       30      IN      A       39.156.66.14\n\n7.4 Ingress介绍在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：\n\nNodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显\nLB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持\n\n基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：\n\n实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务。在这里有两个核心概念：\n\ningress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则\ningress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等\n\nIngress（以Nginx为例）的工作原理如下：\n\n用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service\nIngress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置\nIngress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新\n到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则\n\n\n7.5 Ingress使用7.5.1 环境准备搭建ingress环境\n# 创建文件夹\n[root@k8s-master01 ~]# mkdir ingress-controller\n[root@k8s-master01 ~]# cd ingress-controller&#x2F;\n\n# 获取ingress-nginx，本次案例使用的是0.30版本\n[root@k8s-master01 ingress-controller]# wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;nginx-0.30.0&#x2F;deploy&#x2F;static&#x2F;mandatory.yaml\n[root@k8s-master01 ingress-controller]# wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;nginx-0.30.0&#x2F;deploy&#x2F;static&#x2F;provider&#x2F;baremetal&#x2F;service-nodeport.yaml\n\n# 修改mandatory.yaml文件中的仓库\n# 修改quay.io&#x2F;kubernetes-ingress-controller&#x2F;nginx-ingress-controller:0.30.0\n# 为quay-mirror.qiniu.com&#x2F;kubernetes-ingress-controller&#x2F;nginx-ingress-controller:0.30.0\n# 创建ingress-nginx\n[root@k8s-master01 ingress-controller]# kubectl apply -f .&#x2F;\n\n# 查看ingress-nginx\n[root@k8s-master01 ingress-controller]# kubectl get pod -n ingress-nginx\nNAME                                           READY   STATUS    RESTARTS   AGE\npod&#x2F;nginx-ingress-controller-fbf967dd5-4qpbp   1&#x2F;1     Running   0          12h\n\n# 查看service\n[root@k8s-master01 ingress-controller]# kubectl get svc -n ingress-nginx\nNAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE\ningress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240&#x2F;TCP,443:31335&#x2F;TCP   11h\n\n准备service和pod\n为了后面的实验比较方便，创建如下图所示的模型\n\n创建tomcat-nginx.yaml\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  namespace: dev\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx-pod\n  template:\n    metadata:\n      labels:\n        app: nginx-pod\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.17.1\n        ports:\n        - containerPort: 80\n\n---\n\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: tomcat-deployment\n  namespace: dev\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: tomcat-pod\n  template:\n    metadata:\n      labels:\n        app: tomcat-pod\n    spec:\n      containers:\n      - name: tomcat\n        image: tomcat:8.5-jre10-slim\n        ports:\n        - containerPort: 8080\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\n  namespace: dev\nspec:\n  selector:\n    app: nginx-pod\n  clusterIP: None\n  type: ClusterIP\n  ports:\n  - port: 80\n    targetPort: 80\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: tomcat-service\n  namespace: dev\nspec:\n  selector:\n    app: tomcat-pod\n  clusterIP: None\n  type: ClusterIP\n  ports:\n  - port: 8080\n    targetPort: 8080\n\n# 创建\n[root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml\n\n# 查看\n[root@k8s-master01 ~]# kubectl get svc -n dev\nNAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\nnginx-service    ClusterIP   None         &lt;none&gt;        80&#x2F;TCP     48s\ntomcat-service   ClusterIP   None         &lt;none&gt;        8080&#x2F;TCP   48s\n\n7.5.2 Http代理创建ingress-http.yaml\napiVersion: extensions&#x2F;v1beta1\nkind: Ingress\nmetadata:\n  name: ingress-http\n  namespace: dev\nspec:\n  rules:\n  - host: nginx.itheima.com\n    http:\n      paths:\n      - path: &#x2F;\n        backend:\n          serviceName: nginx-service\n          servicePort: 80\n  - host: tomcat.itheima.com\n    http:\n      paths:\n      - path: &#x2F;\n        backend:\n          serviceName: tomcat-service\n          servicePort: 8080\n\n# 创建\n[root@k8s-master01 ~]# kubectl create -f ingress-http.yaml\ningress.extensions&#x2F;ingress-http created\n\n# 查看\n[root@k8s-master01 ~]# kubectl get ing ingress-http -n dev\nNAME           HOSTS                                  ADDRESS   PORTS   AGE\ningress-http   nginx.itheima.com,tomcat.itheima.com             80      22s\n\n# 查看详情\n[root@k8s-master01 ~]# kubectl describe ing ingress-http  -n dev\n...\nRules:\nHost                Path  Backends\n----                ----  --------\nnginx.itheima.com   &#x2F; nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)\ntomcat.itheima.com  &#x2F; tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)\n...\n\n# 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上\n# 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了\n\n7.5.3 Https代理创建证书\n# 生成证书\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;BJ&#x2F;L&#x3D;BJ&#x2F;O&#x3D;nginx&#x2F;CN&#x3D;itheima.com&quot;\n\n# 创建密钥\nkubectl create secret tls tls-secret --key tls.key --cert tls.crt\n\n创建ingress-https.yaml\napiVersion: extensions&#x2F;v1beta1\nkind: Ingress\nmetadata:\n  name: ingress-https\n  namespace: dev\nspec:\n  tls:\n    - hosts:\n      - nginx.itheima.com\n      - tomcat.itheima.com\n      secretName: tls-secret # 指定秘钥\n  rules:\n  - host: nginx.itheima.com\n    http:\n      paths:\n      - path: &#x2F;\n        backend:\n          serviceName: nginx-service\n          servicePort: 80\n  - host: tomcat.itheima.com\n    http:\n      paths:\n      - path: &#x2F;\n        backend:\n          serviceName: tomcat-service\n          servicePort: 8080\n\n# 创建\n[root@k8s-master01 ~]# kubectl create -f ingress-https.yaml\ningress.extensions&#x2F;ingress-https created\n\n# 查看\n[root@k8s-master01 ~]# kubectl get ing ingress-https -n dev\nNAME            HOSTS                                  ADDRESS         PORTS     AGE\ningress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s\n\n# 查看详情\n[root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev\n...\nTLS:\n  tls-secret terminates nginx.itheima.com,tomcat.itheima.com\nRules:\nHost              Path Backends\n----              ---- --------\nnginx.itheima.com  &#x2F;  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)\ntomcat.itheima.com &#x2F;  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)\n...\n\n# 下面可以通过浏览器访问https:&#x2F;&#x2F;nginx.itheima.com:31335 和 https:&#x2F;&#x2F;tomcat.itheima.com:31335来查看了\n\n8. 数据存储在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。\nVolume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。\nkubernetes的Volume支持多种类型，比较常见的有下面几个：\n\n简单存储：EmptyDir、HostPath、NFS\n高级存储：PV、PVC\n配置存储：ConfigMap、Secret\n\n8.1 基本存储8.1.1 EmptyDirEmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。\nEmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：\n\n临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留\n一个容器需要从另一个容器中获取数据的目录（多容器共享目录）\n\n接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。\n在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。\n\n创建一个volume-emptydir.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: volume-emptydir\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - containerPort: 80\n    volumeMounts:  # 将logs-volume挂在到nginx容器中，对应的目录为 &#x2F;var&#x2F;log&#x2F;nginx\n    - name: logs-volume\n      mountPath: &#x2F;var&#x2F;log&#x2F;nginx\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;tail -f &#x2F;logs&#x2F;access.log&quot;] # 初始命令，动态读取指定文件中内容\n    volumeMounts:  # 将logs-volume 挂在到busybox容器中，对应的目录为 &#x2F;logs\n    - name: logs-volume\n      mountPath: &#x2F;logs\n  volumes: # 声明volume， name为logs-volume，类型为emptyDir\n  - name: logs-volume\n    emptyDir: &#123;&#125;\n\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f volume-emptydir.yaml\npod&#x2F;volume-emptydir created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wide\nNAME                  READY   STATUS    RESTARTS   AGE      IP       NODE   ...... \nvolume-emptydir       2&#x2F;2     Running   0          97s   10.42.2.9   node1  ......\n\n# 通过podIp访问nginx\n[root@k8s-master01 ~]# curl 10.42.2.9\n......\n\n# 通过kubectl logs命令查看指定容器的标准输出\n[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox\n10.42.1.0 - - [27&#x2F;Jun&#x2F;2021:15:08:54 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;curl&#x2F;7.29.0&quot; &quot;-&quot;\n\n8.1.2 HostPath上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。\nHostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。\n\n创建一个volume-hostpath.yaml：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: volume-hostpath\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - containerPort: 80\n    volumeMounts:\n    - name: logs-volume\n      mountPath: &#x2F;var&#x2F;log&#x2F;nginx\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;tail -f &#x2F;logs&#x2F;access.log&quot;]\n    volumeMounts:\n    - name: logs-volume\n      mountPath: &#x2F;logs\n  volumes:\n  - name: logs-volume\n    hostPath: \n      path: &#x2F;root&#x2F;logs\n      type: DirectoryOrCreate  # 目录存在就使用，不存在就先创建后使用\n\n关于type的值的一点说明：\n    DirectoryOrCreate 目录存在就使用，不存在就先创建后使用\n    Directory   目录必须存在\n    FileOrCreate  文件存在就使用，不存在就先创建后使用\n    File 文件必须存在 \n    Socket  unix套接字必须存在\n    CharDevice  字符设备必须存在\n    BlockDevice 块设备必须存在\n\n# 创建Pod\n[root@k8s-master01 ~]# kubectl create -f volume-hostpath.yaml\npod&#x2F;volume-hostpath created\n\n# 查看Pod\n[root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wide\nNAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......\npod-volume-hostpath   2&#x2F;2     Running   0          16s   10.42.2.10     node1  ......\n\n#访问nginx\n[root@k8s-master01 ~]# curl 10.42.2.10\n\n# 接下来就可以去host的&#x2F;root&#x2F;logs目录下查看存储的文件了\n###  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）\n[root@node1 ~]# ls &#x2F;root&#x2F;logs&#x2F;\naccess.log  error.log\n\n# 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的\n\n8.1.3 NFSHostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。\nNFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。\n\n1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器\n# 在nfs上安装nfs服务\n[root@nfs ~]# yum install nfs-utils -y\n\n# 准备一个共享目录\n[root@nfs ~]# mkdir &#x2F;root&#x2F;data&#x2F;nfs -pv\n\n# 将共享目录以读写权限暴露给192.168.5.0&#x2F;24网段中的所有主机\n[root@nfs ~]# vim &#x2F;etc&#x2F;exports\n[root@nfs ~]# more &#x2F;etc&#x2F;exports\n&#x2F;root&#x2F;data&#x2F;nfs     192.168.5.0&#x2F;24(rw,no_root_squash)\n\n# 启动nfs服务\n[root@nfs ~]# systemctl restart nfs\n\n2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备\n# 在node上安装nfs服务，注意不需要启动\n[root@k8s-master01 ~]# yum install nfs-utils -y\n\n3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: volume-nfs\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    ports:\n    - containerPort: 80\n    volumeMounts:\n    - name: logs-volume\n      mountPath: &#x2F;var&#x2F;log&#x2F;nginx\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;tail -f &#x2F;logs&#x2F;access.log&quot;] \n    volumeMounts:\n    - name: logs-volume\n      mountPath: &#x2F;logs\n  volumes:\n  - name: logs-volume\n    nfs:\n      server: 192.168.5.6  #nfs服务器地址\n      path: &#x2F;root&#x2F;data&#x2F;nfs #共享文件路径\n\n4）最后，运行下pod，观察结果\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f volume-nfs.yaml\npod&#x2F;volume-nfs created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods volume-nfs -n dev\nNAME                  READY   STATUS    RESTARTS   AGE\nvolume-nfs        2&#x2F;2     Running   0          2m9s\n\n# 查看nfs服务器上的共享目录，发现已经有文件了\n[root@k8s-master01 ~]# ls &#x2F;root&#x2F;data&#x2F;\naccess.log  error.log\n\n8.2 高级存储前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。\nPV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。\nPVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。\n\n使用了PV和PVC之后，工作可以得到进一步的细分：\n\n存储：存储工程师维护\nPV： kubernetes管理员维护\nPVC：kubernetes用户维护\n\n8.2.1 PVPV是存储资源的抽象，下面是资源清单文件:\napiVersion: v1  \nkind: PersistentVolume\nmetadata:\n  name: pv2\nspec:\n  nfs: # 存储类型，与底层真正存储对应\n  capacity:  # 存储能力，目前只支持存储空间的设置\n    storage: 2Gi\n  accessModes:  # 访问模式\n  storageClassName: # 存储类别\n  persistentVolumeReclaimPolicy: # 回收策略\n\nPV 的关键配置参数说明：\n\n存储类型\n底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异\n\n存储能力（capacity）\n\n\n目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置\n\n访问模式（accessModes）\n用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：\n\nReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载\nReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载\nReadWriteMany（RWX）：读写权限，可以被多个节点挂载\n\n需要注意的是，底层不同的存储类型可能支持的访问模式不同\n\n回收策略（persistentVolumeReclaimPolicy）\n当PV不再被使用了之后，对其的处理方式。目前支持三种策略：\n\nRetain （保留） 保留数据，需要管理员手工清理数据\nRecycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*\nDelete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务\n\n需要注意的是，底层不同的存储类型可能支持的回收策略不同\n\n存储类别\nPV可以通过storageClassName参数指定一个存储类别\n\n具有特定类别的PV只能与请求了该类别的PVC进行绑定\n未设定类别的PV则只能与不请求任何类别的PVC进行绑定\n\n\n状态（status）\n一个 PV 的生命周期中，可能会处于4中不同的阶段：\n\nAvailable（可用）： 表示可用状态，还未被任何 PVC 绑定\nBound（已绑定）： 表示 PV 已经被 PVC 绑定\nReleased（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明\nFailed（失败）： 表示该 PV 的自动回收失败\n\n\n\n实验\n使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。\n\n准备NFS环境\n\n# 创建目录\n[root@nfs ~]# mkdir &#x2F;root&#x2F;data&#x2F;&#123;pv1,pv2,pv3&#125; -pv\n\n# 暴露服务\n[root@nfs ~]# more &#x2F;etc&#x2F;exports\n&#x2F;root&#x2F;data&#x2F;pv1     192.168.5.0&#x2F;24(rw,no_root_squash)\n&#x2F;root&#x2F;data&#x2F;pv2     192.168.5.0&#x2F;24(rw,no_root_squash)\n&#x2F;root&#x2F;data&#x2F;pv3     192.168.5.0&#x2F;24(rw,no_root_squash)\n\n# 重启服务\n[root@nfs ~]#  systemctl restart nfs\n\n\n创建pv.yaml\n\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name:  pv1\nspec:\n  capacity: \n    storage: 1Gi\n  accessModes:\n  - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n    path: &#x2F;root&#x2F;data&#x2F;pv1\n    server: 192.168.5.6\n\n---\n\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name:  pv2\nspec:\n  capacity: \n    storage: 2Gi\n  accessModes:\n  - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n    path: &#x2F;root&#x2F;data&#x2F;pv2\n    server: 192.168.5.6\n    \n---\n\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name:  pv3\nspec:\n  capacity: \n    storage: 3Gi\n  accessModes:\n  - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n    path: &#x2F;root&#x2F;data&#x2F;pv3\n    server: 192.168.5.6\n\n# 创建 pv\n[root@k8s-master01 ~]# kubectl create -f pv.yaml\npersistentvolume&#x2F;pv1 created\npersistentvolume&#x2F;pv2 created\npersistentvolume&#x2F;pv3 created\n\n# 查看pv\n[root@k8s-master01 ~]# kubectl get pv -o wide\nNAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE\npv1    1Gi        RWX            Retain        Available    10s   Filesystem\npv2    2Gi        RWX            Retain        Available    10s   Filesystem\npv3    3Gi        RWX            Retain        Available    9s    Filesystem\n\n8.2.2 PVCPVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc\n  namespace: dev\nspec:\n  accessModes: # 访问模式\n  selector: # 采用标签对PV选择\n  storageClassName: # 存储类别\n  resources: # 请求空间\n    requests:\n      storage: 5Gi\n\nPVC 的关键配置参数说明：\n\n访问模式（accessModes）\n\n用于描述用户应用对存储资源的访问权限\n\n选择条件（selector）\n通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选\n\n存储类别（storageClassName）\nPVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出\n\n资源请求（Resources ）\n描述对存储资源的请求\n\n\n实验\n\n创建pvc.yaml，申请pv\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc1\n  namespace: dev\nspec:\n  accessModes: \n  - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc2\n  namespace: dev\nspec:\n  accessModes: \n  - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc3\n  namespace: dev\nspec:\n  accessModes: \n  - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n\n# 创建pvc\n[root@k8s-master01 ~]# kubectl create -f pvc.yaml\npersistentvolumeclaim&#x2F;pvc1 created\npersistentvolumeclaim&#x2F;pvc2 created\npersistentvolumeclaim&#x2F;pvc3 created\n\n# 查看pvc\n[root@k8s-master01 ~]# kubectl get pvc  -n dev -o wide\nNAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE\npvc1   Bound    pv1      1Gi        RWX                           15s   Filesystem\npvc2   Bound    pv2      2Gi        RWX                           15s   Filesystem\npvc3   Bound    pv3      3Gi        RWX                           15s   Filesystem\n\n# 查看pv\n[root@k8s-master01 ~]# kubectl get pv -o wide\nNAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE\npv1    1Gi        RWx        Retain          Bound    dev&#x2F;pvc1    3h37m    Filesystem\npv2    2Gi        RWX        Retain          Bound    dev&#x2F;pvc2    3h37m    Filesystem\npv3    3Gi        RWX        Retain          Bound    dev&#x2F;pvc3    3h37m    Filesystem   \n\n\n创建pods.yaml, 使用pv\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod1\n  namespace: dev\nspec:\n  containers:\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod1 &gt;&gt; &#x2F;root&#x2F;out.txt; sleep 10; done;&quot;]\n    volumeMounts:\n    - name: volume\n      mountPath: &#x2F;root&#x2F;\n  volumes:\n    - name: volume\n      persistentVolumeClaim:\n        claimName: pvc1\n        readOnly: false\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod2\n  namespace: dev\nspec:\n  containers:\n  - name: busybox\n    image: busybox:1.30\n    command: [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod2 &gt;&gt; &#x2F;root&#x2F;out.txt; sleep 10; done;&quot;]\n    volumeMounts:\n    - name: volume\n      mountPath: &#x2F;root&#x2F;\n  volumes:\n    - name: volume\n      persistentVolumeClaim:\n        claimName: pvc2\n        readOnly: false\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pods.yaml\npod&#x2F;pod1 created\npod&#x2F;pod2 created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide\nNAME   READY   STATUS    RESTARTS   AGE   IP            NODE   \npod1   1&#x2F;1     Running   0          14s   10.244.1.69   node1   \npod2   1&#x2F;1     Running   0          14s   10.244.1.70   node1  \n\n# 查看pvc\n[root@k8s-master01 ~]# kubectl get pvc -n dev -o wide\nNAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE\npvc1   Bound    pv1      1Gi        RWX               94m   Filesystem\npvc2   Bound    pv2      2Gi        RWX               94m   Filesystem\npvc3   Bound    pv3      3Gi        RWX               94m   Filesystem\n\n# 查看pv\n[root@k8s-master01 ~]# kubectl get pv -n dev -o wide\nNAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE\npv1    1Gi        RWX            Retain           Bound    dev&#x2F;pvc1    5h11m   Filesystem\npv2    2Gi        RWX            Retain           Bound    dev&#x2F;pvc2    5h11m   Filesystem\npv3    3Gi        RWX            Retain           Bound    dev&#x2F;pvc3    5h11m   Filesystem\n\n# 查看nfs中的文件存储\n[root@nfs ~]# more &#x2F;root&#x2F;data&#x2F;pv1&#x2F;out.txt\nnode1\nnode1\n[root@nfs ~]# more &#x2F;root&#x2F;data&#x2F;pv2&#x2F;out.txt\nnode2\nnode2\n\n8.2.3 生命周期PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：\n\n资源供应：管理员手动创建底层存储和PV\n\n资源绑定：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定\n在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的\n\n一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了\n如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV\n\nPV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了\n\n资源使用：用户可在pod中像volume一样使用pvc\nPod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。\n\n资源释放：用户删除pvc来释放pv\n当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。\n\n资源回收：kubernetes根据pv设置的回收策略进行资源的回收\n对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用\n\n\n\n8.3 配置存储8.3.1 ConfigMapConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。\n创建configmap.yaml，内容如下：\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: configmap\n  namespace: dev\ndata:\n  info: |\n    username:admin\n    password:123456\n\n接下来，使用此配置文件创建configmap\n# 创建configmap\n[root@k8s-master01 ~]# kubectl create -f configmap.yaml\nconfigmap&#x2F;configmap created\n\n# 查看configmap详情\n[root@k8s-master01 ~]# kubectl describe cm configmap -n dev\nName:         configmap\nNamespace:    dev\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\n\nData\n&#x3D;&#x3D;&#x3D;&#x3D;\ninfo:\n----\nusername:admin\npassword:123456\n\nEvents:  &lt;none&gt;\n\n接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-configmap\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    volumeMounts: # 将configmap挂载到目录\n    - name: config\n      mountPath: &#x2F;configmap&#x2F;config\n  volumes: # 引用configmap\n  - name: config\n    configMap:\n      name: configmap\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-configmap.yaml\npod&#x2F;pod-configmap created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pod pod-configmap -n dev\nNAME            READY   STATUS    RESTARTS   AGE\npod-configmap   1&#x2F;1     Running   0          6s\n\n#进入容器\n[root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev &#x2F;bin&#x2F;sh\n# cd &#x2F;configmap&#x2F;config&#x2F;\n# ls\ninfo\n# more info\nusername:admin\npassword:123456\n\n# 可以看到映射已经成功，每个configmap都映射成了一个目录\n# key---&gt;文件     value----&gt;文件中的内容\n# 此时如果更新configmap的内容, 容器中的值也会动态更新\n\n8.3.2 Secret在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。\n\n首先使用base64对数据进行编码\n\n[root@k8s-master01 ~]# echo -n &#39;admin&#39; | base64 #准备username\nYWRtaW4&#x3D;\n[root@k8s-master01 ~]# echo -n &#39;123456&#39; | base64 #准备password\nMTIzNDU2\n\n\n接下来编写secret.yaml，并创建Secret\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: secret\n  namespace: dev\ntype: Opaque\ndata:\n  username: YWRtaW4&#x3D;\n  password: MTIzNDU2\n\n# 创建secret\n[root@k8s-master01 ~]# kubectl create -f secret.yaml\nsecret&#x2F;secret created\n\n# 查看secret详情\n[root@k8s-master01 ~]# kubectl describe secret secret -n dev\nName:         secret\nNamespace:    dev\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nType:  Opaque\nData\n&#x3D;&#x3D;&#x3D;&#x3D;\npassword:  6 bytes\nusername:  5 bytes\n\n\n创建pod-secret.yaml，将上面创建的secret挂载进去：\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-secret\n  namespace: dev\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.17.1\n    volumeMounts: # 将secret挂载到目录\n    - name: config\n      mountPath: &#x2F;secret&#x2F;config\n  volumes:\n  - name: config\n    secret:\n      secretName: secret\n\n# 创建pod\n[root@k8s-master01 ~]# kubectl create -f pod-secret.yaml\npod&#x2F;pod-secret created\n\n# 查看pod\n[root@k8s-master01 ~]# kubectl get pod pod-secret -n dev\nNAME            READY   STATUS    RESTARTS   AGE\npod-secret      1&#x2F;1     Running   0          2m28s\n\n# 进入容器，查看secret信息，发现已经自动解码了\n[root@k8s-master01 ~]# kubectl exec -it pod-secret &#x2F;bin&#x2F;sh -n dev\n&#x2F; # ls &#x2F;secret&#x2F;config&#x2F;\npassword  username\n&#x2F; # more &#x2F;secret&#x2F;config&#x2F;username\nadmin\n&#x2F; # more &#x2F;secret&#x2F;config&#x2F;password\n123456\n\n至此，已经实现了利用secret实现了信息的编码。\n9. 安全认证9.1 访问控制概述Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种客户端进行认证和鉴权操作。\n客户端\n在Kubernetes集群中，客户端通常有两类：\n\nUser Account：一般是独立于kubernetes之外的其他服务管理的用户账号。\nService Account：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。\n\n\n认证、授权与准入控制\nApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：\n\nAuthentication（认证）：身份鉴别，只有正确的账号才能够通过认证\nAuthorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作\nAdmission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。\n\n\n9.2 认证管理Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：\n\nHTTP Base认证：通过用户名+密码的方式认证\n这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。\n\nHTTP Token认证：通过一个Token来识别合法用户\n这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。\n\nHTTPS证书认证：基于CA根证书签名的双向数字证书认证方式\n这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。\n\n\nHTTPS认证大体分为3个过程：\n\n证书申请和下发\nHTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者\n\n客户端和服务端的双向认证\n1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，\n   客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，\n   客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器\n2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，\n   在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法\n\n服务器端和客户端进行通信\n服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。\n服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密\n\n\n\n\n\n\n\n\n\n\n注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可\n9.3 授权管理授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。\n每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。\nAPI Server目前支持以下几种授权策略：\n\nAlwaysDeny：表示拒绝所有请求，一般用于测试\nAlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）\nABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制\nWebhook：通过调用外部REST服务对用户进行授权\nNode：是一种专用模式，用于对kubelet发出的请求进行访问控制\nRBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）\n\nRBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：给哪些对象授予了哪些权限\n其中涉及到了下面几个概念：\n\n对象：User、Groups、ServiceAccount\n角色：代表着一组定义在资源上的可操作动作(权限)的集合\n绑定：将定义好的角色跟用户绑定在一起\n\n\nRBAC引入了4个顶级资源对象：\n\nRole、ClusterRole：角色，用于指定一组权限\nRoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象\n\nRole、ClusterRole\n一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。\n# Role只能对命名空间内的资源进行授权，需要指定nameapce\nkind: Role\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n  namespace: dev\n  name: authorization-role\nrules:\n- apiGroups: [&quot;&quot;]  # 支持的API组列表,&quot;&quot; 空字符串，表示核心API群\n  resources: [&quot;pods&quot;] # 支持的资源对象列表\n  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] # 允许的对资源对象的操作方法列表\n\n# ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n name: authorization-clusterrole\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;pods&quot;]\n  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]\n\n需要详细说明的是，rules中的参数：\n\napiGroups: 支持的API组列表\n&quot;&quot;,&quot;apps&quot;, &quot;autoscaling&quot;, &quot;batch&quot;\n\nresources：支持的资源对象列表\n&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;,&quot;secrets&quot;,&quot;configmaps&quot;,&quot;crontabs&quot;,&quot;deployments&quot;,&quot;jobs&quot;,\n&quot;nodes&quot;,&quot;rolebindings&quot;,&quot;clusterroles&quot;,&quot;daemonsets&quot;,&quot;replicasets&quot;,&quot;statefulsets&quot;,\n&quot;horizontalpodautoscalers&quot;,&quot;replicationcontrollers&quot;,&quot;cronjobs&quot;\n\nverbs：对资源对象的操作方法列表\n&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;exec&quot;\n\nRoleBinding、ClusterRoleBinding\n角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。\n# RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n  name: authorization-role-binding\n  namespace: dev\nsubjects:\n- kind: User\n  name: heima\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: authorization-role\n  apiGroup: rbac.authorization.k8s.io\n\n# ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限\nkind: ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n name: authorization-clusterrole-binding\nsubjects:\n- kind: User\n  name: heima\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: ClusterRole\n  name: authorization-clusterrole\n  apiGroup: rbac.authorization.k8s.io\n\nRoleBinding引用ClusterRole进行授权\nRoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。\n一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。\n\n# 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding\n# 所以heima只能读取dev命名空间中的资源\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n  name: authorization-role-binding-ns\n  namespace: dev\nsubjects:\n- kind: User\n  name: heima\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: ClusterRole\n  name: authorization-clusterrole\n  apiGroup: rbac.authorization.k8s.io\n\n实战：创建一个只能管理dev空间下Pods资源的账号\n\n创建账号\n\n# 1) 创建证书\n[root@k8s-master01 pki]# cd &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;\n[root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048)\n\n# 2) 用apiserver的证书去签署\n# 2-1) 签名申请，申请的用户是devman,组是devgroup\n[root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;&#x2F;CN&#x3D;devman&#x2F;O&#x3D;devgroup&quot;     \n# 2-2) 签署证书\n[root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650\n\n# 3) 设置集群、用户、上下文信息\n[root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs&#x3D;true --certificate-authority&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt --server&#x3D;https:&#x2F;&#x2F;192.168.109.100:6443\n\n[root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs&#x3D;true --client-certificate&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;devman.crt --client-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;devman.key\n\n[root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster&#x3D;kubernetes --user&#x3D;devman\n\n# 切换账户到devman\n[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes\nSwitched to context &quot;devman@kubernetes&quot;.\n\n# 查看dev下pod，发现没有权限\n[root@k8s-master01 pki]# kubectl get pods -n dev\nError from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;\n\n# 切换到admin账户\n[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes\nSwitched to context &quot;kubernetes-admin@kubernetes&quot;.\n\n2） 创建Role和RoleBinding，为devman用户授权\nkind: Role\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n  namespace: dev\n  name: dev-role\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;pods&quot;]\n  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]\n  \n---\n\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io&#x2F;v1beta1\nmetadata:\n  name: authorization-role-binding\n  namespace: dev\nsubjects:\n- kind: User\n  name: devman\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: dev-role\n  apiGroup: rbac.authorization.k8s.io\n\n[root@k8s-master01 pki]# kubectl create -f dev-role.yaml\nrole.rbac.authorization.k8s.io&#x2F;dev-role created\nrolebinding.rbac.authorization.k8s.io&#x2F;authorization-role-binding created\n\n\n切换账户，再次验证\n\n# 切换账户到devman\n[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes\nSwitched to context &quot;devman@kubernetes&quot;.\n\n# 再次查看\n[root@k8s-master01 pki]# kubectl get pods -n dev\nNAME                                 READY   STATUS             RESTARTS   AGE\nnginx-deployment-66cb59b984-8wp2k    1&#x2F;1     Running            0          4d1h\nnginx-deployment-66cb59b984-dc46j    1&#x2F;1     Running            0          4d1h\nnginx-deployment-66cb59b984-thfck    1&#x2F;1     Running            0          4d1h\n\n# 为了不影响后面的学习,切回admin账户\n[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes\nSwitched to context &quot;kubernetes-admin@kubernetes&quot;.\n\n9.4 准入控制通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。\n准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：\n--admission-control&#x3D;NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,\n                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds\n\n只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。\n当前可配置的Admission Control准入控制如下：\n\nAlwaysAdmit：允许所有请求\nAlwaysDeny：禁止所有请求，一般用于测试\nAlwaysPullImages：在启动容器之前总去下载镜像\nDenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求\nImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。\nService Account：实现ServiceAccount实现了自动化\nSecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效\nResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标\nLimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制\nInitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置\nNamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。\nDefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节\nDefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min\nPodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制\n\n10. DashBoard之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。\n10.1 部署Dashboard\n下载yaml，并运行Dashboard\n\n# 下载yaml\n[root@k8s-master01 ~]# wget  https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml\n\n# 修改kubernetes-dashboard的Service类型\nkind: Service\napiVersion: v1\nmetadata:\n  labels:\n    k8s-app: kubernetes-dashboard\n  name: kubernetes-dashboard\n  namespace: kubernetes-dashboard\nspec:\n  type: NodePort  # 新增\n  ports:\n    - port: 443\n      targetPort: 8443\n      nodePort: 30009  # 新增\n  selector:\n    k8s-app: kubernetes-dashboard\n\n# 部署\n[root@k8s-master01 ~]# kubectl create -f recommended.yaml\n\n# 查看namespace下的kubernetes-dashboard下的资源\n[root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboard\nNAME                                            READY   STATUS    RESTARTS   AGE\npod&#x2F;dashboard-metrics-scraper-c79c65bb7-zwfvw   1&#x2F;1     Running   0          111s\npod&#x2F;kubernetes-dashboard-56484d4c5-z95z5        1&#x2F;1     Running   0          111s\n\nNAME                               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)         AGE\nservice&#x2F;dashboard-metrics-scraper  ClusterIP  10.96.89.218    &lt;none&gt;       8000&#x2F;TCP        111s\nservice&#x2F;kubernetes-dashboard       NodePort   10.104.178.171  &lt;none&gt;       443:30009&#x2F;TCP   111s\n\n2）创建访问账户，获取token\n# 创建账号\n[root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard\n\n# 授权\n[root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole&#x3D;cluster-admin --serviceaccount&#x3D;kubernetes-dashboard:dashboard-admin\n\n# 获取账号token\n[root@k8s-master01 ~]#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin\ndashboard-admin-token-xbqhh        kubernetes.io&#x2F;service-account-token   3      2m35s\n\n[root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard\nName:         dashboard-admin-token-xbqhh\nNamespace:    kubernetes-dashboard\nLabels:       &lt;none&gt;\nAnnotations:  kubernetes.io&#x2F;service-account.name: dashboard-admin\n              kubernetes.io&#x2F;service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039\n\nType:  kubernetes.io&#x2F;service-account-token\n\nData\n&#x3D;&#x3D;&#x3D;&#x3D;\nnamespace:  20 bytes\ntoken:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw\nca.crt:     1025 bytes\n\n3）通过浏览器访问Dashboard的UI\n在登录页面上输入上面的token\n\n出现下面的页面代表成功\n\n10.2 使用DashBoard本章节以Deployment为例演示DashBoard的使用\n查看\n选择指定的命名空间dev，然后点击Deployments，查看dev空间下的所有deployment\n\n扩缩容\n在Deployment上点击规模，然后指定目标副本数量，点击确定\n\n编辑\n在Deployment上点击编辑，然后修改yaml文件，点击确定\n\n查看Pod\n点击Pods, 查看pods列表\n\n操作Pod\n选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作\n\n\n\n\n\n\n\n\n\n\nDashboard提供了kubectl的绝大部分功能，这里不再一一演示\n","slug":"kubernetes-黑马程序员","date":"2022-04-23T13:10:13.000Z","categories_index":"Kubernetes","tags_index":"kubernetes","author_index":"ITLab"},{"id":"84d66273b8c632d9f270cda34aaa6364","title":"Zookeeper集群搭建（3.8.0）","content":"Zookeeper集群搭建（3.8.0）使用vagrant创建三台虚拟机\n#新建Vagrantfile\nVagrant.configure(&quot;2&quot;) do |config|\n\t(1..3).each do |i|\n\t\tconfig.vm.define &quot;node#&#123;i&#125;&quot; do |node|\n\t\t  node.vm.box &#x3D; &quot;centos&#x2F;7&quot;\n\t\t  node.vm.hostname &#x3D; &quot;node#&#123;i&#125;&quot;\n\t\t  node.vm.provider :virtualbox do |v|\n\t\t\tv.memory &#x3D; 1024\n\t\t\tv.cpus &#x3D; 1\n\t\t  end\n\t\t  node.vm.network :private_network, ip: &quot;192.168.56.10#&#123;i&#125;&quot;\n\t\tend\n\tend\nend\n\n\n\n执行\nvagrant up\n\n可以看到virtualbox上已经创建出来三个虚拟机（vagrant默认使用virtualbox）。\n\n通过vagrant创建的三台机器如下图：\n\n\n\n机器名称\nIP地址\n\n\n\nnode1\n192.168.56.101\n\n\nnode2\n192.168.56.102\n\n\nnode3\n192.168.56.103\n\n\n使用如下指令分别ssh连接服务器\nvagrant ssh node1\nvagrant ssh node2\nvagrant ssh node3\n\n\n\n安装一些工具类、zookeeper并解压\nsudo yum install wget -y\nwget https:&#x2F;&#x2F;dlcdn.apache.org&#x2F;zookeeper&#x2F;zookeeper-3.8.0&#x2F;apache-zookeeper-3.8.0-bin.tar.gz --no-check-certificate\ntar zxvf apache-zookeeper-3.8.0-bin.tar.gz &amp;&amp; mv apache-zookeeper-3.8.0-bin zookeeper\n\n三个机器上结构都类似如下：\n[vagrant@node2 ~]$ pwd\n&#x2F;home&#x2F;vagrant\n[vagrant@node2 ~]$ ls\napache-zookeeper-3.8.0-bin.tar.gz  zookeeper\n[vagrant@node2 ~]$\n\n配置说明zookeepeer的集群配置主要关注三点。\n1、server.x配置\n默认情况下，conf目录下只有一个 zoo_sample.cfg文件，需要拷贝一份为 zoo.cfg\n\n2、修改zoo.cfg\n#这是数据目录，默认是&#x2F;tmp&#x2F;zookeeper，这是不允许的，&#x2F;tmp是临时目录，需要修改为自己的路径，我这里修改为自己的&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data,默认没有data目录，需要手动创建。\ndataDir&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data\n#因为是有三个节点，server.x的x是zoo服务器的标志，需要于myid的内容对应，接下来会说myid。顺序排列就可以了，等号后面的内容格式是A:B:C  A代表的是服务器的地址， 可以是hostname，也可以是ip地址，使用hostname需要修改每个服务器的&#x2F;etc&#x2F;hosts文件，使用ip则不用， 我使用的是ip地址。不管使用hostname还是ip都要保证服务器之前可以通信。B代表选举Leader的端口，默认2888， C代表集群内机器通讯使用（Leader监听此端口）默认3888，不用修改，如果你在一个电脑上模拟伪集群，则需要修改，否则端口冲突。\nserver.1&#x3D;192.168.56.101:2888:3888\nserver.2&#x3D;192.168.56.102:2888:3888\nserver.3&#x3D;192.168.56.103:2888:3888\n\n三台机器修改完毕后的zoo.cfg文件内容都是\n[vagrant@node1 conf]$ cat zoo.cfg\n# The number of milliseconds of each tick\ntickTime&#x3D;2000\n# The number of ticks that the initial\n# synchronization phase can take\ninitLimit&#x3D;10\n# The number of ticks that can pass between\n# sending a request and getting an acknowledgement\nsyncLimit&#x3D;5\n# the directory where the snapshot is stored.\n# do not use &#x2F;tmp for storage, &#x2F;tmp here is just\n# example sakes.\n#dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper\n# the port at which the clients will connect\nclientPort&#x3D;2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns&#x3D;60\n#\n# Be sure to read the maintenance section of the\n# administrator guide before turning on autopurge.\n#\n# https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount&#x3D;3\n# Purge task interval in hours\n# Set to &quot;0&quot; to disable auto purge feature\n#autopurge.purgeInterval&#x3D;1\n\n## Metrics Providers\n#\n# https:&#x2F;&#x2F;prometheus.io Metrics Exporter\n#metricsProvider.className&#x3D;org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider\n#metricsProvider.httpHost&#x3D;0.0.0.0\n#metricsProvider.httpPort&#x3D;7000\n#metricsProvider.exportJvmInfo&#x3D;true\n#这是数据目录，默认是&#x2F;tmp&#x2F;zookeeper，这是不允许的，&#x2F;tmp是临时目录，需要修改为自己的路径，我这里修改为自己的&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data,默认没有data目录，需要手动创建。\ndataDir&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data\n#因为是有三个节点，所以顺序排列就可以了，node1和node2和node3是我的host名字，此处也可以使用每个服务器的ip地址，使用hostname需要修改每个服务器的&#x2F;etc&#x2F;hosts文件，使用ip则不用。不管使用hostname还是ip都要保证服务器之前可以通信。2888和3888是zookeeper内部通信接口，不用修改，如果你在一个电脑上模拟伪集群，则需要修改，否则端口冲突。\nserver.1&#x3D;192.168.56.101:2888:3888\nserver.2&#x3D;192.168.56.102:2888:3888\nserver.3&#x3D;192.168.56.103:2888:3888\n\n\n\n3、需要在每个机器的dataDir目录下创建myid文件。里面的内容对应的就是server.x的x，比如node1的myid内容是1，node2的myid内容是2，node3的myid内容是3\n#在node1虚拟机的&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data目录上执行\n[vagrant@node1 data]$ pwd\n&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data\n[vagrant@node1 data]$ echo &quot;1&quot; &gt; myid\n#在node2虚拟机的&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data目录上执行\n[vagrant@node2 data]$ pwd\n&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data\n[vagrant@node2 data]$ echo &quot;2&quot; &gt; myid\n#在node3虚拟机的&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data目录上执行\n[vagrant@node3 data]$ pwd\n&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;data\n[vagrant@node3 data]$ echo &quot;3&quot; &gt; myid\n\n4、zookeeper需要jdk的支持\nsudo yum install java-1.8.0-openjdk -y\n\n\n\n启动分别在node1、node2、node3上进入zookeeper目录后，启动\nbin&#x2F;zkServer.sh status\n\n这里需要注意，第一台启动的时候，可能提示如下信息，不用管\n[vagrant@node1 zookeeper]$ bin&#x2F;zkServer.sh status\n&#x2F;usr&#x2F;bin&#x2F;java\nZooKeeper JMX enabled by default\nUsing config: &#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg\nClient port found: 2181. Client address: localhost. Client SSL: false.\nError contacting service. It is probably not running.\n\n这是因为要跟其他两个服务器通信，但是其他两台的zookeeper还未启动，忽略。\n三台服务器启动完毕后，查看状态。\n#node1服务器\n[vagrant@node1 zookeeper]$ bin&#x2F;zkServer.sh status\n&#x2F;usr&#x2F;bin&#x2F;java\nZooKeeper JMX enabled by default\nUsing config: &#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg\nClient port found: 2181. Client address: localhost. Client SSL: false.\nMode: follower\n#node2服务器\n[vagrant@node2 zookeeper]$ bin&#x2F;zkServer.sh status\n&#x2F;usr&#x2F;bin&#x2F;java\nZooKeeper JMX enabled by default\nUsing config: &#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg\nClient port found: 2181. Client address: localhost. Client SSL: false.\nMode: leader\n#node3服务器\n[vagrant@node3 zookeeper]$ bin&#x2F;zkServer.sh status\n&#x2F;usr&#x2F;bin&#x2F;java\nZooKeeper JMX enabled by default\nUsing config: &#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg\nClient port found: 2181. Client address: localhost. Client SSL: false.\nMode: follower\n\n测试使用zkCli.sh 连接leader(node1服务器)，创建一个叫做test的node。\n[vagrant@node2 zookeeper]$ bin&#x2F;zkCli.sh\n&#x2F;usr&#x2F;bin&#x2F;java\nConnecting to localhost:2181\n2022-03-30 04:18:52,326 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:zookeeper.version&#x3D;3.8.0-5a02a05eddb59aee6ac762f7ea82e92a68eb9c0f, built on 2022-02-25 08:49 UTC\n2022-03-30 04:18:52,327 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:host.name&#x3D;node2\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.version&#x3D;1.8.0_322\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.vendor&#x3D;Red Hat, Inc.\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.home&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64&#x2F;jre\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.class.path&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-prometheus-metrics-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-jute-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;snappy-java-1.1.7.7.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;slf4j-api-1.7.30.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_servlet-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_hotspot-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_common-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-unix-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-classes-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-classes-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-resolver-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-handler-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-codec-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-buffer-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;metrics-core-4.1.12.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-core-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-classic-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jline-2.14.6.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-ajax-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-servlet-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-server-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-security-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-io-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-http-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;javax.servlet-api-3.1.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-databind-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-core-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-annotations-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-io-2.11.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-cli-1.4.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;audience-annotations-0.12.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf:\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.library.path&#x3D;&#x2F;usr&#x2F;java&#x2F;packages&#x2F;lib&#x2F;amd64:&#x2F;usr&#x2F;lib64:&#x2F;lib64:&#x2F;lib:&#x2F;usr&#x2F;lib\n2022-03-30 04:18:52,328 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.io.tmpdir&#x3D;&#x2F;tmp\n2022-03-30 04:18:52,353 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.compiler&#x3D;&lt;NA&gt;\n2022-03-30 04:18:52,353 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.name&#x3D;Linux\n2022-03-30 04:18:52,353 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.arch&#x3D;amd64\n2022-03-30 04:18:52,353 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.version&#x3D;3.10.0-1127.el7.x86_64\n2022-03-30 04:18:52,353 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.name&#x3D;vagrant\n2022-03-30 04:18:52,354 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.home&#x3D;&#x2F;home&#x2F;vagrant\n2022-03-30 04:18:52,354 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.dir&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper\n2022-03-30 04:18:52,354 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.free&#x3D;10MB\n2022-03-30 04:18:52,354 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.max&#x3D;247MB\n2022-03-30 04:18:52,354 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.total&#x3D;15MB\n2022-03-30 04:18:52,357 [myid:] - INFO  [main:o.a.z.ZooKeeper@637] - Initiating client connection, connectString&#x3D;localhost:2181 sessionTimeout&#x3D;30000 watcher&#x3D;org.apache.zookeeper.ZooKeeperMain$MyWatcher@7c16905e\n2022-03-30 04:18:52,361 [myid:] - INFO  [main:o.a.z.c.X509Util@77] - Setting -D jdk.tls.rejectClientInitiatedRenegotiation&#x3D;true to disable client-initiated TLS renegotiation\n2022-03-30 04:18:52,365 [myid:] - INFO  [main:o.a.z.ClientCnxnSocket@239] - jute.maxbuffer value is 1048575 Bytes\n2022-03-30 04:18:52,376 [myid:] - INFO  [main:o.a.z.ClientCnxn@1732] - zookeeper.request.timeout value is 0. feature enabled&#x3D;false\n2022-03-30 04:18:52,380 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1171] - Opening socket connection to server localhost&#x2F;0:0:0:0:0:0:0:1:2181.\n2022-03-30 04:18:52,381 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1173] - SASL config status: Will not attempt to authenticate using SASL (unknown error)\n2022-03-30 04:18:52,385 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1005] - Socket connection established, initiating session, client: &#x2F;0:0:0:0:0:0:0:1:37554, server: localhost&#x2F;0:0:0:0:0:0:0:1:2181\nWelcome to ZooKeeper!\n2022-03-30 04:18:52,403 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1444] - Session establishment complete on server localhost&#x2F;0:0:0:0:0:0:0:1:2181, session id &#x3D; 0x20000309d020003, negotiated timeout &#x3D; 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\nJLine support is enabled\n[zk: localhost:2181(CONNECTED) 0] create &#x2F;test\nCreated &#x2F;test\n[zk: localhost:2181(CONNECTED) 1]\n\n查看其他服务器是否有test这个node。\nnode2服务器\n[vagrant@node1 zookeeper]$ bin&#x2F;zkCli.sh\n&#x2F;usr&#x2F;bin&#x2F;java\nConnecting to localhost:2181\n2022-03-30 04:22:55,364 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:zookeeper.version&#x3D;3.8.0-5a02a05eddb59aee6ac762f7ea82e92a68eb9c0f, built on 2022-02-25 08:49 UTC\n2022-03-30 04:22:55,366 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:host.name&#x3D;node1\n2022-03-30 04:22:55,366 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.version&#x3D;1.8.0_322\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.vendor&#x3D;Red Hat, Inc.\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.home&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64&#x2F;jre\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.class.path&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-prometheus-metrics-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-jute-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;snappy-java-1.1.7.7.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;slf4j-api-1.7.30.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_servlet-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_hotspot-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_common-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-unix-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-classes-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-classes-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-resolver-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-handler-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-codec-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-buffer-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;metrics-core-4.1.12.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-core-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-classic-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jline-2.14.6.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-ajax-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-servlet-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-server-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-security-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-io-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-http-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;javax.servlet-api-3.1.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-databind-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-core-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-annotations-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-io-2.11.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-cli-1.4.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;audience-annotations-0.12.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf:.:&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64&#x2F;lib&#x2F;dt.jar:&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64&#x2F;lib&#x2F;tools.jar\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.library.path&#x3D;&#x2F;usr&#x2F;java&#x2F;packages&#x2F;lib&#x2F;amd64:&#x2F;usr&#x2F;lib64:&#x2F;lib64:&#x2F;lib:&#x2F;usr&#x2F;lib\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.io.tmpdir&#x3D;&#x2F;tmp\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.compiler&#x3D;&lt;NA&gt;\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.name&#x3D;Linux\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.arch&#x3D;amd64\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.version&#x3D;3.10.0-1127.el7.x86_64\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.name&#x3D;vagrant\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.home&#x3D;&#x2F;home&#x2F;vagrant\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.dir&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.free&#x3D;10MB\n2022-03-30 04:22:55,367 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.max&#x3D;247MB\n2022-03-30 04:22:55,368 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.total&#x3D;15MB\n2022-03-30 04:22:55,370 [myid:] - INFO  [main:o.a.z.ZooKeeper@637] - Initiating client connection, connectString&#x3D;localhost:2181 sessionTimeout&#x3D;30000 watcher&#x3D;org.apache.zookeeper.ZooKeeperMain$MyWatcher@7c16905e\n2022-03-30 04:22:55,374 [myid:] - INFO  [main:o.a.z.c.X509Util@77] - Setting -D jdk.tls.rejectClientInitiatedRenegotiation&#x3D;true to disable client-initiated TLS renegotiation\n2022-03-30 04:22:55,378 [myid:] - INFO  [main:o.a.z.ClientCnxnSocket@239] - jute.maxbuffer value is 1048575 Bytes\n2022-03-30 04:22:55,386 [myid:] - INFO  [main:o.a.z.ClientCnxn@1732] - zookeeper.request.timeout value is 0. feature enabled&#x3D;false\n2022-03-30 04:22:55,397 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1171] - Opening socket connection to server localhost&#x2F;127.0.0.1:2181.\n2022-03-30 04:22:55,397 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1173] - SASL config status: Will not attempt to authenticate using SASL (unknown error)\n2022-03-30 04:22:55,402 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1005] - Socket connection established, initiating session, client: &#x2F;127.0.0.1:52908, server: localhost&#x2F;127.0.0.1:2181\nWelcome to ZooKeeper!\nJLine support is enabled\n2022-03-30 04:22:55,471 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1444] - Session establishment complete on server localhost&#x2F;127.0.0.1:2181, session id &#x3D; 0x1000031544f0000, negotiated timeout &#x3D; 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n[zk: localhost:2181(CONNECTED) 0] ls &#x2F;\n[test, zookeeper]\n[zk: localhost:2181(CONNECTED) 1]\n\n\n\n\nnode3服务器\n[vagrant@node3 zookeeper]$ bin&#x2F;zkCli.sh\n&#x2F;usr&#x2F;bin&#x2F;java\nConnecting to localhost:2181\n2022-03-30 04:20:15,221 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:zookeeper.version&#x3D;3.8.0-5a02a05eddb59aee6ac762f7ea82e92a68eb9c0f, built on 2022-02-25 08:49 UTC\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:host.name&#x3D;node3\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.version&#x3D;1.8.0_322\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.vendor&#x3D;Red Hat, Inc.\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.home&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64&#x2F;jre\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.class.path&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;classes:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;target&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;build&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-prometheus-metrics-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-jute-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;zookeeper-3.8.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;snappy-java-1.1.7.7.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;slf4j-api-1.7.30.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_servlet-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_hotspot-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient_common-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;simpleclient-0.9.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-unix-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-native-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-classes-epoll-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-transport-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-classes-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-tcnative-2.0.48.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-resolver-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-handler-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-common-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-codec-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;netty-buffer-4.1.73.Final.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;metrics-core-4.1.12.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-core-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;logback-classic-1.2.10.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jline-2.14.6.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-ajax-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-util-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-servlet-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-server-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-security-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-io-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jetty-http-9.4.43.v20210629.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;javax.servlet-api-3.1.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-databind-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-core-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;jackson-annotations-2.13.1.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-io-2.11.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;commons-cli-1.4.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;lib&#x2F;audience-annotations-0.12.0.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;zookeeper-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;*.jar:&#x2F;home&#x2F;vagrant&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf:\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.library.path&#x3D;&#x2F;usr&#x2F;java&#x2F;packages&#x2F;lib&#x2F;amd64:&#x2F;usr&#x2F;lib64:&#x2F;lib64:&#x2F;lib:&#x2F;usr&#x2F;lib\n2022-03-30 04:20:15,223 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.io.tmpdir&#x3D;&#x2F;tmp\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:java.compiler&#x3D;&lt;NA&gt;\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.name&#x3D;Linux\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.arch&#x3D;amd64\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.version&#x3D;3.10.0-1127.el7.x86_64\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.name&#x3D;vagrant\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.home&#x3D;&#x2F;home&#x2F;vagrant\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:user.dir&#x3D;&#x2F;home&#x2F;vagrant&#x2F;zookeeper\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.free&#x3D;10MB\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.max&#x3D;247MB\n2022-03-30 04:20:15,224 [myid:] - INFO  [main:o.a.z.Environment@98] - Client environment:os.memory.total&#x3D;15MB\n2022-03-30 04:20:15,227 [myid:] - INFO  [main:o.a.z.ZooKeeper@637] - Initiating client connection, connectString&#x3D;localhost:2181 sessionTimeout&#x3D;30000 watcher&#x3D;org.apache.zookeeper.ZooKeeperMain$MyWatcher@7c16905e\n2022-03-30 04:20:15,231 [myid:] - INFO  [main:o.a.z.c.X509Util@77] - Setting -D jdk.tls.rejectClientInitiatedRenegotiation&#x3D;true to disable client-initiated TLS renegotiation\n2022-03-30 04:20:15,235 [myid:] - INFO  [main:o.a.z.ClientCnxnSocket@239] - jute.maxbuffer value is 1048575 Bytes\n2022-03-30 04:20:15,249 [myid:] - INFO  [main:o.a.z.ClientCnxn@1732] - zookeeper.request.timeout value is 0. feature enabled&#x3D;false\n2022-03-30 04:20:15,254 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1171] - Opening socket connection to server localhost&#x2F;0:0:0:0:0:0:0:1:2181.\n2022-03-30 04:20:15,255 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1173] - SASL config status: Will not attempt to authenticate using SASL (unknown error)\n2022-03-30 04:20:15,259 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1005] - Socket connection established, initiating session, client: &#x2F;0:0:0:0:0:0:0:1:37874, server: localhost&#x2F;0:0:0:0:0:0:0:1:2181\nWelcome to ZooKeeper!\nJLine support is enabled\n2022-03-30 04:20:15,338 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):o.a.z.ClientCnxn$SendThread@1444] - Session establishment complete on server localhost&#x2F;0:0:0:0:0:0:0:1:2181, session id &#x3D; 0x300003148b90000, negotiated timeout &#x3D; 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n[zk: localhost:2181(CONNECTED) 0] ls &#x2F;\n[test, zookeeper]\n[zk: localhost:2181(CONNECTED) 1]\n\n可以看到node2和node3服务器上的zookeeper也有&#x2F;test这个node。说明集群没问题。\nWEBUI浏览使用docker部署webUI\ndocker run -d -p *080:8080 -e ZK_DEFAULT_NODE&#x3D;192.168.56.102:2181&#x2F; -e USER&#x3D;zkweb -e PASSWORD&#x3D;zkweb --name zk-web -t tobilg&#x2F;zookeeper-webui\n\n访问\n\n\n","slug":"Zookeeper集群搭建（3-8-0）","date":"2022-04-23T13:01:21.000Z","categories_index":"Zookeeper","tags_index":"Zookeeper cluster,3.8.0","author_index":"ITLab"},{"id":"63b66b84785bad4685f03c761bd73fdb","title":"spring-authorization-server授权服务器Oauth2.1（新版）","content":"\n\n\n\n\n\n\n\n\n说明\nspring Security5 时候，不推荐使用spring-security-oauth2。提供了新的方法（https://github.com/spring-projects/spring-authorization-server）\n\n需要注意的是该方式支持的并不是oauth2，而是oauth2.1，什么是oauth2.1呢？推荐查看：https://oauth.net/2.1/和https://aaronparecki.com/2019/12/12/21/its-time-for-oauth-2-dot-1。\n摘取oauth2.net网站上对比oauth2的说明：\n主要区别（以下使用翻译软件翻译，大致意思没错）\n\n使用授权代码流的所有 OAuth 客户端都需要 PKCE\n必须使用精确的字符串匹配来比较重定向 URI\nresponse_type=token本规范中省略了隐式授权 ( )\n本规范中省略了资源所有者密码凭证授权\n不记名令牌用法省略了在 URI 的查询字符串中使用不记名令牌\n公共客户端的刷新令牌必须受发送方限制或一次性使用\n\n\n\n\n\n\n\n\n\n\n官方demo运行\n根据https://github.com/spring-projects/spring-authorization-server上说明使用gradle命令运行即可。\n\n\n\n\n\n\n\n\n\n\n拷贝官方代码（基本未做更改），使用postman进行测试。\n    代码位置：authorization-server\n\n​\t\t\nauthorization-server\n├── README.md\n├── authorization-server.iml\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── xpp\n    │   │           └── ssgo\n    │   │               └── as\n    │   │                   ├── AuthorizationServerApplication.java\n    │   │                   ├── config\n    │   │                   │   ├── SecurityConfig.java\n    │   │                   │   └── WebAuthorizationServerConfig.java\n    │   │                   └── jose\n    │   │                       ├── Jwks.java\n    │   │                       └── KeyGeneratorUtils.java\n    │   └── resources\n    │       ├── data.sql\n    │       └── application.yml\n    └── test\n        └── java\n\n\n\n\n\n\n\n\n\n\n\n\n测试\n\n启动项目\n查看自动创建的表结构：\n浏览器访问：https://localhost:8080/h2-console\n\n点击Connect：\n\n我们看到有五张表创建，打开表会发现数据也被初始化进去了。\n\n授权码模式\n请求授权码模式地址：http://localhost:8080/oauth2/authorize?response_type=code&amp;client_id=messaging-client&amp;scope=message.read&amp;redirect_uri=https://baidu.com\n\n输入用户名密码(user1, password):\n\n勾选授权scope，点击submit consent按钮：\n\n拷贝地址栏：https://www.baidu.com/?code=dPEZCnsiz2WPk5mWdnPImxbSQkbwK7-yPKmg56JuR2NHbswtbXWZFjgZr6MEXfIqi8JhRourmlSSYVVfGuCN-46ep8jbQwxHsqrUVeeY-1XRHkpqaQ2UM9-ulbTsU0mg\n授权码code&#x3D;dPEZCnsiz2WPk5mWdnPImxbSQkbwK7-yPKmg56JuR2NHbswtbXWZFjgZr6MEXfIqi8JhRourmlSSYVVfGuCN-46ep8jbQwxHsqrUVeeY-1XRHkpqaQ2UM9-ulbTsU0mg\n打开postman 通过该code获取access_token:\n\n\n点击send，返回：\n\nJSON数据如下：\n&#123;\n    &quot;access_token&quot;: &quot;eyJraWQiOiI3NzlmYTBkMC1kYmI5LTRkOGMtYTljNy1iMWE3N2U1MjU3ZDMiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ1c2VyMSIsImF1ZCI6Im1lc3NhZ2luZy1jbGllbnQiLCJuYmYiOjE2Mjk4ODM3NTgsInNjb3BlIjpbIm1lc3NhZ2UucmVhZCJdLCJpc3MiOiJodHRwOlwvXC9hdXRoLXNlcnZlcjo5MDAwIiwiZXhwIjoxNjI5ODg0MDU4LCJpYXQiOjE2Mjk4ODM3NTh9.DONZ0BYwqikDpX36yifOraxr6h_AX4uUAbLqnitC1vEaRHIZVuaSXcLesXx2XxIOyfKu-gglMxho83-JnNU60sX9QQVgnzsHQIExFoBtnFIOmj6mrxOcuTLFWEjya1fqN9rRDAHDInNkTpHICdzKWAtnRR_N7Xwt87B7EwcmAaZedLEyRZo6xQWrx_nIDIsdalxDHricniK7lYxMRHBzXIiV7hIFUtjfPCTGGUhuV3Etu5WGJpo9loOGezTydttvcHttlC8A71viDBR8jD0fQ5Z6NZuq1CfK3rBoh1jXmGUp8g8fi7WTeA2zKyLYYYPSot5FiHcecpc9bAPIh8oPEA&quot;,\n    &quot;refresh_token&quot;: &quot;m166TmZ_o8XpP_wunxsjRRHqH5qbyMMVZz6-tRPQe_73DiKKd5ujdA8TdiwPDgxw6bnYE6MjlTcLy7Cc30BDYsZhHwr7PKXqX0QyQCwkiFRIkrmQOmvCAl-GO_R4gwWZ&quot;,\n    &quot;scope&quot;: &quot;message.read&quot;,\n    &quot;token_type&quot;: &quot;Bearer&quot;,\n    &quot;expires_in&quot;: 299\n&#125;\n\n刷新token\n\n\n请求后结果：\n\nJSON数据是：\n&#123;\n    &quot;access_token&quot;: &quot;eyJraWQiOiI3NzlmYTBkMC1kYmI5LTRkOGMtYTljNy1iMWE3N2U1MjU3ZDMiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ1c2VyMSIsImF1ZCI6Im1lc3NhZ2luZy1jbGllbnQiLCJuYmYiOjE2Mjk4ODM5MzgsInNjb3BlIjpbIm1lc3NhZ2UucmVhZCJdLCJpc3MiOiJodHRwOlwvXC9hdXRoLXNlcnZlcjo5MDAwIiwiZXhwIjoxNjI5ODg0MjM4LCJpYXQiOjE2Mjk4ODM5Mzh9.GoCvmcLHIWYEN7-_jJQw3cOAC1TOH_If6VuxhgzsRIw2jfeJlgdKRxC9a_meRzoZGWcDb95aM_BPEwFgXsOgiXM5u_NTTaB9j6xEOoaTP_KA8V9bbqw63C-_nYlIzRQwYZUy4YHFDA-bOrUGjZxtRbr1WxP27iwiSMnXQ8XOI8P-gN5mr3EW7gxIr7vtoP1duwmqROirUuskw74YAr2l6ZDxdn7AEG17Qqb5gWYU9j61NHuyJGT7Vy1RQJT_G__vsLVaf-1z7CnE1_9IxSRGQf4TlKDG2F2C7TEGqGnNXQa5Sc-CPjh7hNHEirqH0_rBnKFwG9irtbS7eCFLporjkg&quot;,\n    &quot;refresh_token&quot;: &quot;m166TmZ_o8XpP_wunxsjRRHqH5qbyMMVZz6-tRPQe_73DiKKd5ujdA8TdiwPDgxw6bnYE6MjlTcLy7Cc30BDYsZhHwr7PKXqX0QyQCwkiFRIkrmQOmvCAl-GO_R4gwWZ&quot;,\n    &quot;scope&quot;: &quot;message.read&quot;,\n    &quot;token_type&quot;: &quot;Bearer&quot;,\n    &quot;expires_in&quot;: 300\n&#125;\n\n简化模式（response_type&#x3D;token）在oauth2.1被移除.\n\n客户端模式：\n\n\n返回结果如图：\n\nJSON结果：\n&#123;\n    &quot;access_token&quot;: &quot;eyJraWQiOiJjOGRhNzAwZC0zNzUyLTQyMTMtOTFmZi1hOTlmMjY5NTU4NTciLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJtZXNzYWdpbmctY2xpZW50IiwiYXVkIjoibWVzc2FnaW5nLWNsaWVudCIsIm5iZiI6MTYyOTg4MzEzNywic2NvcGUiOlsib3BlbmlkIiwibWVzc2FnZS5yZWFkIiwibWVzc2FnZS53cml0ZSJdLCJpc3MiOiJodHRwOlwvXC9hdXRoLXNlcnZlcjo5MDAwIiwiZXhwIjoxNjI5ODgzNDM3LCJpYXQiOjE2Mjk4ODMxMzd9.NvTu-y5AxLXLSSC_FvxgG3ZYCsOdQRBQgay5sZOmgPAPHcNrTeau7RtdQPoYL7rxedbbfgzBzBOQA3wYepMcuWqO7DBc3kB-I6D6c8nImMo24hSVDTXqnGEtyAUWUhiWJPY1IvVmgksZdaemXQUjFQmBM6Lxt32nBVz8Ap7NXb4oqIbr2bkYodvPRLdYY0PeMpPKAqJuKl4nnRzTCGWx9koJ4KGynkCo3KtMjpv3WuarVKpyiUIhTRlOOAI7wrGplFukaKXpNriMMwasFNtcKfSdWQ6iIDtFs1oUOfE7NJ8EY1FkUaZP1brrHzJgrSvaQPATOfNMFWAA7MN6DzUrlQ&quot;,\n    &quot;scope&quot;: &quot;openid message.read message.write&quot;,\n    &quot;token_type&quot;: &quot;Bearer&quot;,\n    &quot;expires_in&quot;: 300\n&#125;\n\n密码模式 在oauth2.1被移除。\n之前以为是bug，就给提了issue（https://github.com/spring-projects/spring-authorization-server/issues/419），官方回复不支持。\n但是有扩展方式。还没弄。具体可看我提出的issue的作者回复。\n\n\n\n\n\n\n\n\n\n\n\nspring-security-oauth2的实现方式，可查看我之前的笔记\n知乎：https://zhuanlan.zhihu.com/p/403379055\ngithub源码：https://github.com/xpp1109/spring-security-lt5-oauth2\n\n\n\n\n\n\n\n\n\n本文内容github地址是：https://github.com/xpp1109/spring-security-gte5-oauth2\n\n\n\n\n\n\n\n\n\n一键三联，关注、点赞、分享。完结撒花，谢谢！\n\n梦想越是美丽，就越是显得遥不可及。可奇怪的是，一旦你下定了决心，很快地，那些梦想就一一成为了现实！\n\n","slug":"新版authorization-server","date":"2022-04-22T09:57:14.000Z","categories_index":"Java,Spring Security,Spring Boot","tags_index":"Spring Security,spring-authorization-server,Oauth2.1,Java","author_index":"ITLab"}]